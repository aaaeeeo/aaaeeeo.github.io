<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Throne â€” Tactical Hex Duel</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0a0a0c;
            --bg-panel: #111114;
            --bg-hex: #16161a;
            --bg-hex-hover: #1e1e24;
            --border: #2a2a32;
            --text-primary: #e8e6e3;
            --text-muted: #6b6b76;
            --accent-gold: #d4af37;
            --accent-gold-dim: #a68a2a;
            --player1: #c94c4c;
            --player1-dim: #8a3535;
            --player2: #4c8bc9;
            --player2-dim: #35628a;
            --player-cpu: #a855f7;
            --player-cpu-dim: #7c3aed;
            --throne: #d4af37;
            --pin-indicator: #ff6b6b;
            --valid-move: rgba(100, 200, 100, 0.3);
            --damage-path: rgba(255, 165, 0, 0.5);
            --path-highlight: rgba(100, 150, 255, 0.4);
            --path-end-highlight: rgba(100, 150, 255, 0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .game-container {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            min-height: 100vh;
            gap: 0;
        }

        /* Left Panel - Game State */
        .panel {
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel-right {
            border-right: none;
            border-left: 1px solid var(--border);
            overflow-y: auto;
            max-height: 100vh;
        }

        .panel-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-muted);
            margin-bottom: 12px;
            font-family: 'JetBrains Mono', monospace;
        }

        .logo {
            font-size: 28px;
            font-weight: 700;
            letter-spacing: 4px;
            text-align: center;
            color: var(--accent-gold);
            padding: 16px 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 8px;
        }

        .turn-indicator {
            text-align: center;
            padding: 20px;
            background: var(--bg-hex);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .turn-indicator .player-name {
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .turn-indicator.player1 .player-name {
            color: var(--player1);
        }

        .turn-indicator.player2 .player-name {
            color: var(--player2);
        }

        .actions-remaining {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            color: var(--text-muted);
        }

        .actions-remaining span {
            color: var(--accent-gold);
            font-weight: 500;
        }



        .army-display {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid var(--border);
        }

        .army-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .army-title.player1 {
            color: var(--player1);
        }

        .army-title.player2 {
            color: var(--player2);
        }

        .army-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .army-piece {
            width: 36px;
            height: 36px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.15s;
            border: 2px solid transparent;
        }

        .army-piece:hover {
            transform: scale(1.1);
        }

        .army-piece.player1 {
            background: var(--player1-dim);
        }

        .army-piece.player2 {
            background: var(--player2-dim);
        }

        .army-piece.dead {
            opacity: 0.3;
            pointer-events: none;
        }

        .army-piece.pinned {
            border-color: var(--pin-indicator);
        }

        /* Board Area */
        .board-area {
            display: flex;
            align-items: center;
            justify-content: center;
            background:
                radial-gradient(ellipse at center, rgba(212, 175, 55, 0.03) 0%, transparent 60%),
                var(--bg-dark);
            position: relative;
        }

        #game-board {
            cursor: default;
        }

        .hex {
            fill: var(--bg-hex);
            stroke: var(--border);
            stroke-width: 1.1;
            transition: all 0.2s;
            cursor: pointer;
        }

        /* Ring colors - distinct variations to help identify pins */
        .hex.ring-0 {
            fill: rgba(212, 175, 55, 0.3);
            /* Throne ring - gold tint */
        }

        .hex.ring-1 {
            fill: #0a0a0e;
            stroke: #ff2e2e;
            stroke-opacity: 0.2;
        }

        .hex.ring-2 {
            fill: #0e0e14;
            stroke: #22c55e;
            stroke-opacity: 0.2;
        }

        .hex.ring-3 {
            fill: #121218;
            stroke: #3b82f6;
            stroke-opacity: 0.2;
        }

        .hex.ring-4 {
            fill: #16161c;
            stroke: #f59e0b;
            stroke-opacity: 0.2;
        }

        .hex.ring-5 {
            fill: #1a1a20;
            stroke: #df24ff;
            stroke-opacity: 0.2;
        }

        .hex:hover {
            fill: var(--bg-hex-hover);
        }

        .hex.throne {
            fill: rgba(212, 175, 55, 0.15);
            stroke: var(--accent-gold);
            stroke-width: 2;
        }

        .hex.valid-move {
            fill: var(--valid-move);
        }

        .hex.damage-path {
            fill: var(--damage-path);
        }

        .hex.selected {
            stroke: var(--accent-gold);
            stroke-width: 3;
        }

        .hex.path-step {
            fill: var(--path-highlight);
            stroke: var(--path-highlight);
            stroke-width: 2;
        }

        .hex.path-end {
            fill: var(--path-end-highlight);
            stroke: var(--path-end-highlight);
            stroke-width: 3;
        }

        /* Keep throne's yellow outline visible even when part of a path */
        .hex.throne.path-step,
        .hex.throne.path-end {
            stroke: var(--accent-gold);
            stroke-width: 3;
        }

        .piece {
            cursor: pointer;
        }

        .piece.selected {
            filter: drop-shadow(0 0 8px var(--accent-gold));
        }

        .piece.pinned {
            filter: drop-shadow(0 0 6px var(--pin-indicator));
        }

        .piece.used {
            opacity: 0.5;
            filter: grayscale(0.7);
        }

        .piece.used.pinned {
            opacity: 0.5;
            filter: grayscale(0.7) drop-shadow(0 0 6px var(--pin-indicator));
        }

        .piece-stat {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-anchor: middle;
            pointer-events: none;
            font-weight: bold;
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.8));
        }

        .piece-stat.hp {
            fill: #df24ff;
            letter-spacing: 1px;
        }

        .piece-stat.dmg {
            fill: #e8c34a;
        }

        .piece-stat.rng {
            fill: #22c55e;
            letter-spacing: 1px;
        }

        .ring-highlight {
            fill: none;
            stroke: var(--accent-gold);
            stroke-width: 2;
            stroke-dasharray: 5 5;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .ring-highlight.active {
            opacity: 0.6;
        }

        /* Controls */
        .action-controls {
            position: absolute;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 100;
        }

        .game-controls {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
        }

        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 10px 20px;
            border: 1px solid var(--border);
            background: var(--bg-panel);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover {
            background: var(--bg-hex);
            border-color: var(--accent-gold-dim);
        }

        .btn.primary {
            background: var(--accent-gold-dim);
            color: var(--bg-dark);
            border-color: var(--accent-gold);
        }

        .btn.primary:hover {
            background: var(--accent-gold);
        }

        .btn.rotate {
            background: var(--accent-gold);
            color: var(--bg-dark);
            border-color: var(--accent-gold);
            font-weight: 500;
        }

        .btn.rotate:hover {
            background: #e8c34a;
        }

        .btn.auto-move {
            background: #a855f7;
            color: white;
            border-color: #9333ea;
            font-weight: 500;
        }

        .btn.auto-move:hover {
            background: #9333ea;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Right Panel - Parameters */
        .param-section {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid var(--border);
        }

        .param-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
        }

        .param-row:last-child {
            border-bottom: none;
        }

        .param-label {
            font-size: 13px;
            color: var(--text-muted);
        }

        .param-input {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            width: 60px;
            padding: 6px 8px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-primary);
            border-radius: 4px;
            text-align: center;
        }

        .param-input:focus {
            outline: none;
            border-color: var(--accent-gold-dim);
        }

        .param-input:disabled {
            background: var(--bg-hex);
            color: var(--text-muted);
            opacity: 0.5;
            cursor: not-allowed;
        }

        select.param-input {
            width: 100px;
        }

        /* Unit Editor */
        .unit-editor {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid var(--border);
        }

        .unit-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }

        .unit-btn {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            border: 2px solid var(--border);
            background: var(--bg-dark);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 18px;
            transition: all 0.15s;
        }

        .unit-btn:hover,
        .unit-btn.active {
            border-color: var(--accent-gold);
        }

        .unit-btn.player1 {
            background: var(--player1-dim);
        }

        .unit-btn.player2 {
            background: var(--player2-dim);
        }

        .template-selector {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 12px 0;
        }

        .template-btn {
            padding: 12px;
            border: 2px solid var(--border);
            background: var(--bg-dark);
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-primary);
            text-align: center;
            transition: all 0.15s;
        }

        .template-btn:hover {
            border-color: var(--accent-gold-dim);
            background: var(--bg-hex);
        }

        .template-btn.active {
            background: var(--accent-gold-dim);
            border-color: var(--accent-gold);
            color: var(--bg-dark);
        }

        /* Victory Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: var(--bg-panel);
            border: 1px solid var(--accent-gold);
            border-radius: 12px;
            padding: 48px;
            text-align: center;
            max-width: 400px;
        }

        .modal h2 {
            font-size: 32px;
            margin-bottom: 16px;
            color: var(--accent-gold);
        }

        .modal p {
            font-size: 18px;
            color: var(--text-muted);
            margin-bottom: 32px;
        }

        /* Placement Mode */
        .placement-palette {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid var(--border);
        }

        .placement-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .placement-piece {
            width: 44px;
            height: 44px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
            position: relative;
        }

        .placement-piece:hover {
            transform: scale(1.05);
        }

        .placement-piece.selected {
            border-color: var(--accent-gold);
            box-shadow: 0 0 12px rgba(212, 175, 55, 0.4);
        }

        .placement-piece.placed {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .placement-piece .count {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: 10px;
            background: var(--bg-dark);
            padding: 1px 4px;
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
        }

        /* Log */
        .game-log {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid var(--border);
            max-height: 200px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }

        .log-entry {
            padding: 4px 0;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry.player1 {
            color: var(--player1);
        }

        .log-entry.player2 {
            color: var(--player2);
        }

        .log-entry.system {
            color: var(--accent-gold);
        }

        /* Rotation UI */
        .rotation-controls {
            position: absolute;
            display: flex;
            gap: 8px;
            background: var(--bg-panel);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--accent-gold);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .rotation-controls button {
            width: 36px;
            height: 36px;
            border-radius: 4px;
            border: 1px solid var(--border);
            background: var(--bg-hex);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 16px;
        }

        .rotation-controls button:hover {
            background: var(--accent-gold-dim);
            color: var(--bg-dark);
        }
    </style>
</head>

<body>
    <div class="game-container">
        <!-- Left Panel -->
        <div class="panel">
            <div class="logo">THRONE</div>

            <div class="turn-indicator player1" id="turn-indicator">
                <div class="player-name">Player 1</div>
                <div class="actions-remaining">Actions: <span id="actions-count">2</span>/2</div>
            </div>



            <div class="army-display">
                <div class="army-title player1">â¬¢ Player 1 Army</div>
                <div class="army-pieces" id="army-p1"></div>
            </div>

            <div class="army-display">
                <div class="army-title player2">â¬¢ Player 2 Army</div>
                <div class="army-pieces" id="army-p2"></div>
            </div>

            <div class="game-log" id="game-log">
                <div class="log-entry system">Game initialized.</div>
            </div>
        </div>

        <!-- Board Area -->
        <div class="board-area">
            <svg id="game-board" width="700" height="700"></svg>
            <div class="action-controls" id="action-controls">
                <button class="btn auto-move" id="btn-auto-move">âœ¨ Auto-Move</button>
                <button class="btn rotate" id="btn-rotate" style="display: none;">â†» Rotate Ring</button>
                <button class="btn primary" id="btn-confirm-path" style="display: none;">Confirm Move</button>
            </div>

            <div class="game-controls">
                <button class="btn" id="btn-reset">Reset Game</button>
                <button class="btn" id="btn-reset-turn" disabled>Reset Turn</button>
                <button class="btn" id="btn-cancel-path" style="display: none;">Cancel</button>
                <button class="btn" id="btn-end-turn">End Turn</button>
            </div>
            <div class="rotation-controls" id="rotation-controls" style="display: none;">
                <button id="rotate-ccw">â†º</button>
                <span style="display: flex; align-items: center; font-size: 12px; color: var(--text-muted);">Ring <span
                        id="rotation-ring">1</span></span>
                <button id="rotate-cw">â†»</button>
                <button id="rotate-cancel" style="margin-left: 8px; font-size: 12px;">âœ•</button>
            </div>
        </div>

        <!-- Right Panel - Parameters -->
        <div class="panel panel-right">
            <div class="panel-title">Game Parameters</div>
            <div class="param-section">
                <div class="param-row">
                    <span class="param-label">Actions/Turn</span>
                    <input type="number" class="param-input" id="param-actions" value="2" min="1" max="4">
                </div>
            </div>

            <div class="panel-title" style="margin-top: 16px;">Unit Editor</div>
            <div class="unit-editor">
                <div class="unit-selector" id="unit-selector"></div>
                <div id="unit-details" style="display: none;">
                    <div class="param-row">
                        <span class="param-label">Max HP</span>
                        <input type="number" class="param-input" id="unit-hp" value="3" min="1" max="10">
                    </div>
                    <div class="param-row">
                        <span class="param-label">Ram Damage</span>
                        <input type="number" class="param-input" id="unit-ram-damage" value="1" min="1" max="5">
                    </div>
                    <div class="param-row">
                        <span class="param-label">Move Range</span>
                        <input type="number" class="param-input" id="unit-range" value="3" min="1" max="6">
                    </div>
                    <div class="panel-title" style="margin-top: 12px; margin-bottom: 8px;">Movement Template</div>
                    <div class="template-selector" id="template-selector"></div>
                </div>
            </div>

            <div class="panel-title" style="margin-top: 16px;">Instructions</div>
            <div class="param-section" style="font-size: 13px; color: var(--text-muted); line-height: 1.6;">
                <p><strong>Movement:</strong> Click a piece to start path building. Click adjacent hexes to build your
                    path step-by-step. Click the last hex again or "Confirm Move" to execute. Press Escape or "Cancel"
                    to abort.</p>
                <p style="margin-top: 8px;"><strong>Rotation:</strong> Select your King, then tap "â†» Rotate Ring"
                    button. Select a ring number, then tap â†º or â†» to rotate.</p>
                <p style="margin-top: 8px;"><strong>Victory:</strong> Capture the Throne, eliminate all enemy units, or
                    pin + ram the enemy King.</p>
            </div>
        </div>
    </div>

    <!-- Victory Modal -->
    <div class="modal-overlay" id="victory-modal">
        <div class="modal">
            <h2 id="victory-title">Victory!</h2>
            <p id="victory-message">Player 1 wins by capturing the Throne!</p>
            <button class="btn primary" id="btn-new-game">New Game</button>
        </div>
    </div>

    <!-- Game Mode Selection Modal -->
    <div class="modal-overlay active" id="mode-selection-modal">
        <div class="modal">
            <h2>Select Game Mode</h2>
            <p>Choose your opponent<br><span style="font-size: 14px; color: var(--text-color-secondary)">(CPU plays as
                    Player 2)</span></p>
            <div style="display: flex; gap: 16px; justify-content: center;">
                <button class="btn primary" id="btn-mode-2p" style="padding: 16px 24px;">2 Player</button>
                <button class="btn primary auto-move" id="btn-mode-cpu" style="padding: 16px 24px;">vs CPU</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // THRONE - Tactical Hex Duel Prototype
        // ============================================

        const HEX_SIZE = 38;
        const BOARD_RADIUS = 5;
        const CENTER_X = 350;
        const CENTER_Y = 350;

        // Hex directions (pointy-top)
        const HEX_DIRECTIONS = [
            { q: 1, r: 0 },   // E
            { q: 1, r: -1 },  // NE
            { q: 0, r: -1 },  // NW
            { q: -1, r: 0 },  // W
            { q: -1, r: 1 },  // SW
            { q: 0, r: 1 },   // SE
        ];

        const PIECE_TYPES = {
            KING: { symbol: 'â™š', name: 'King', defaultHP: Infinity, isKing: true },
            PAWN: { symbol: 'â™Ÿ', name: 'Pawn', defaultHP: 2, isKing: false },
            KNIGHT: { symbol: 'â™ž', name: 'Knight', defaultHP: 4, isKing: false },
            ROOK: { symbol: 'â™œ', name: 'Rook', defaultHP: 6, isKing: false },
            BISHOP: { symbol: 'â™', name: 'Bishop', defaultHP: 4, isKing: false },
            LANCE: { symbol: 'âš”', name: 'Lance', defaultHP: 4, isKing: false },
        };

        // Game state
        let gameState = {
            phase: 'setup', // setup, playing, ended
            gameMode: '2player', // '2player' or 'vsCPU'
            cpuPlayer: 2, // Which player is CPU (only used in vsCPU mode)
            currentPlayer: 1,
            actionsRemaining: 2,
            actionsPerTurn: 2,
            isFirstTurn: true,
            usedPieces: new Set(),
            hasAnyPieceMoved: false,
            pieces: [],
            board: new Map(), // hex key -> piece
            pinningPaths: [], // Store paths that create pins for visualization
            pinningMap: new Map(), // Map: enemy piece index -> Set of ally piece indices that are pinning it
            previewPinningPaths: [], // Store preview pinning paths when building a move
            selectedPiece: null,
            validMoves: [],
            rotationMode: false,
            selectedRing: null,
            pathBuilding: false,
            currentPath: [],
            pathStartPiece: null,
            params: {
                actionsPerTurn: 2
            },
            unitConfigs: {},
            turnSnapshot: null
        };

        // Movement templates
        const MOVEMENT_TEMPLATES = {
            FREE_MOTION: 'free_motion',
            STRAIGHT_LINE: 'straight_line'
        };

        // Initialize unit configs with default movement patterns
        function initUnitConfigs() {
            // King: free motion, range 1
            gameState.unitConfigs['KING'] = {
                range: 1,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: Infinity,
                ramDamage: 2
            };
            // Pawn: free motion, range 2
            gameState.unitConfigs['PAWN'] = {
                range: 2,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: 2,
                ramDamage: 1
            };
            // Knight: free motion, range 3
            gameState.unitConfigs['KNIGHT'] = {
                range: 3,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: 4,
                ramDamage: 2
            };
            // Rook: free motion
            gameState.unitConfigs['ROOK'] = {
                range: 2,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: 6,
                ramDamage: 3
            };
            // Bishop: straight line
            gameState.unitConfigs['BISHOP'] = {
                range: 5,
                template: MOVEMENT_TEMPLATES.STRAIGHT_LINE,
                hp: 4,
                ramDamage: 2
            };
            // Lance: free motion
            gameState.unitConfigs['LANCE'] = {
                range: 1,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: 4,
                ramDamage: 2
            };
        }

        // ============================================
        // HEX MATH
        // ============================================

        function hexKey(q, r) {
            return `${q},${r}`;
        }

        function parseHexKey(key) {
            const [q, r] = key.split(',').map(Number);
            return { q, r };
        }

        function hexToPixel(q, r) {
            const x = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r) + CENTER_X;
            const y = HEX_SIZE * (3 / 2 * r) + CENTER_Y;
            return { x, y };
        }

        function pixelToHex(x, y) {
            const px = x - CENTER_X;
            const py = y - CENTER_Y;
            const q = (Math.sqrt(3) / 3 * px - 1 / 3 * py) / HEX_SIZE;
            const r = (2 / 3 * py) / HEX_SIZE;
            return hexRound(q, r);
        }

        function hexRound(q, r) {
            const s = -q - r;
            let rq = Math.round(q);
            let rr = Math.round(r);
            let rs = Math.round(s);

            const qDiff = Math.abs(rq - q);
            const rDiff = Math.abs(rr - r);
            const sDiff = Math.abs(rs - s);

            if (qDiff > rDiff && qDiff > sDiff) {
                rq = -rr - rs;
            } else if (rDiff > sDiff) {
                rr = -rq - rs;
            }

            return { q: rq, r: rr };
        }

        function hexDistance(q1, r1, q2, r2) {
            return (Math.abs(q1 - q2) + Math.abs(q1 + r1 - q2 - r2) + Math.abs(r1 - r2)) / 2;
        }

        function getRing(q, r) {
            return hexDistance(0, 0, q, r);
        }

        function isValidHex(q, r) {
            return getRing(q, r) <= BOARD_RADIUS;
        }

        function getHexCorners(cx, cy, size) {
            const corners = [];
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 180 * (60 * i - 30);
                corners.push({
                    x: cx + size * Math.cos(angle),
                    y: cy + size * Math.sin(angle)
                });
            }
            return corners;
        }

        function hexNeighbor(q, r, direction) {
            const d = HEX_DIRECTIONS[direction];
            return { q: q + d.q, r: r + d.r };
        }

        function getHexesInRing(ring) {
            if (ring === 0) return [{ q: 0, r: 0 }];

            const hexes = [];
            let hex = { q: ring, r: 0 }; // Start at E

            for (let dir = 2; dir < 8; dir++) {
                const actualDir = dir % 6;
                for (let i = 0; i < ring; i++) {
                    hexes.push({ ...hex });
                    hex = hexNeighbor(hex.q, hex.r, actualDir);
                }
            }

            return hexes;
        }

        function rotateHexAroundCenter(q, r, steps) {
            // Rotate a hex position around center by steps * 60 degrees
            // Using cube coordinates for rotation
            const s = -q - r;
            let newQ = q, newR = r, newS = s;

            const absSteps = Math.abs(steps);
            const direction = steps > 0 ? 1 : -1;

            for (let i = 0; i < absSteps; i++) {
                if (direction > 0) {
                    // Clockwise
                    [newQ, newR, newS] = [-newR, -newS, -newQ];
                } else {
                    // Counter-clockwise
                    [newQ, newR, newS] = [-newS, -newQ, -newR];
                }
            }

            return { q: newQ, r: newR };
        }

        // ============================================
        // FIXED STARTING POSITIONS
        // ============================================

        function setupFixedPositions() {
            gameState.pieces = [];

            // Pick a random corner for player 1 (6 possible corners on ring 5)
            const corners = [
                { q: 5, r: 0 },   // E
                { q: 0, r: -5 }, // NW
                { q: -5, r: 5 }, // W
                { q: -5, r: 0 }, // W (different)
                { q: 0, r: 5 },  // SE
                { q: 5, r: -5 }  // NE
            ];
            const p1Corner = corners[Math.floor(Math.random() * corners.length)];

            // Player 2 gets opposite corner (rotate 180 degrees)
            const p2Corner = rotateHexAroundCenter(p1Corner.q, p1Corner.r, 3);

            // Place Player 1 pieces
            placeArmy(1, p1Corner);

            // Place Player 2 pieces
            placeArmy(2, p2Corner);

            // Update pins after placement
            updatePins();
        }

        function placeArmy(player, kingCorner) {
            // King at ring 5 corner
            createPiece('KING', player, kingCorner.q, kingCorner.r);

            // Find direction toward center from king corner
            // Calculate which direction points most toward (0,0)
            let bestDir = 0;
            let minDist = Infinity;
            for (let dir = 0; dir < 6; dir++) {
                const neighbor = hexNeighbor(kingCorner.q, kingCorner.r, dir);
                const dist = hexDistance(0, 0, neighbor.q, neighbor.r);
                if (dist < minDist) {
                    minDist = dist;
                    bestDir = dir;
                }
            }

            // Find hexes on ring 4 that are neighbors of the king
            const ring4Candidates = [];
            for (let dir = 0; dir < 6; dir++) {
                const neighbor = hexNeighbor(kingCorner.q, kingCorner.r, dir);
                if (getRing(neighbor.q, neighbor.r) === 4 && isValidHex(neighbor.q, neighbor.r)) {
                    ring4Candidates.push({ pos: neighbor, dir: dir });
                }
            }

            // Sort by proximity to the "inward" direction
            ring4Candidates.sort((a, b) => {
                const aDist = Math.abs((a.dir - bestDir + 6) % 6);
                const bDist = Math.abs((b.dir - bestDir + 6) % 6);
                return aDist - bDist;
            });

            // Take first 3 positions for Bishop, Knight, Rook
            const ring4Positions = ring4Candidates.slice(0, 3).map(c => c.pos);

            // Ensure we have 3 positions (fallback to any ring 4 neighbors)
            if (ring4Positions.length < 3) {
                const allRing4 = getHexesInRing(4);
                for (const hex of allRing4) {
                    if (hexDistance(kingCorner.q, kingCorner.r, hex.q, hex.r) <= 2) {
                        if (!ring4Positions.some(p => p.q === hex.q && p.r === hex.r)) {
                            ring4Positions.push(hex);
                            if (ring4Positions.length >= 3) break;
                        }
                    }
                }
            }

            // Place Rook, Knight, Bishop on ring 4 (guaranteed 3 positions)
            if (ring4Positions.length >= 1) {
                createPiece('ROOK', player, ring4Positions[0].q, ring4Positions[0].r);
            }
            if (ring4Positions.length >= 2) {
                createPiece('KNIGHT', player, ring4Positions[1].q, ring4Positions[1].r);
            }
            if (ring4Positions.length >= 3) {
                createPiece('BISHOP', player, ring4Positions[2].q, ring4Positions[2].r);
            }

            // Ring 3: 3 Pawns next to the ring 4 pieces
            const pawnPositions = [];

            // Find hexes on ring 3 that are neighbors of the ring 4 pieces
            for (const ring4Pos of ring4Positions) {
                for (let dir = 0; dir < 6; dir++) {
                    const neighbor = hexNeighbor(ring4Pos.q, ring4Pos.r, dir);
                    if (getRing(neighbor.q, neighbor.r) === 3 &&
                        isValidHex(neighbor.q, neighbor.r) &&
                        !pawnPositions.some(p => p.q === neighbor.q && p.r === neighbor.r)) {
                        pawnPositions.push(neighbor);
                    }
                }
            }

            // If we don't have 3 pawn positions, find more from ring 3
            if (pawnPositions.length < 3) {
                const allRing3 = getHexesInRing(3);
                for (const hex of allRing3) {
                    // Check if it's near any ring 4 piece
                    let isNear = false;
                    for (const ring4Pos of ring4Positions) {
                        if (hexDistance(hex.q, hex.r, ring4Pos.q, ring4Pos.r) <= 2) {
                            isNear = true;
                            break;
                        }
                    }
                    if (isNear && !pawnPositions.some(p => p.q === hex.q && p.r === hex.r)) {
                        pawnPositions.push(hex);
                        if (pawnPositions.length >= 3) break;
                    }
                }
            }

            // Place 3 Pawns (guaranteed to place all 3)
            for (let i = 0; i < 3 && i < pawnPositions.length; i++) {
                createPiece('PAWN', player, pawnPositions[i].q, pawnPositions[i].r);
            }

            // If we still don't have 3 pawns, place them anywhere on ring 3
            let currentPawnCount = gameState.pieces.filter(p => p.player === player && p.type === 'PAWN').length;
            if (currentPawnCount < 3) {
                const allRing3 = getHexesInRing(3);
                for (const hex of allRing3) {
                    if (!getPieceAt(hex.q, hex.r) && currentPawnCount < 3) {
                        createPiece('PAWN', player, hex.q, hex.r);
                        currentPawnCount++;
                    }
                }
            }

            // Get all pawn positions for lance placement check
            const pawnPositionsList = gameState.pieces
                .filter(p => p.player === player && p.type === 'PAWN')
                .map(p => ({ q: p.q, r: p.r }));

            // Ring 2: Lance should be adjacent to all ally pawns (which are on ring 3)
            const ring2Hexes = getHexesInRing(2);
            let lancePosition = null;
            let maxAdjacentPawns = 0;

            // Find a hex on ring 2 that is adjacent to as many pawns as possible
            // Ideally adjacent to all 3 pawns
            for (const hex of ring2Hexes) {
                if (getPieceAt(hex.q, hex.r)) continue; // Skip if occupied

                // Count how many pawns this hex is adjacent to
                let adjacentPawnCount = 0;
                for (const pawn of pawnPositionsList) {
                    if (hexDistance(hex.q, hex.r, pawn.q, pawn.r) === 1) {
                        adjacentPawnCount++;
                    }
                }

                // Prefer positions adjacent to more pawns
                if (adjacentPawnCount > maxAdjacentPawns) {
                    maxAdjacentPawns = adjacentPawnCount;
                    lancePosition = hex;
                }
            }

            // If we found a position adjacent to at least one pawn, use it
            // Otherwise, find any ring 2 hex that's adjacent to at least one pawn
            if (!lancePosition || maxAdjacentPawns === 0) {
                for (const hex of ring2Hexes) {
                    if (getPieceAt(hex.q, hex.r)) continue;

                    // Check if adjacent to any pawn
                    for (const pawn of pawnPositionsList) {
                        if (hexDistance(hex.q, hex.r, pawn.q, pawn.r) === 1) {
                            lancePosition = hex;
                            break;
                        }
                    }
                    if (lancePosition) break;
                }
            }

            // Final fallback: just pick first available ring 2 hex
            if (!lancePosition && ring2Hexes.length > 0) {
                for (const hex of ring2Hexes) {
                    if (!getPieceAt(hex.q, hex.r)) {
                        lancePosition = hex;
                        break;
                    }
                }
            }

            if (lancePosition) {
                createPiece('LANCE', player, lancePosition.q, lancePosition.r);
            }

            // Verify all pieces were created
            const pieces = gameState.pieces.filter(p => p.player === player);
            const pieceCounts = {
                KING: pieces.filter(p => p.type === 'KING').length,
                PAWN: pieces.filter(p => p.type === 'PAWN').length,
                KNIGHT: pieces.filter(p => p.type === 'KNIGHT').length,
                ROOK: pieces.filter(p => p.type === 'ROOK').length,
                BISHOP: pieces.filter(p => p.type === 'BISHOP').length,
                LANCE: pieces.filter(p => p.type === 'LANCE').length
            };

            // Ensure we have all required pieces, create missing ones if needed
            if (pieceCounts.KING === 0) {
                createPiece('KING', player, kingCorner.q, kingCorner.r);
            }
            if (pieceCounts.ROOK === 0 && ring4Positions.length > 0) {
                createPiece('ROOK', player, ring4Positions[0].q, ring4Positions[0].r);
            }
            if (pieceCounts.KNIGHT === 0 && ring4Positions.length > 1) {
                createPiece('KNIGHT', player, ring4Positions[1].q, ring4Positions[1].r);
            }
            if (pieceCounts.BISHOP === 0 && ring4Positions.length > 2) {
                createPiece('BISHOP', player, ring4Positions[2].q, ring4Positions[2].r);
            }
            if (pieceCounts.PAWN < 3) {
                const allRing3 = getHexesInRing(3);
                for (const hex of allRing3) {
                    if (!getPieceAt(hex.q, hex.r) && pieceCounts.PAWN < 3) {
                        createPiece('PAWN', player, hex.q, hex.r);
                        pieceCounts.PAWN++;
                    }
                }
            }
            if (pieceCounts.LANCE === 0) {
                const allRing2 = getHexesInRing(2);
                for (const hex of allRing2) {
                    if (!getPieceAt(hex.q, hex.r)) {
                        createPiece('LANCE', player, hex.q, hex.r);
                        break;
                    }
                }
            }
        }


        function createPiece(type, player, q, r) {
            const config = gameState.unitConfigs[type];
            const hp = config.hp === Infinity ? Infinity : config.hp;

            const piece = {
                type,
                player,
                q, r,
                hp,
                maxHP: hp,
                alive: true,
                pinned: false
            };

            gameState.pieces.push(piece);
        }

        // ============================================
        // BOARD RENDERING
        // ============================================

        function createBoard() {
            const svg = document.getElementById('game-board');
            svg.innerHTML = '';

            // Create hex group
            const hexGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            hexGroup.id = 'hex-group';
            svg.appendChild(hexGroup);

            // Create ring highlight paths for rotation
            for (let ring = 1; ring <= BOARD_RADIUS; ring++) {
                const ringHexes = getHexesInRing(ring);
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.id = `ring-${ring}`;
                path.classList.add('ring-highlight');

                // Create path around ring
                let d = '';
                ringHexes.forEach((hex, i) => {
                    const { x, y } = hexToPixel(hex.q, hex.r);
                    if (i === 0) {
                        d += `M ${x} ${y}`;
                    } else {
                        d += ` L ${x} ${y}`;
                    }
                });
                d += ' Z';
                path.setAttribute('d', d);
                svg.appendChild(path);
            }

            // Create hexes
            for (let q = -BOARD_RADIUS; q <= BOARD_RADIUS; q++) {
                for (let r = -BOARD_RADIUS; r <= BOARD_RADIUS; r++) {
                    if (!isValidHex(q, r)) continue;

                    const { x, y } = hexToPixel(q, r);
                    const corners = getHexCorners(x, y, HEX_SIZE - 2);

                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', corners.map(c => `${c.x},${c.y}`).join(' '));
                    polygon.classList.add('hex');
                    polygon.dataset.q = q;
                    polygon.dataset.r = r;

                    const ring = getRing(q, r);
                    polygon.classList.add(`ring-${ring}`);
                    polygon.dataset.ring = ring;

                    if (q === 0 && r === 0) {
                        polygon.classList.add('throne');
                    }

                    polygon.addEventListener('click', (e) => onHexClick(q, r, e));
                    hexGroup.appendChild(polygon);
                }
            }

            // Create pinning paths group (rendered behind pieces)
            const pinningGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            pinningGroup.id = 'pinning-paths-group';
            svg.appendChild(pinningGroup);

            // Create piece group
            const pieceGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            pieceGroup.id = 'piece-group';
            svg.appendChild(pieceGroup);
        }

        function renderPieces() {
            const pieceGroup = document.getElementById('piece-group');
            pieceGroup.innerHTML = '';

            gameState.pieces.forEach((piece, index) => {
                if (!piece.alive) return;

                const { x, y } = hexToPixel(piece.q, piece.r);

                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.classList.add('piece');
                g.dataset.index = index;

                if (gameState.selectedPiece === index) {
                    g.classList.add('selected');
                }
                if (piece.pinned) {
                    g.classList.add('pinned');
                }
                if (gameState.usedPieces.has(index)) {
                    g.classList.add('used');
                }

                // Piece background
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', HEX_SIZE * 0.6);

                let fillColor, strokeColor;
                if (piece.player === 1) {
                    fillColor = '#c94c4c'; // var(--player1)
                    strokeColor = '#8a3535'; // var(--player1-dim)
                } else {
                    if (gameState.gameMode === 'vsCPU' && piece.player === gameState.cpuPlayer) {
                        fillColor = '#a855f7'; // var(--player-cpu)
                        strokeColor = '#7c3aed'; // var(--player-cpu-dim)
                    } else {
                        fillColor = '#4c8bc9'; // var(--player2)
                        strokeColor = '#35628a'; // var(--player2-dim)
                    }
                }

                circle.setAttribute('fill', fillColor);
                circle.setAttribute('stroke', strokeColor);
                circle.setAttribute('stroke-width', 2);
                g.appendChild(circle);

                // Piece symbol
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y + 6);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '24');
                text.setAttribute('fill', 'white');
                text.setAttribute('pointer-events', 'none');
                text.textContent = PIECE_TYPES[piece.type].symbol;
                g.appendChild(text);

                // Stats indicators
                const config = gameState.unitConfigs[piece.type];

                // HP indicator (not for King)
                if (!PIECE_TYPES[piece.type].isKing && piece.hp < Infinity) {
                    const hpText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    hpText.setAttribute('x', x + HEX_SIZE * 0.4);
                    hpText.setAttribute('y', y - HEX_SIZE * 0.3);
                    hpText.classList.add('piece-stat', 'hp');
                    hpText.textContent = `â™¥${piece.hp}`;
                    g.appendChild(hpText);
                }

                // Damage indicator
                if (config.ramDamage > 0) {
                    const dmgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    dmgText.setAttribute('x', x - HEX_SIZE * 0.4);
                    dmgText.setAttribute('y', y - HEX_SIZE * 0.3);
                    dmgText.classList.add('piece-stat', 'dmg');
                    dmgText.textContent = `ðŸ—¡${config.ramDamage}`;
                    g.appendChild(dmgText);
                }

                // Range indicator
                if (config.range > 0 && config.range < Infinity) {
                    const rngText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    rngText.setAttribute('x', x + HEX_SIZE * 0.4);
                    rngText.setAttribute('y', y + HEX_SIZE * 0.5); // Bottom-right
                    rngText.classList.add('piece-stat', 'rng');

                    const moveIcon = config.template === MOVEMENT_TEMPLATES.STRAIGHT_LINE ? 'â†‘' : 'â†';
                    rngText.textContent = `${moveIcon}${config.range}`;
                    g.appendChild(rngText);
                }

                g.addEventListener('click', (e) => {
                    e.stopPropagation();
                    onPieceClick(index);
                });

                pieceGroup.appendChild(g);
            });
        }

        function highlightValidMoves(moves) {
            // Clear previous highlights
            document.querySelectorAll('.hex.valid-move, .hex.damage-path').forEach(el => {
                el.classList.remove('valid-move', 'damage-path');
            });

            moves.forEach(move => {
                const hex = document.querySelector(`.hex[data-q="${move.q}"][data-r="${move.r}"]`);
                if (hex) {
                    hex.classList.add(move.willKill ? 'damage-path' : 'valid-move');
                }

                // Highlight damage path
                if (move.damagePath) {
                    move.damagePath.forEach(pos => {
                        const pathHex = document.querySelector(`.hex[data-q="${pos.q}"][data-r="${pos.r}"]`);
                        if (pathHex) pathHex.classList.add('damage-path');
                    });
                }
            });
        }

        function clearHighlights() {
            document.querySelectorAll('.hex.valid-move, .hex.damage-path, .hex.selected, .hex.path-step, .hex.path-end').forEach(el => {
                el.classList.remove('valid-move', 'damage-path', 'selected', 'path-step', 'path-end');
            });
        }

        // ============================================
        // GAME LOGIC
        // ============================================

        function getValidMoves(piece) {
            if (!piece.alive || piece.pinned) return [];

            const config = gameState.unitConfigs[piece.type];
            const maxRange = config.range;
            // For templates, all directions are valid for path finding
            // Template restrictions are enforced during path building
            const validDirections = [0, 1, 2, 3, 4, 5];

            // Use BFS to find all reachable positions
            // Track all paths to each destination, then select the best one
            const bestPaths = new Map(); // key -> { move, damageCount, distance }
            const queue = [{
                q: piece.q,
                r: piece.r,
                distance: 0,
                damagePath: [],
                path: [{ q: piece.q, r: piece.r }]
            }];

            // Track visited states: key -> Set of (distance, damageCount) pairs
            // This allows revisiting if we find a better path (more damage or shorter)
            const visited = new Map(); // key -> Set of "distance,damageCount" strings

            function getVisitedKey(distance, damageCount) {
                return `${distance},${damageCount}`;
            }

            function isBetterPath(newDistance, newDamageCount, existing) {
                if (!existing) return true;
                // Prefer paths with more damage, or if same damage, shorter path
                for (const state of existing) {
                    const [dist, dmg] = state.split(',').map(Number);
                    if (dmg > newDamageCount) return false; // Existing has more damage
                    if (dmg === newDamageCount && dist <= newDistance) return false; // Same damage, shorter or equal
                }
                return true;
            }

            function addVisited(key, distance, damageCount) {
                if (!visited.has(key)) {
                    visited.set(key, new Set());
                }
                visited.get(key).add(getVisitedKey(distance, damageCount));
            }

            function shouldExplore(key, distance, damageCount) {
                const existing = visited.get(key);
                if (!existing) return true;
                return isBetterPath(distance, damageCount, existing);
            }

            while (queue.length > 0) {
                const current = queue.shift();

                // Stop if we've reached max range
                if (current.distance >= maxRange) continue;

                // Try moving in all valid directions from current position
                validDirections.forEach(dir => {
                    const next = hexNeighbor(current.q, current.r, dir);
                    const nextKey = hexKey(next.q, next.r);

                    // Check if valid hex
                    if (!isValidHex(next.q, next.r)) return;

                    const newDistance = current.distance + 1;
                    const occupant = getPieceAt(next.q, next.r);
                    const newDamagePath = [...current.damagePath];
                    let newDamageCount = newDamagePath.length;

                    // If there's an enemy here, add to damage path
                    if (occupant && occupant.player !== piece.player) {
                        newDamagePath.push({ q: next.q, r: next.r, piece: occupant });
                        newDamageCount = newDamagePath.length;
                    }

                    // Check if we should explore this path
                    if (!shouldExplore(nextKey, newDistance, newDamageCount)) {
                        return;
                    }

                    const newPath = [...current.path, { q: next.q, r: next.r }];
                    const newState = {
                        q: next.q,
                        r: next.r,
                        distance: newDistance,
                        damagePath: newDamagePath,
                        damageCount: newDamageCount,
                        path: newPath
                    };

                    // If there's a friendly, we can pass through but can't end here
                    if (occupant && occupant.player === piece.player) {
                        // Can pass through - continue exploring
                        addVisited(nextKey, newDistance, newDamageCount);
                        queue.push(newState);
                        return;
                    }

                    // Empty hex or enemy hex - can potentially end here
                    addVisited(nextKey, newDistance, newDamageCount);

                    // Check if we can end on this hex
                    let isValidDestination = false;
                    let wouldKill = false;

                    if (occupant && occupant.player !== piece.player) {
                        // Check if the attacker is pinning this target (using coordinates instead of references)
                        const occupantIndex = gameState.pieces.findIndex(p => p.q === occupant.q && p.r === occupant.r);
                        const attackerIndex = gameState.pieces.findIndex(p => p.q === piece.q && p.r === piece.r);
                        const isPinningPiece = occupantIndex >= 0 &&
                            attackerIndex >= 0 &&
                            gameState.pinningMap.has(occupantIndex) &&
                            gameState.pinningMap.get(occupantIndex).has(attackerIndex);

                        // If the attacker is pinning the target, they can't insta-kill it
                        // They must deal enough damage to kill it normally
                        if (isPinningPiece && occupant.pinned) {
                            // Attacker is pinning the target - must kill with damage, not insta-kill
                            wouldKill = canKillWithRam(piece, occupant, newDamageCount + 1);
                        } else {
                            // Normal case: pinned pieces die instantly (unless pinned by attacker)
                            wouldKill = occupant.pinned || canKillWithRam(piece, occupant, newDamageCount + 1);
                        }
                        isValidDestination = wouldKill;
                    } else {
                        // Empty hex - valid destination
                        isValidDestination = true;
                    }

                    if (isValidDestination) {
                        // Check if this is a better path to this destination
                        const existing = bestPaths.get(nextKey);
                        const isBetter = !existing ||
                            newDamageCount > existing.damageCount ||
                            (newDamageCount === existing.damageCount && newDistance < existing.distance);

                        if (isBetter) {
                            bestPaths.set(nextKey, {
                                q: next.q,
                                r: next.r,
                                damagePath: newDamagePath,
                                damageCount: newDamageCount,
                                willKill: wouldKill,
                                path: newPath,
                                distance: newDistance
                            });
                        }
                    }

                    // Continue exploring from this position
                    queue.push(newState);
                });
            }

            return Array.from(bestPaths.values()).map(({ willKill, damagePath, path, q, r }) => ({
                q, r, damagePath, willKill, path
            }));
        }

        function getValidNextSteps(piece, currentPath) {
            // Pinned pieces cannot move
            if (!piece.alive || piece.pinned) return [];

            // Get valid adjacent hexes for the next step in path building
            const config = gameState.unitConfigs[piece.type];
            const maxRange = config.range;

            // If path is at max range, no more steps
            if (currentPath.length >= maxRange) return [];

            const currentPos = currentPath.length > 0
                ? currentPath[currentPath.length - 1]
                : { q: piece.q, r: piece.r };

            // Determine valid directions based on template
            let validDirections = [];

            if (config.template === MOVEMENT_TEMPLATES.FREE_MOTION) {
                // Free motion: can move in any direction
                validDirections = [0, 1, 2, 3, 4, 5];
            } else if (config.template === MOVEMENT_TEMPLATES.STRAIGHT_LINE) {
                // Straight line: must continue in the same direction
                if (currentPath.length === 0) {
                    // First step: can choose any direction
                    validDirections = [0, 1, 2, 3, 4, 5];
                } else {
                    // Subsequent steps: must continue in the same direction
                    // Find the direction from the previous position to the current position
                    let fromPos, toPos;
                    if (currentPath.length === 1) {
                        // From piece position to first step
                        fromPos = { q: piece.q, r: piece.r };
                        toPos = currentPath[0];
                    } else {
                        // From previous step to current step
                        fromPos = currentPath[currentPath.length - 2];
                        toPos = currentPath[currentPath.length - 1];
                    }

                    // Find the direction from fromPos to toPos
                    let direction = -1;
                    for (let dir = 0; dir < 6; dir++) {
                        const neighbor = hexNeighbor(fromPos.q, fromPos.r, dir);
                        if (neighbor.q === toPos.q && neighbor.r === toPos.r) {
                            direction = dir;
                            break;
                        }
                    }

                    // If we found the direction, only allow that direction
                    if (direction >= 0) {
                        validDirections = [direction];
                    } else {
                        // Fallback: if we can't determine direction, allow all (shouldn't happen)
                        validDirections = [0, 1, 2, 3, 4, 5];
                    }
                }
            }

            const validNext = [];

            validDirections.forEach(dir => {
                const next = hexNeighbor(currentPos.q, currentPos.r, dir);

                if (!isValidHex(next.q, next.r)) return;

                // Check if already in path (can't backtrack)
                const alreadyInPath = currentPath.some(step => step.q === next.q && step.r === next.r);
                if (alreadyInPath) return;

                const occupant = getPieceAt(next.q, next.r);

                // Can pass through friendlies, but can't end on them
                // Can pass through enemies (will damage), can end on them if they'd die
                validNext.push({
                    q: next.q,
                    r: next.r,
                    hasEnemy: occupant && occupant.player !== piece.player,
                    hasFriendly: occupant && occupant.player === piece.player,
                    occupant: occupant
                });
            });

            return validNext;
        }

        function calculateDamagePath(piece, path) {
            // Calculate which enemies would be damaged along this path
            const damagePath = [];
            path.forEach(step => {
                const occupant = getPieceAt(step.q, step.r);
                if (occupant && occupant.player !== piece.player) {
                    damagePath.push({ q: step.q, r: step.r, piece: occupant });
                }
            });
            return damagePath;
        }

        function canKillWithRam(attackingPiece, targetPiece, damageTotal) {
            if (PIECE_TYPES[targetPiece.type].isKing) {
                return targetPiece.pinned; // King can only die if pinned
            }
            const ramDamage = gameState.unitConfigs[attackingPiece.type].ramDamage;
            return targetPiece.hp <= damageTotal * ramDamage;
        }

        function getPieceAt(q, r) {
            return gameState.pieces.find(p => p.alive && p.q === q && p.r === r);
        }

        // Simulate killing pieces along path and check if destination would still be killable
        function simulateMoveAndValidate(pieceIndex, targetQ, targetR, move, ramDamage) {
            const piece = gameState.pieces[pieceIndex];
            const destOccupant = getPieceAt(targetQ, targetR);

            // If no destination enemy, move is valid
            if (!destOccupant || destOccupant.player === piece.player) {
                return true;
            }

            // Create list of pieces that would be killed along the path (excluding destination)
            const piecesToKill = [];
            if (move.damagePath) {
                move.damagePath.forEach(pos => {
                    // Skip destination - it will be handled separately
                    if (pos.q === targetQ && pos.r === targetR) return;

                    const target = pos.piece || getPieceAt(pos.q, pos.r);
                    if (target && target.player !== piece.player) {
                        // Check if this piece would die from the damage
                        if (target.pinned || canKillWithRam(piece, target, 1)) {
                            piecesToKill.push(target);
                        }
                    }
                });
            }

            // Temporarily mark pieces as dead to simulate the move
            const originalAliveStates = new Map();
            piecesToKill.forEach(target => {
                originalAliveStates.set(target, target.alive);
                target.alive = false;
            });

            // Recalculate pins with simulated kills
            updatePins();

            // Check if destination would still be killable after simulated kills
            const destAfterSimulation = getPieceAt(targetQ, targetR);
            if (!destAfterSimulation || destAfterSimulation.player === piece.player) {
                // Restore original states
                originalAliveStates.forEach((alive, target) => {
                    target.alive = alive;
                });
                updatePins();
                return true; // Destination is gone or friendly, move is valid
            }

            const totalDamageInstances = 1; // Destination always takes 1 instance of damage

            // Check if the attacker is pinning this target (using simulated pin state)
            // Use coordinates instead of indexOf to avoid reference issues
            const occupantIndex = gameState.pieces.findIndex(p => p.q === destAfterSimulation.q && p.r === destAfterSimulation.r);
            const attackerIndex = pieceIndex;
            const isPinningPiece = occupantIndex >= 0 &&
                gameState.pinningMap.has(occupantIndex) &&
                gameState.pinningMap.get(occupantIndex).has(attackerIndex);

            // Check if destination would die (using same logic as applyDamage)
            let wouldKill = false;
            
            // Check if target would still be pinned without attacker
            if (destAfterSimulation.pinned && attackerIndex !== null) {
                const stillPinnedWithoutAttacker = isStillPinnedWithoutAttacker(destAfterSimulation, attackerIndex);
                if (stillPinnedWithoutAttacker) {
                    // Still pinned without attacker - insta-kill allowed
                    wouldKill = true;
                } else {
                    // Not pinned without attacker - must kill with damage
                    wouldKill = canKillWithRam(piece, destAfterSimulation, totalDamageInstances);
                }
            } else if (destAfterSimulation.pinned) {
                // Target is pinned, no attacker specified - insta-kill
                wouldKill = true;
            } else {
                // Not pinned - must kill with damage
                wouldKill = canKillWithRam(piece, destAfterSimulation, totalDamageInstances);
            }

            // Handle King special case (matching applyDamage logic)
            if (PIECE_TYPES[destAfterSimulation.type].isKing) {
                if (destAfterSimulation.pinned && isPinningPiece) {
                    // Attacker is pinning King - check if still pinned without attacker
                    const stillPinnedWithoutAttacker = isStillPinnedWithoutAttacker(destAfterSimulation, attackerIndex);
                    if (stillPinnedWithoutAttacker) {
                        // Still pinned without attacker - insta-kill allowed
                        wouldKill = true;
                    } else {
                        // Not pinned without attacker - can damage King
                        wouldKill = destAfterSimulation.hp <= totalDamageInstances * ramDamage;
                    }
                } else if (destAfterSimulation.pinned) {
                    // King is pinned, attacker is not pinning - insta-kill allowed
                    wouldKill = true;
                } else {
                    // King not pinned - cannot be damaged
                    wouldKill = false;
                }
            }

            // Restore original states
            originalAliveStates.forEach((alive, target) => {
                target.alive = alive;
            });
            updatePins();

            return wouldKill;
        }

        function executeMove(pieceIndex, targetQ, targetR, move) {
            const piece = gameState.pieces[pieceIndex];
            const destOccupant = getPieceAt(targetQ, targetR);
            const ramDamage = gameState.unitConfigs[piece.type].ramDamage;

            // Validate the entire move by simulating it first
            if (!simulateMoveAndValidate(pieceIndex, targetQ, targetR, move, ramDamage)) {
                // Invalid move - don't execute anything
                addLog('Cannot land on enemy that would survive!', 'system');
                return false;
            }

            // Now that validation passed, apply damage along path (excluding destination)
            const piecesToDamage = [];
            if (move.damagePath) {
                move.damagePath.forEach(pos => {
                    // Skip destination - it will be handled separately
                    if (pos.q === targetQ && pos.r === targetR) return;

                    const target = pos.piece || getPieceAt(pos.q, pos.r);
                    if (target && target.player !== piece.player) {
                        piecesToDamage.push(target);
                    }
                });
            }

            // Apply damage to pieces along path (not destination)
            piecesToDamage.forEach(target => {
                applyDamage(target, ramDamage, pieceIndex);
                // Recalculate pins after each kill (pinned pieces might have been killed)
                updatePins();
            });

            // Handle enemy at destination (we've already validated it will die)
            if (destOccupant && destOccupant.player !== piece.player) {
                applyDamage(destOccupant, ramDamage, pieceIndex);
                // Recalculate pins after damage/kill
                updatePins();
                // Double-check that it actually died
                if (destOccupant.alive) {
                    console.error('Move validation error - destination survived');
                    addLog('Cannot land on enemy that would survive!', 'system');
                    return false;
                }
            }

            // Only move the piece if we got here (all validations passed and destination died if it was an enemy)
            piece.q = targetQ;
            piece.r = targetR;

            addLog(`${piece.player === 1 ? 'P1' : 'P2'} ${PIECE_TYPES[piece.type].name} moves to (${targetQ}, ${targetR})`, piece.player);

            // Check victory
            if (targetQ === 0 && targetR === 0 && PIECE_TYPES[piece.type].isKing) {
                endGame(piece.player, 'throne');
                return true;
            }

            // Update pins after move
            updatePins();

            // Check army elimination
            checkArmyElimination();

            return true;
        }

        // Check if a piece would still be pinned without the attacker's involvement
        function isStillPinnedWithoutAttacker(targetPiece, attackerIndex) {
            if (!targetPiece || !targetPiece.alive) return false;
            if (attackerIndex === null) return targetPiece.pinned;

            // Find target index using coordinates instead of reference (more reliable)
            const targetIndex = gameState.pieces.findIndex(p => p.q === targetPiece.q && p.r === targetPiece.r);
            if (targetIndex < 0) return false;
            
            // If attacker is the target itself, removing attacker removes target, so target can't be pinned
            if (targetIndex === attackerIndex) return false;

            // Save current state
            const savedPieces = JSON.parse(JSON.stringify(gameState.pieces));
            const savedPinningPaths = [...gameState.pinningPaths];
            const savedPinningMap = new Map(gameState.pinningMap);

            // Temporarily remove the attacker (mark as not alive for pinning calculation)
            const attacker = gameState.pieces[attackerIndex];
            const attackerWasAlive = attacker.alive;
            attacker.alive = false;

            // Recalculate pins without the attacker using the same logic as updatePins
            // This ensures consistency with the main pinning calculation
            const activePlayer = gameState.currentPlayer;
            const otherPlayer = activePlayer === 1 ? 2 : 1;

            // Reset pin states
            gameState.pieces.forEach(p => {
                if (p.alive) {
                    p.pinned = false;
                }
            });
            gameState.pinningPaths = [];
            gameState.pinningMap.clear();

            // Group pieces by player (attacker is now "dead")
            const piecesByPlayer = { 1: [], 2: [] };
            gameState.pieces.forEach(p => {
                if (p.alive) {
                    piecesByPlayer[p.player].push(p);
                }
            });

            // Step 1: Calculate pinnings from active player (without attacker)
            const activeAllies = piecesByPlayer[activePlayer];
            for (let i = 0; i < activeAllies.length; i++) {
                for (let j = i + 1; j < activeAllies.length; j++) {
                    const ally1 = activeAllies[i];
                    const ally2 = activeAllies[j];
                    const paths = findValidPinningPaths(ally1, ally2, activePlayer);
                    paths.forEach(path => {
                        const ally1Index = gameState.pieces.findIndex(p => p === ally1);
                        const ally2Index = gameState.pieces.findIndex(p => p === ally2);
                        path.forEach(step => {
                            if (step.q === ally1.q && step.r === ally1.r) return;
                            if (step.q === ally2.q && step.r === ally2.r) return;
                            const enemy = getPieceAt(step.q, step.r);
                            if (enemy && enemy.player !== activePlayer && enemy.alive) {
                                enemy.pinned = true;
                                const enemyIndex = gameState.pieces.findIndex(p => p === enemy);
                                if (!gameState.pinningMap.has(enemyIndex)) {
                                    gameState.pinningMap.set(enemyIndex, new Set());
                                }
                                gameState.pinningMap.get(enemyIndex).add(ally1Index);
                                gameState.pinningMap.get(enemyIndex).add(ally2Index);
                            }
                        });
                    });
                }
            }

            // Step 2: Calculate pinnings from other player (excluding pinned pieces)
            const otherAllies = piecesByPlayer[otherPlayer].filter(p => !p.pinned);
            for (let i = 0; i < otherAllies.length; i++) {
                for (let j = i + 1; j < otherAllies.length; j++) {
                    const ally1 = otherAllies[i];
                    const ally2 = otherAllies[j];
                    const paths = findValidPinningPaths(ally1, ally2, otherPlayer);
                    paths.forEach(path => {
                        const ally1Index = gameState.pieces.findIndex(p => p === ally1);
                        const ally2Index = gameState.pieces.findIndex(p => p === ally2);
                        path.forEach(step => {
                            if (step.q === ally1.q && step.r === ally1.r) return;
                            if (step.q === ally2.q && step.r === ally2.r) return;
                            const enemy = getPieceAt(step.q, step.r);
                            if (enemy && enemy.player !== otherPlayer && enemy.alive) {
                                enemy.pinned = true;
                                const enemyIndex = gameState.pieces.findIndex(p => p === enemy);
                                if (!gameState.pinningMap.has(enemyIndex)) {
                                    gameState.pinningMap.set(enemyIndex, new Set());
                                }
                                gameState.pinningMap.get(enemyIndex).add(ally1Index);
                                gameState.pinningMap.get(enemyIndex).add(ally2Index);
                            }
                        });
                    });
                }
            }

            // Check if target is still pinned (use the recalculated piece from gameState.pieces)
            // IMPORTANT: Save this value BEFORE restoring state
            // Use coordinates to find target instead of index (more reliable)
            const recalculatedTarget = getPieceAt(targetPiece.q, targetPiece.r);
            const stillPinned = recalculatedTarget && recalculatedTarget.alive && recalculatedTarget.pinned;

            // Restore state by copying properties back to each piece
            // DO NOT replace the array or objects, as that would break existing references
            const parsedSaved = JSON.parse(JSON.stringify(savedPieces));
            for (let i = 0; i < gameState.pieces.length; i++) {
                if (i < parsedSaved.length) {
                    // Restore all properties from saved state
                    Object.assign(gameState.pieces[i], parsedSaved[i]);
                }
            }
            gameState.pinningPaths = savedPinningPaths;
            gameState.pinningMap = savedPinningMap;

            return stillPinned;
        }

        function applyDamage(piece, damage, attackerIndex = null) {
            // Find the piece index using coordinates (more reliable than indexOf)
            const pieceIndex = gameState.pieces.findIndex(p => p.q === piece.q && p.r === piece.r);
            
            // If piece not found, return early
            if (pieceIndex < 0) {
                console.error('applyDamage: piece not found at', piece.q, piece.r);
                return;
            }
            
            // Use the actual piece from gameState.pieces to ensure we modify the right object
            const actualPiece = gameState.pieces[pieceIndex];

            // Check if the attacker is one of the pieces pinning this target
            const isPinningPiece = attackerIndex !== null &&
                pieceIndex >= 0 &&
                gameState.pinningMap.has(pieceIndex) &&
                gameState.pinningMap.get(pieceIndex).has(attackerIndex);

            // Check if piece would still be pinned without the attacker
            // If yes, it dies immediately; if no, apply normal damage
            if (actualPiece.pinned) {
                if (attackerIndex !== null) {
                    const stillPinnedWithoutAttacker = isStillPinnedWithoutAttacker(actualPiece, attackerIndex);
                    if (stillPinnedWithoutAttacker) {
                        // Still pinned without attacker - die immediately
                        actualPiece.alive = false;
                        if (PIECE_TYPES[actualPiece.type].isKing) {
                            addLog(`${actualPiece.player === 1 ? 'P1' : 'P2'} King destroyed (pinned)!`, 'system');
                            endGame(actualPiece.player === 1 ? 2 : 1, 'kingkill');
                        } else {
                            addLog(`${actualPiece.player === 1 ? 'P1' : 'P2'} ${PIECE_TYPES[actualPiece.type].name} destroyed (pinned)`, actualPiece.player);
                        }
                        return;
                    }
                    // Not pinned without attacker - continue to normal damage logic below
                } else {
                    // Pinned, but no attacker specified - die immediately
                    actualPiece.alive = false;
                    if (PIECE_TYPES[actualPiece.type].isKing) {
                        addLog(`${actualPiece.player === 1 ? 'P1' : 'P2'} King destroyed (pinned)!`, 'system');
                        endGame(actualPiece.player === 1 ? 2 : 1, 'kingkill');
                    } else {
                        addLog(`${actualPiece.player === 1 ? 'P1' : 'P2'} ${PIECE_TYPES[actualPiece.type].name} destroyed (pinned)`, actualPiece.player);
                    }
                    return;
                }
            }

            // Handle King special case
            if (PIECE_TYPES[actualPiece.type].isKing) {
                // If we got here, King was pinned but is no longer pinned after removing attacker
                // OR King is not pinned at all
                // King can only be damaged if it was pinned and no longer pinned after removing attacker
                if (!actualPiece.pinned) {
                    // King not pinned - cannot be damaged
                    return;
                }
                // King was pinned but no longer pinned - apply normal damage
                actualPiece.hp -= damage;
                if (actualPiece.hp <= 0) {
                    actualPiece.alive = false;
                    addLog(`${actualPiece.player === 1 ? 'P1' : 'P2'} King destroyed!`, 'system');
                    endGame(actualPiece.player === 1 ? 2 : 1, 'kingkill');
                }
                return;
            }

            actualPiece.hp -= damage;
            if (actualPiece.hp <= 0) {
                actualPiece.alive = false;
                addLog(`${actualPiece.player === 1 ? 'P1' : 'P2'} ${PIECE_TYPES[actualPiece.type].name} destroyed`, actualPiece.player);
            }
        }

        function updatePins() {
            const activePlayer = gameState.currentPlayer;
            const otherPlayer = activePlayer === 1 ? 2 : 1;

            // Reset all pin states
            gameState.pieces.forEach(piece => {
                if (piece.alive) {
                    piece.pinned = false;
                }
            });

            // Clear pinning paths and pinning map
            gameState.pinningPaths = [];
            gameState.pinningMap.clear();

            // Group pieces by player
            const piecesByPlayer = { 1: [], 2: [] };
            gameState.pieces.forEach(piece => {
                if (piece.alive) {
                    piecesByPlayer[piece.player].push(piece);
                }
            });

            // Step 1: Calculate pinnings from active player
            const activeAllies = piecesByPlayer[activePlayer];
            const activeEnemies = piecesByPlayer[otherPlayer];

            // Check all pairs of allies from the active player
            for (let i = 0; i < activeAllies.length; i++) {
                for (let j = i + 1; j < activeAllies.length; j++) {
                    const ally1 = activeAllies[i];
                    const ally2 = activeAllies[j];

                    // Find all valid paths between these allies
                    const paths = findValidPinningPaths(ally1, ally2, activePlayer);

                    paths.forEach(path => {
                        // Store this pinning path for visualization (with player info)
                        gameState.pinningPaths.push({ path: path, player: activePlayer });

                        // Find the indices of the pinning allies
                        const ally1Index = gameState.pieces.findIndex(p => p === ally1);
                        const ally2Index = gameState.pieces.findIndex(p => p === ally2);

                        // Mark all enemies on this path as pinned and track which allies are pinning them
                        path.forEach(step => {
                            if (step.q === ally1.q && step.r === ally1.r) return;
                            if (step.q === ally2.q && step.r === ally2.r) return;

                            const enemy = getPieceAt(step.q, step.r);
                            if (enemy && enemy.player !== activePlayer && enemy.alive) {
                                enemy.pinned = true;

                                // Track which allies are pinning this enemy
                                const enemyIndex = gameState.pieces.findIndex(p => p === enemy);
                                if (!gameState.pinningMap.has(enemyIndex)) {
                                    gameState.pinningMap.set(enemyIndex, new Set());
                                }
                                gameState.pinningMap.get(enemyIndex).add(ally1Index);
                                gameState.pinningMap.get(enemyIndex).add(ally2Index);
                            }
                        });
                    });
                }
            }

            // Step 2: Calculate pinnings from other player
            // Pieces already pinned cannot be used to pin other pieces
            const otherAllies = piecesByPlayer[otherPlayer].filter(piece => !piece.pinned);
            const otherEnemies = piecesByPlayer[activePlayer];

            // Check all pairs of allies from the other player (excluding pinned pieces)
            for (let i = 0; i < otherAllies.length; i++) {
                for (let j = i + 1; j < otherAllies.length; j++) {
                    const ally1 = otherAllies[i];
                    const ally2 = otherAllies[j];

                    // Find all valid paths between these allies
                    const paths = findValidPinningPaths(ally1, ally2, otherPlayer);

                    paths.forEach(path => {
                        // Store this pinning path for visualization (with player info)
                        gameState.pinningPaths.push({ path: path, player: otherPlayer });

                        // Find the indices of the pinning allies
                        const ally1Index = gameState.pieces.findIndex(p => p === ally1);
                        const ally2Index = gameState.pieces.findIndex(p => p === ally2);

                        // Mark all enemies on this path as pinned and track which allies are pinning them
                        path.forEach(step => {
                            if (step.q === ally1.q && step.r === ally1.r) return;
                            if (step.q === ally2.q && step.r === ally2.r) return;

                            const enemy = getPieceAt(step.q, step.r);
                            if (enemy && enemy.player !== otherPlayer && enemy.alive) {
                                enemy.pinned = true;

                                // Track which allies are pinning this enemy
                                const enemyIndex = gameState.pieces.findIndex(p => p === enemy);
                                if (!gameState.pinningMap.has(enemyIndex)) {
                                    gameState.pinningMap.set(enemyIndex, new Set());
                                }
                                gameState.pinningMap.get(enemyIndex).add(ally1Index);
                                gameState.pinningMap.get(enemyIndex).add(ally2Index);
                            }
                        });
                    });
                }
            }

            // Render pinning paths
            renderPinningPaths();

            // Check if all enemies are pinned (win condition)
            checkAllEnemiesPinned();
        }

        // Calculate preview pinning paths for a simulated move
        function calculatePreviewPinning(pieceIndex, destination, path) {
            // Save current state
            const savedPieces = JSON.parse(JSON.stringify(gameState.pieces));
            const savedPinningPaths = [...gameState.pinningPaths];
            const savedPinningMap = new Map(gameState.pinningMap);

            const piece = gameState.pieces[pieceIndex];
            const config = gameState.unitConfigs[piece.type];
            const ramDamage = config.ramDamage;
            const destOccupant = getPieceAt(destination.q, destination.r);

            // Simulate damage along path (excluding destination)
            const damagePath = calculateDamagePath(piece, path);
            damagePath.forEach(pos => {
                if (pos.q === destination.q && pos.r === destination.r) return;
                const target = pos.piece || getPieceAt(pos.q, pos.r);
                if (target && target.player !== piece.player) {
                    // Apply damage - kill if HP would drop to 0 or below
                    if (target.hp <= ramDamage) {
                        target.alive = false;
                    } else {
                        target.hp -= ramDamage;
                    }
                }
            });

            // Kill destination if enemy
            if (destOccupant && destOccupant.player !== piece.player) {
                destOccupant.alive = false;
            }

            // Move the piece
            piece.q = destination.q;
            piece.r = destination.r;

            // Calculate pins after simulated move using two-step process
            const activePlayer = gameState.currentPlayer;
            const otherPlayer = activePlayer === 1 ? 2 : 1;
            const previewPaths = [];

            // Reset pin states for preview calculation
            gameState.pieces.forEach(p => {
                if (p.alive) {
                    p.pinned = false;
                }
            });

            // Group pieces by player
            const piecesByPlayer = { 1: [], 2: [] };
            gameState.pieces.forEach(p => {
                if (p.alive) {
                    piecesByPlayer[p.player].push(p);
                }
            });

            // Step 1: Calculate pinnings from active player
            const activeAllies = piecesByPlayer[activePlayer];
            const activeEnemies = piecesByPlayer[otherPlayer];

            // Check all pairs of allies from the active player
            for (let i = 0; i < activeAllies.length; i++) {
                for (let j = i + 1; j < activeAllies.length; j++) {
                    const ally1 = activeAllies[i];
                    const ally2 = activeAllies[j];

                    // Find all valid paths between these allies
                    const paths = findValidPinningPaths(ally1, ally2, activePlayer);

                    paths.forEach(path => {
                        previewPaths.push({ path: path, player: activePlayer });

                        // Mark enemies on this path as pinned
                        path.forEach(step => {
                            if (step.q === ally1.q && step.r === ally1.r) return;
                            if (step.q === ally2.q && step.r === ally2.r) return;

                            const enemy = getPieceAt(step.q, step.r);
                            if (enemy && enemy.player !== activePlayer && enemy.alive) {
                                enemy.pinned = true;
                            }
                        });
                    });
                }
            }

            // Step 2: Calculate pinnings from other player
            // Pieces already pinned cannot be used to pin other pieces
            const otherAllies = piecesByPlayer[otherPlayer].filter(p => !p.pinned);
            const otherEnemies = piecesByPlayer[activePlayer];

            // Check all pairs of allies from the other player (excluding pinned pieces)
            for (let i = 0; i < otherAllies.length; i++) {
                for (let j = i + 1; j < otherAllies.length; j++) {
                    const ally1 = otherAllies[i];
                    const ally2 = otherAllies[j];

                    // Find all valid paths between these allies
                    const paths = findValidPinningPaths(ally1, ally2, otherPlayer);

                    paths.forEach(path => {
                        previewPaths.push({ path: path, player: otherPlayer });

                        // Mark enemies on this path as pinned
                        path.forEach(step => {
                            if (step.q === ally1.q && step.r === ally1.r) return;
                            if (step.q === ally2.q && step.r === ally2.r) return;

                            const enemy = getPieceAt(step.q, step.r);
                            if (enemy && enemy.player !== otherPlayer && enemy.alive) {
                                enemy.pinned = true;
                            }
                        });
                    });
                }
            }

            // Restore original state
            gameState.pieces = JSON.parse(JSON.stringify(savedPieces));
            gameState.pinningPaths = savedPinningPaths;
            gameState.pinningMap = savedPinningMap;

            return previewPaths;
        }

        function renderPinningPaths() {
            const pinningGroup = document.getElementById('pinning-paths-group');
            if (!pinningGroup) return;

            // Clear existing paths
            pinningGroup.innerHTML = '';

            // If there are preview paths, only show preview (hide current pinning)
            if (gameState.previewPinningPaths.length > 0) {
                // Render preview pinning paths using player colors (red/blue)
                gameState.previewPinningPaths.forEach(pinningData => {
                    const path = pinningData.path;
                    const player = pinningData.player;

                    if (path.length < 2) return;

                    // Create a path element for preview
                    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                    // Build path data
                    let pathData = '';
                    path.forEach((step, index) => {
                        const { x, y } = hexToPixel(step.q, step.r);
                        if (index === 0) {
                            pathData += `M ${x} ${y}`;
                        } else {
                            pathData += ` L ${x} ${y}`;
                        }
                    });

                    // Use player team colors for preview pinning
                    // Player 1: brighter red, Player 2: brighter blue for preview
                    const previewColor = player === 1 ? '#ff6b6b' : '#6bb5ff';
                    const opacity = '0.8';
                    const strokeWidth = '3';

                    pathElement.setAttribute('d', pathData);
                    pathElement.setAttribute('stroke', previewColor);
                    pathElement.setAttribute('stroke-width', strokeWidth);
                    pathElement.setAttribute('fill', 'none');
                    pathElement.setAttribute('opacity', opacity);
                    pathElement.setAttribute('stroke-dasharray', '4 4'); // Dashed line for preview
                    pathElement.style.pointerEvents = 'none';
                    pathElement.classList.add('preview-pin');

                    pinningGroup.appendChild(pathElement);
                });
            } else {
                // No preview - render current pinning paths (solid lines)
                gameState.pinningPaths.forEach(pinningData => {
                    const path = pinningData.path;
                    const player = pinningData.player;

                    if (path.length < 2) return;

                    // Create a path element
                    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                    // Build path data
                    let pathData = '';
                    path.forEach((step, index) => {
                        const { x, y } = hexToPixel(step.q, step.r);
                        if (index === 0) {
                            pathData += `M ${x} ${y}`;
                        } else {
                            pathData += ` L ${x} ${y}`;
                        }
                    });

                    // Use team color for the pin line
                    const teamColor = player === 1 ? 'var(--player1)' : 'var(--player2)';
                    // Make blue (player 2) pins more visible
                    const opacity = player === 2 ? '0.7' : '0.5';
                    const strokeWidth = '3';

                    pathElement.setAttribute('d', pathData);
                    pathElement.setAttribute('stroke', teamColor);
                    pathElement.setAttribute('stroke-width', strokeWidth);
                    pathElement.setAttribute('fill', 'none');
                    pathElement.setAttribute('opacity', opacity);
                    pathElement.setAttribute('stroke-dasharray', '4 4');
                    pathElement.style.pointerEvents = 'none';

                    pinningGroup.appendChild(pathElement);
                });
            }
        }

        // Get relative direction from entry direction
        // Returns: { straight, left, right } as direction indices
        // When entering from entryDir, valid exits are:
        // - Straight: opposite side (entryDir + 3) % 6
        // - Left: one step counterclockwise from straight: (straight + 1) % 6 = (entryDir + 4) % 6
        // - Right: one step clockwise from straight: (straight - 1 + 6) % 6 = (entryDir + 2) % 6
        function getRelativeDirections(entryDir) {
            const straight = (entryDir + 3) % 6; // Opposite
            const left = (entryDir + 4) % 6;     // One step left (counterclockwise) of straight
            const right = (entryDir + 2) % 6;    // One step right (clockwise) of straight
            return { straight, left, right };
        }

        // Determine turn direction: 'straight', 'left', or 'right'
        function getTurnDirection(entryDir, exitDir) {
            const rel = getRelativeDirections(entryDir);
            if (exitDir === rel.straight) return 'straight';
            if (exitDir === rel.left) return 'left';
            if (exitDir === rel.right) return 'right';
            return null; // Invalid (backward or sideways)
        }

        // Update lean state based on turn
        // lean: 'none' | 'left' | 'right'
        // turn: 'straight' | 'left' | 'right'
        function updateLean(lean, turn) {
            if (turn === 'straight') return lean; // Straight doesn't change lean
            if (turn === 'left') {
                if (lean === 'left') return null; // Can't turn left twice
                return 'left'; // Now leaning left
            }
            if (turn === 'right') {
                if (lean === 'right') return null; // Can't turn right twice
                return 'right'; // Now leaning right
            }
            return null;
        }

        function findValidPinningPaths(start, end, pinningPlayer = null) {
            const paths = [];
            // Use provided pinningPlayer or default to currentPlayer for backwards compatibility
            const activePlayer = pinningPlayer !== null ? pinningPlayer : gameState.currentPlayer;
            const enemies = gameState.pieces.filter(p => 
                p.alive && p.player !== activePlayer
            );

            // Verify that start and end are both allies of the pinning player
            const startPiece = getPieceAt(start.q, start.r);
            const endPiece = getPieceAt(end.q, end.r);
            if (!startPiece || !startPiece.alive || startPiece.player !== activePlayer) return paths;
            if (!endPiece || !endPiece.alive || endPiece.player !== activePlayer) return paths;

            // Try all possible starting directions from start hex
            for (let startDir = 0; startDir < 6; startDir++) {
                const neighbor = hexNeighbor(start.q, start.r, startDir);
                if (!isValidHex(neighbor.q, neighbor.r)) continue;

                // Check if first step has an enemy (path must travel through enemies)
                const firstStepPiece = getPieceAt(neighbor.q, neighbor.r);
                if (!firstStepPiece || !firstStepPiece.alive || firstStepPiece.player === activePlayer) {
                    continue; // Must start with an enemy
                }

                // When we move from start to neighbor in direction startDir,
                // the neighbor sees us entering from the opposite direction: (startDir + 3) % 6
                const entryDirForNeighbor = (startDir + 3) % 6;

                // Start pathfinding with entry direction from neighbor's perspective
                findPathWithRules(
                    neighbor.q, neighbor.r,
                    entryDirForNeighbor,
                    end.q, end.r,
                    [{ q: start.q, r: start.r }, { q: neighbor.q, r: neighbor.r }],
                    'none' // Initial lean state
                );
            }

            function findPathWithRules(q, r, entryDir, targetQ, targetR, path, lean) {
                const currentPath = [...path, { q, r }];

                // Limit path length to prevent infinite loops
                if (currentPath.length >= 20) return;

                // Get valid exit directions (relative to entry)
                const rel = getRelativeDirections(entryDir);
                const validExits = [rel.straight, rel.left, rel.right];

                // Try each valid exit direction
                for (const exitDir of validExits) {
                    const neighbor = hexNeighbor(q, r, exitDir);
                    if (!isValidHex(neighbor.q, neighbor.r)) continue;

                    // Check if already in path (no backtracking)
                    if (currentPath.some(step => step.q === neighbor.q && step.r === neighbor.r)) continue;

                    // Determine turn direction
                    const turn = getTurnDirection(entryDir, exitDir);
                    if (turn === null) continue; // Invalid direction

                    // Update lean state
                    const newLean = updateLean(lean, turn);
                    if (newLean === null) continue; // Violates zig-zag rule

                    // Check if this neighbor is the target (must check before checking occupant)
                    if (neighbor.q === targetQ && neighbor.r === targetR) {
                        // Reached target! Create final path and validate
                        const finalPath = [...currentPath, { q: neighbor.q, r: neighbor.r }];
                        if (isPathValidForPinning(finalPath, activePlayer, enemies)) {
                            paths.push(finalPath);
                        }
                        continue; // Don't continue from target
                    }

                    // Check if this cell has an enemy (path must travel through enemies)
                    const occupant = getPieceAt(neighbor.q, neighbor.r);
                    if (!occupant || !occupant.alive) continue; // Must have a piece
                    if (occupant.player === activePlayer) continue; // Can't be an ally (except endpoints which we already checked above)

                    // Continue pathfinding
                    // Entry direction for next hex is the direction we came from (opposite of exitDir)
                    const nextEntryDir = (exitDir + 3) % 6;
                    findPathWithRules(
                        neighbor.q, neighbor.r,
                        nextEntryDir,
                        targetQ, targetR,
                        currentPath,
                        newLean
                    );
                }
            }

            return paths;
        }

        function getDirectionFrom(from, to) {
            // Find which direction from 'from' to 'to'
            for (let dir = 0; dir < 6; dir++) {
                const neighbor = hexNeighbor(from.q, from.r, dir);
                if (neighbor.q === to.q && neighbor.r === to.r) {
                    return dir;
                }
            }
            return -1;
        }

        // Verify that a path travels exclusively through enemies (excluding endpoints which are allies)
        function isPathValidForPinning(path, activePlayer, enemies) {
            // Path must have at least 3 cells (start ally, middle enemies, end ally)
            if (path.length < 3) return false;

            // Check that endpoints are allies
            const startPiece = getPieceAt(path[0].q, path[0].r);
            const endPiece = getPieceAt(path[path.length - 1].q, path[path.length - 1].r);
            if (!startPiece || !startPiece.alive || startPiece.player !== activePlayer) return false;
            if (!endPiece || !endPiece.alive || endPiece.player !== activePlayer) return false;

            // Check that every cell along the path (excluding endpoints) has an enemy
            for (let i = 1; i < path.length - 1; i++) {
                const step = path[i];
                const occupant = getPieceAt(step.q, step.r);

                // Must have an enemy at this position
                if (!occupant || !occupant.alive) return false;
                if (occupant.player === activePlayer) return false; // Can't be an ally
                if (!enemies.includes(occupant)) return false; // Must be in enemies list
            }

            return true;
        }

        function isPathPinned(path, enemies) {
            // Legacy function - now just checks that middle cells have enemies
            // The pathfinding already ensures paths travel through enemies, but keep this for safety
            for (let i = 1; i < path.length - 1; i++) {
                const step = path[i];
                const occupant = getPieceAt(step.q, step.r);

                // Must have an enemy at this position
                if (!occupant || !occupant.alive) return false;
                if (!enemies.includes(occupant)) return false;
            }

            return path.length > 2; // Path must have at least 3 cells (start, middle, end)
        }

        function executeRotation(ring, clockwise) {
            const ringHexes = getHexesInRing(ring);
            const piecesInRing = gameState.pieces.filter(p =>
                p.alive && getRing(p.q, p.r) === ring
            );

            // Rotate each piece
            piecesInRing.forEach(piece => {
                const rotated = rotateHexAroundCenter(piece.q, piece.r, clockwise ? 1 : -1);
                piece.q = rotated.q;
                piece.r = rotated.r;
            });

            addLog(`${gameState.currentPlayer === 1 ? 'P1' : 'P2'} King rotates ring ${ring} ${clockwise ? 'CW' : 'CCW'}`, gameState.currentPlayer);

            // Update pins after rotation
            updatePins();

            // Check for pin + ram kills
            checkPinnedKings();
        }

        function checkPinnedKings() {
            gameState.pieces.forEach(piece => {
                if (piece.alive && PIECE_TYPES[piece.type].isKing && piece.pinned) {
                    // Check if any adjacent enemy can ram
                    // This is evaluated after rotation
                }
            });
        }

        function checkArmyElimination() {
            [1, 2].forEach(player => {
                const nonKingPieces = gameState.pieces.filter(p =>
                    p.player === player && p.alive && !PIECE_TYPES[p.type].isKing
                );
                if (nonKingPieces.length === 0) {
                    endGame(player === 1 ? 2 : 1, 'elimination');
                }
            });
        }

        function checkAllEnemiesPinned() {
            [1, 2].forEach(player => {
                const enemyPlayer = player === 1 ? 2 : 1;
                const enemyPieces = gameState.pieces.filter(p =>
                    p.player === enemyPlayer && p.alive
                );

                // If there are no enemy pieces, skip (already handled by elimination check)
                if (enemyPieces.length === 0) return;

                // Check if all enemy pieces are pinned
                const allPinned = enemyPieces.every(piece => piece.pinned);

                if (allPinned) {
                    endGame(player, 'allpinned');
                }
            });
        }

        function endGame(winner, reason) {
            gameState.phase = 'ended';

            const reasons = {
                throne: `Player ${winner} captures the Throne!`,
                kingkill: `Player ${winner} destroys the enemy King!`,
                elimination: `Player ${winner} eliminates all enemy units!`,
                allpinned: `Player ${winner} pins all enemy pieces!`
            };

            document.getElementById('victory-title').textContent = `Player ${winner} Wins!`;
            document.getElementById('victory-message').textContent = reasons[reason];
            document.getElementById('victory-modal').classList.add('active');

            addLog(`VICTORY: ${reasons[reason]}`, 'system');
        }

        function useAction(pieceIndex) {
            gameState.usedPieces.add(pieceIndex);
            gameState.hasAnyPieceMoved = true;
            gameState.actionsRemaining--;
            updateUI();
            updateAutoMoveVisibility();

            if (gameState.actionsRemaining <= 0) {
                endTurn();
            }
        }

        function endTurn() {
            if (gameState.pathBuilding) {
                cancelPathBuilding();
            }

            // Clear all pins at the end of the turn
            gameState.pieces.forEach(piece => {
                if (piece.alive) {
                    piece.pinned = false;
                }
            });
            gameState.pinningPaths = [];
            gameState.pinningMap.clear();
            gameState.previewPinningPaths = []; // Clear preview pinning

            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;

            // After the first turn, all players get 2 actions
            if (gameState.isFirstTurn) {
                gameState.isFirstTurn = false;
            }
            gameState.actionsRemaining = gameState.params.actionsPerTurn;

            gameState.usedPieces.clear();
            gameState.selectedPiece = null;
            gameState.validMoves = [];

            updatePins();
            saveTurnSnapshot();

            updateUI();
            clearHighlights();
            renderPieces();
            document.getElementById('btn-rotate').style.display = 'none';

            addLog(`--- Player ${gameState.currentPlayer}'s Turn ---`, 'system');

            // Trigger CPU turn if applicable
            if (gameState.gameMode === 'vsCPU' && gameState.currentPlayer === gameState.cpuPlayer) {
                setTimeout(cpuTakeTurn, 800);
            }
        }

        async function cpuTakeTurn() {
            if (gameState.phase !== 'playing') return;
            const myPlayer = gameState.cpuPlayer;

            addLog('CPU thinking...', gameState.currentPlayer);

            // Loop until no actions remaining or game ends
            while (gameState.actionsRemaining > 0 && gameState.phase === 'playing') {
                // SAFETY: Stop if it's no longer my turn (e.g. game reset, or turn ended externally)
                if (gameState.currentPlayer !== myPlayer) return;

                const thoughtTime = 600 + Math.random() * 400; // Random delay for realism
                await new Promise(r => setTimeout(r, thoughtTime));

                // SAFETY: Check again after await
                if (gameState.currentPlayer !== myPlayer || gameState.phase !== 'playing') return;

                // Execute best move
                autoMove();

                // Check if game ended during autoMove (e.g. invalid move causing issues, or win)
                if (gameState.phase !== 'playing') break;
            }

            // End turn automatically - ONLY if it's still my turn
            if (gameState.phase === 'playing' && gameState.currentPlayer === myPlayer) {
                await new Promise(r => setTimeout(r, 600));
                if (gameState.phase === 'playing' && gameState.currentPlayer === myPlayer) {
                    endTurn();
                }
            }
        }

        function saveTurnSnapshot() {
            gameState.turnSnapshot = {
                pieces: JSON.parse(JSON.stringify(gameState.pieces)),
                actionsRemaining: gameState.actionsRemaining,
                hasAnyPieceMoved: gameState.hasAnyPieceMoved
            };
        }

        function resetTurn() {
            if (!gameState.turnSnapshot) return;

            gameState.pieces = JSON.parse(JSON.stringify(gameState.turnSnapshot.pieces));
            gameState.actionsRemaining = gameState.turnSnapshot.actionsRemaining;
            gameState.hasAnyPieceMoved = gameState.turnSnapshot.hasAnyPieceMoved;

            gameState.usedPieces.clear();
            gameState.selectedPiece = null;
            gameState.validMoves = [];

            if (gameState.pathBuilding) cancelPathBuilding();
            if (gameState.rotationMode) exitRotationMode();

            updatePins();
            updateUI();
            updateArmyDisplay();
            clearHighlights();
            renderPieces();

            addLog(`Turn reset to start of Player ${gameState.currentPlayer}'s turn.`, 'system');
        }

        // ============================================
        // INPUT HANDLING
        // ============================================

        function onHexClick(q, r, e) {
            if (gameState.phase !== 'playing') return;

            if (gameState.rotationMode) {
                handleRotationClick(q, r);
                return;
            }

            // Path building mode
            if (gameState.pathBuilding && gameState.pathStartPiece !== null) {
                const piece = gameState.pieces[gameState.pathStartPiece];
                const validNext = getValidNextSteps(piece, gameState.currentPath);
                const clickedStep = validNext.find(step => step.q === q && step.r === r);

                if (clickedStep) {
                    // Add this step to path
                    gameState.currentPath.push({ q, r });
                    updatePathVisualization();
                } else {
                    // Check if clicking the last step again (confirm move)
                    if (gameState.currentPath.length > 0) {
                        const last = gameState.currentPath[gameState.currentPath.length - 1];
                        if (last.q === q && last.r === r) {
                            confirmPathMove();
                            return;
                        }
                    }
                    // Invalid step - cancel path building
                    cancelPathBuilding();
                }
                return;
            }

            // Old behavior - deselect
            if (gameState.selectedPiece !== null) {
                gameState.selectedPiece = null;
                gameState.validMoves = [];
                clearHighlights();
                renderPieces();
                document.getElementById('btn-rotate').style.display = 'none';
            }
        }

        function onPieceClick(index) {
            const piece = gameState.pieces[index];

            if (gameState.phase !== 'playing') return;

            // In rotation mode, treat piece clicks same as hex clicks - select the ring
            if (gameState.rotationMode) {
                handleRotationClick(piece.q, piece.r);
                return;
            }

            // If we're in path building mode, check if this piece is on a valid next step
            if (gameState.pathBuilding && gameState.pathStartPiece !== null) {
                const pathPiece = gameState.pieces[gameState.pathStartPiece];
                const validNext = getValidNextSteps(pathPiece, gameState.currentPath);
                const clickedStep = validNext.find(step => step.q === piece.q && step.r === piece.r);

                if (clickedStep) {
                    // This piece is on a valid move tile - continue the path
                    gameState.currentPath.push({ q: piece.q, r: piece.r });
                    updatePathVisualization();
                    return;
                } else {
                    // This piece is not on a valid move tile - cancel path building
                    cancelPathBuilding();
                }
            }

            // Select the piece type in the unit editor
            selectUnitForEdit(piece.type);

            // Select own piece - start path building
            if (piece.player === gameState.currentPlayer && !gameState.usedPieces.has(index)) {
                // Pinned pieces cannot be selected
                if (piece.pinned) {
                    addLog('Pinned pieces cannot move or take actions!', 'system');
                    return;
                }
                startPathBuilding(index);
            }
        }

        function startPathBuilding(pieceIndex) {
            const piece = gameState.pieces[pieceIndex];

            // Pinned pieces cannot take actions
            if (piece.pinned) {
                addLog('Pinned pieces cannot move or take actions!', 'system');
                return;
            }

            gameState.pathBuilding = true;
            gameState.pathStartPiece = pieceIndex;
            gameState.currentPath = [];
            gameState.selectedPiece = pieceIndex;

            // Show rotate button if King (and not pinned)
            const rotateBtn = document.getElementById('btn-rotate');
            if (PIECE_TYPES[piece.type].isKing && !piece.pinned) {
                rotateBtn.style.display = 'flex';
            } else {
                rotateBtn.style.display = 'none';
            }

            updatePathVisualization();
            updateAutoMoveVisibility();
        }

        function cancelPathBuilding() {
            gameState.pathBuilding = false;
            gameState.currentPath = [];
            gameState.pathStartPiece = null;
            gameState.selectedPiece = null;
            gameState.previewPinningPaths = []; // Clear preview pinning
            clearHighlights();
            renderPieces();
            renderPinningPaths(); // Re-render to clear preview paths
            document.getElementById('btn-rotate').style.display = 'none';
            document.getElementById('btn-confirm-path').style.display = 'none';
            document.getElementById('btn-cancel-path').style.display = 'none';
            updateAutoMoveVisibility();
        }

        function updatePathVisualization() {
            if (!gameState.pathBuilding || gameState.pathStartPiece === null) return;

            const piece = gameState.pieces[gameState.pathStartPiece];
            const validNext = getValidNextSteps(piece, gameState.currentPath);

            clearHighlights();

            // Highlight current path
            gameState.currentPath.forEach((step, idx) => {
                const hex = document.querySelector(`.hex[data-q="${step.q}"][data-r="${step.r}"]`);
                if (hex) {
                    if (idx === gameState.currentPath.length - 1) {
                        hex.classList.add('path-end'); // Last step highlighted more prominently
                    } else {
                        hex.classList.add('path-step'); // Intermediate steps
                    }
                }
            });

            // Highlight valid next steps
            validNext.forEach(step => {
                const hex = document.querySelector(`.hex[data-q="${step.q}"][data-r="${step.r}"]`);
                if (hex) {
                    if (step.hasEnemy) {
                        hex.classList.add('damage-path');
                    } else {
                        hex.classList.add('valid-move');
                    }
                }
            });

            // Calculate and show preview pinning if path is complete
            gameState.previewPinningPaths = [];
            if (gameState.currentPath.length > 0) {
                const destination = gameState.currentPath[gameState.currentPath.length - 1];
                // Only calculate preview if destination is valid (not a friendly unit)
                const occupant = getPieceAt(destination.q, destination.r);
                if (!occupant || occupant.player !== piece.player) {
                    try {
                        const previewPaths = calculatePreviewPinning(
                            gameState.pathStartPiece,
                            destination,
                            gameState.currentPath
                        );
                        gameState.previewPinningPaths = previewPaths;
                    } catch (e) {
                        // If preview calculation fails, just don't show preview
                        console.warn('Preview pinning calculation failed:', e);
                    }
                }
            }

            // Show confirm/cancel buttons
            const confirmBtn = document.getElementById('btn-confirm-path');
            const cancelBtn = document.getElementById('btn-cancel-path');
            if (gameState.currentPath.length > 0) {
                confirmBtn.style.display = 'flex';
            } else {
                confirmBtn.style.display = 'none';
            }
            cancelBtn.style.display = 'inline-block';

            renderPieces();
            renderPinningPaths(); // Re-render to show preview paths
        }

        function confirmPathMove() {
            if (!gameState.pathBuilding || gameState.pathStartPiece === null || gameState.currentPath.length === 0) {
                return;
            }

            const piece = gameState.pieces[gameState.pathStartPiece];
            const destination = gameState.currentPath[gameState.currentPath.length - 1];
            const damagePath = calculateDamagePath(piece, gameState.currentPath);

            // Check if destination is valid
            const occupant = getPieceAt(destination.q, destination.r);

            // Cannot land on friendly
            if (occupant && occupant.player === piece.player) {
                addLog('Cannot land on friendly unit!', 'system');
                return;
            }

            // If landing on enemy, must kill it
            // Use simulateMoveAndValidate to check if move is valid (reuses same logic as applyDamage)
            if (occupant && occupant.player !== piece.player) {
                const move = {
                    q: destination.q,
                    r: destination.r,
                    damagePath: damagePath,
                    willKill: true,
                    path: gameState.currentPath
                };
                const ramDamage = gameState.unitConfigs[piece.type].ramDamage;
                
                if (!simulateMoveAndValidate(gameState.pathStartPiece, destination.q, destination.r, move, ramDamage)) {
                    addLog('Cannot land on enemy that would survive!', 'system');
                    return;
                }
            }

            // Execute the move
            const move = {
                q: destination.q,
                r: destination.r,
                damagePath: damagePath,
                willKill: occupant && occupant.player !== piece.player,
                path: gameState.currentPath
            };

            // Only consume action if move succeeds
            const moveSucceeded = executeMove(gameState.pathStartPiece, destination.q, destination.r, move);
            if (!moveSucceeded) {
                // Move was rejected - don't consume action, don't clean up path building
                // User can try a different move
                return;
            }

            useAction(gameState.pathStartPiece);

            // Clean up
            cancelPathBuilding();
            updateArmyDisplay();
        }


        function handleRotationClick(q, r) {
            const ring = getRing(q, r);
            if (ring === 0 || ring > BOARD_RADIUS) return;

            gameState.selectedRing = ring;
            document.getElementById('rotation-ring').textContent = ring;

            // Highlight selected ring
            document.querySelectorAll('.ring-highlight').forEach(el => el.classList.remove('active'));
            document.getElementById(`ring-${ring}`).classList.add('active');
        }

        function setupRotationControls() {
            document.getElementById('rotate-cw').addEventListener('click', () => {
                if (gameState.selectedRing) {
                    executeRotation(gameState.selectedRing, true);
                    exitRotationMode();
                    useAction(gameState.selectedPiece);
                    gameState.selectedPiece = null;
                    renderPieces();
                }
            });

            document.getElementById('rotate-ccw').addEventListener('click', () => {
                if (gameState.selectedRing) {
                    executeRotation(gameState.selectedRing, false);
                    exitRotationMode();
                    useAction(gameState.selectedPiece);
                    gameState.selectedPiece = null;
                    renderPieces();
                }
            });

            document.getElementById('rotate-cancel').addEventListener('click', () => {
                exitRotationMode();
            });
        }

        function enterRotationMode(pieceIndex) {
            const piece = gameState.pieces[pieceIndex];
            if (!PIECE_TYPES[piece.type].isKing) return;

            // Pinned pieces cannot take actions
            if (piece.pinned) {
                addLog('Pinned pieces cannot move or take actions!', 'system');
                return;
            }

            gameState.rotationMode = true;
            gameState.selectedRing = 1;

            document.getElementById('action-controls').style.display = 'none';
            const controls = document.getElementById('rotation-controls');
            controls.style.display = 'flex';
            controls.style.top = '24px';
            controls.style.left = '50%';
            controls.style.transform = 'translateX(-50%)';

            document.getElementById('rotation-ring').textContent = '1';
            document.getElementById(`ring-1`).classList.add('active');
            updateAutoMoveVisibility();
        }

        function exitRotationMode() {
            gameState.rotationMode = false;
            gameState.selectedRing = null;
            document.getElementById('rotation-controls').style.display = 'none';
            document.getElementById('action-controls').style.display = 'flex';
            document.querySelectorAll('.ring-highlight').forEach(el => el.classList.remove('active'));
            updateAutoMoveVisibility();
        }

        // ============================================
        // UI UPDATES
        // ============================================

        function updateUI() {
            const indicator = document.getElementById('turn-indicator');
            const nameEl = indicator.querySelector('.player-name');

            indicator.className = `turn-indicator player${gameState.currentPlayer}`;
            nameEl.textContent = `Player ${gameState.currentPlayer}`;

            // CPU overrides
            if (gameState.gameMode === 'vsCPU' && gameState.currentPlayer === gameState.cpuPlayer) {
                nameEl.textContent = 'CPU (Thinking...)';
                nameEl.style.color = 'var(--player-cpu)';
                indicator.style.borderColor = 'var(--player-cpu)';
            } else {
                nameEl.style.color = '';
                indicator.style.borderColor = '';
            }

            document.getElementById('actions-count').textContent = gameState.actionsRemaining;

            const isCpuTurn = gameState.gameMode === 'vsCPU' && gameState.currentPlayer === gameState.cpuPlayer;
            const canInteract = gameState.phase === 'playing' && !isCpuTurn;

            document.getElementById('btn-end-turn').disabled = !canInteract;

            // Reset Turn button enablement
            const resetTurnBtn = document.getElementById('btn-reset-turn');
            if (resetTurnBtn) {
                const totalActionsForTurn = gameState.isFirstTurn ? 1 : gameState.params.actionsPerTurn;
                resetTurnBtn.disabled = !canInteract || gameState.actionsRemaining >= totalActionsForTurn;
            }
        }


        function updateArmyDisplay() {
            // Update titles
            const p2Title = document.querySelector('.army-title.player2');
            if (gameState.gameMode === 'vsCPU') {
                p2Title.textContent = 'â¬¢ CPU Army';
                p2Title.style.color = 'var(--player-cpu)';
            } else {
                p2Title.textContent = 'â¬¢ Player 2 Army';
                p2Title.style.color = 'var(--player2)';
            }

            [1, 2].forEach(player => {
                const container = document.getElementById(`army-p${player}`);
                container.innerHTML = '';

                gameState.pieces.filter(p => p.player === player).forEach((piece, idx) => {
                    const div = document.createElement('div');
                    div.className = `army-piece player${player}`;

                    if (gameState.gameMode === 'vsCPU' && player === gameState.cpuPlayer) {
                        div.style.background = 'var(--player-cpu-dim)';
                    }

                    if (!piece.alive) div.classList.add('dead');
                    if (piece.pinned) div.classList.add('pinned');
                    div.textContent = PIECE_TYPES[piece.type].symbol;
                    div.title = `${PIECE_TYPES[piece.type].name} HP: ${piece.hp}`;
                    container.appendChild(div);
                });
            });
        }


        function addLog(message, type = 'system') {
            const log = document.getElementById('game-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type === 1 ? 'player1' : type === 2 ? 'player2' : 'system'}`;
            entry.textContent = message;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // ============================================
        // UNIT EDITOR
        // ============================================

        function setupUnitEditor() {
            const selector = document.getElementById('unit-selector');

            Object.entries(PIECE_TYPES).forEach(([type, info]) => {
                const btn = document.createElement('button');
                btn.className = 'unit-btn';
                btn.dataset.type = type;
                btn.textContent = info.symbol;
                btn.title = info.name;
                btn.addEventListener('click', () => selectUnitForEdit(type));
                selector.appendChild(btn);
            });

            setupTemplateSelector();
        }

        function selectUnitForEdit(type) {
            document.querySelectorAll('.unit-btn').forEach(b => b.classList.remove('active'));
            // Find and activate the button for this unit type
            const btn = document.querySelector(`.unit-btn[data-type="${type}"]`);
            if (btn) {
                btn.classList.add('active');
            }

            document.getElementById('unit-details').style.display = 'block';

            const config = gameState.unitConfigs[type];
            const rangeInput = document.getElementById('unit-range');
            rangeInput.value = config.range;

            // Disable range input for King (always 1)
            if (type === 'KING') {
                rangeInput.disabled = true;
                rangeInput.title = 'King move range is always 1';
            } else {
                rangeInput.disabled = false;
                rangeInput.title = '';
            }

            document.getElementById('unit-hp').value = config.hp === Infinity ? 999 : config.hp;

            // Disable Max HP if it's Infinity (King) or if any piece has ever moved
            const hpInput = document.getElementById('unit-hp');
            hpInput.disabled = config.hp === Infinity || gameState.hasAnyPieceMoved;
            if (gameState.hasAnyPieceMoved) {
                hpInput.title = 'Cannot change Max HP: pieces have already moved';
            } else {
                hpInput.title = '';
            }

            document.getElementById('unit-ram-damage').value = config.ramDamage;

            // Update template selector
            document.querySelectorAll('.template-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.template === config.template);
            });

            // Store current editing type
            document.getElementById('unit-details').dataset.type = type;
        }

        function setupTemplateSelector() {
            const selector = document.getElementById('template-selector');
            selector.innerHTML = '';

            // Create template buttons
            const templates = [
                { id: MOVEMENT_TEMPLATES.FREE_MOTION, label: 'Free Motion', desc: 'Move in any direction' },
                { id: MOVEMENT_TEMPLATES.STRAIGHT_LINE, label: 'Straight Line', desc: 'Pick one direction, continue straight' }
            ];

            templates.forEach(template => {
                const btn = document.createElement('button');
                btn.className = 'template-btn';
                btn.dataset.template = template.id;
                btn.innerHTML = `<div style="font-weight: 600; margin-bottom: 4px;">${template.label}</div><div style="font-size: 10px; color: var(--text-muted);">${template.desc}</div>`;
                btn.addEventListener('click', () => selectTemplate(template.id));
                selector.appendChild(btn);
            });

            // Range input handler
            document.getElementById('unit-range').addEventListener('input', (e) => {
                const type = document.getElementById('unit-details').dataset.type;
                if (type) {
                    gameState.unitConfigs[type].range = parseInt(e.target.value);
                    renderPieces();
                }
            });

            // HP input handler
            document.getElementById('unit-hp').addEventListener('input', (e) => {
                const type = document.getElementById('unit-details').dataset.type;
                if (type) {
                    // Check if any piece has ever moved
                    if (gameState.hasAnyPieceMoved) {
                        // Revert the value - can't change if pieces have moved
                        const config = gameState.unitConfigs[type];
                        e.target.value = config.hp === Infinity ? 999 : config.hp;
                        return;
                    }

                    const value = parseInt(e.target.value);
                    const newHP = value === 999 ? Infinity : value;
                    gameState.unitConfigs[type].hp = newHP;

                    // Update all existing pieces of this type
                    gameState.pieces.forEach(piece => {
                        if (piece.type === type && piece.alive) {
                            piece.maxHP = newHP;
                            // Set current HP to new max HP (heal to full)
                            piece.hp = newHP;
                        }
                    });

                    // Update the display
                    renderPieces();
                    updateArmyDisplay();
                }
            });

            // Ram damage input handler
            document.getElementById('unit-ram-damage').addEventListener('input', (e) => {
                const type = document.getElementById('unit-details').dataset.type;
                if (type) {
                    gameState.unitConfigs[type].ramDamage = parseInt(e.target.value);
                    renderPieces();
                }
            });
        }

        function selectTemplate(templateId) {
            const type = document.getElementById('unit-details').dataset.type;
            if (!type) return;

            gameState.unitConfigs[type].template = templateId;

            // Update UI
            document.querySelectorAll('.template-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.template === templateId);
            });
            renderPieces();
        }

        // ============================================
        // PARAMETERS
        // ============================================

        function setupParams() {
            document.getElementById('param-actions').addEventListener('change', (e) => {
                gameState.params.actionsPerTurn = parseInt(e.target.value);
                gameState.actionsRemaining = gameState.params.actionsPerTurn;
                saveTurnSnapshot();
                updateUI();
            });
        }

        // ============================================
        // GAME CONTROLS
        // ============================================

        function startGame(mode = '2player') {
            gameState.gameMode = mode;
            gameState.phase = 'playing';
            gameState.currentPlayer = 1;
            gameState.isFirstTurn = true;
            // First player gets only 1 action on their first turn
            gameState.actionsRemaining = 1;
            gameState.actionsPerTurn = gameState.params.actionsPerTurn;

            // Reset state
            gameState.usedPieces = new Set();
            gameState.hasAnyPieceMoved = false;
            gameState.pieces = [];
            gameState.board = new Map();
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            gameState.rotationMode = false;
            gameState.selectedRing = null;
            gameState.pathBuilding = false;
            gameState.currentPath = [];
            gameState.pathStartPiece = null;
            gameState.pinningPaths = [];
            gameState.pinningMap.clear();

            // Hide modals
            document.getElementById('victory-modal').classList.remove('active');
            document.getElementById('mode-selection-modal').classList.remove('active');

            // Setup board
            setupFixedPositions();
            saveTurnSnapshot();
            updatePins();
            updateUI();
            renderPieces();
            updateArmyDisplay();

            addLog('=== GAME STARTED ===', 'system');
            addLog(`Mode: ${mode === 'vsCPU' ? 'vs CPU' : '2 Player'}`, 'system');
            addLog(`Player 1's Turn (1 action)`, 'system');
        }

        function resetGame() {
            // Just show mode selection
            document.getElementById('victory-modal').classList.remove('active');
            document.getElementById('mode-selection-modal').classList.add('active');
            gameState.phase = 'setup';
            document.getElementById('game-log').innerHTML = '<div class="log-entry system">Game reset.</div>';
        }

        // ============================================
        // AUTO-MOVE AI
        // ============================================

        function pieceValue(piece) {
            if (!piece || !piece.alive) return 0;
            const config = gameState.unitConfigs[piece.type];
            if (PIECE_TYPES[piece.type].isKing) return 9999; // King is priceless
            return piece.hp + config.ramDamage + config.range;
        }

        function countNonKingPieces(player) {
            return gameState.pieces.filter(p =>
                p.player === player && p.alive && !PIECE_TYPES[p.type].isKing
            ).length;
        }

        function evaluateMove(pieceIndex, destination, path) {
            const piece = gameState.pieces[pieceIndex];
            const config = gameState.unitConfigs[piece.type];
            const occupant = getPieceAt(destination.q, destination.r);
            let score = 0;

            // Build move object for validation (same structure as confirmPathMove)
            const damagePath = calculateDamagePath(piece, path);
            const move = {
                q: destination.q,
                r: destination.r,
                damagePath: damagePath,
                willKill: occupant && occupant.player !== piece.player,
                path: path
            };

            // VALIDATION: Use the same validation as executeMove
            const ramDamage = config.ramDamage;
            if (!simulateMoveAndValidate(pieceIndex, destination.q, destination.r, move, ramDamage)) {
                return -Infinity; // Invalid move
            }

            // Win condition: King to throne
            if (PIECE_TYPES[piece.type].isKing && destination.q === 0 && destination.r === 0) {
                return Infinity;
            }

            // Win condition: Capture enemy King
            if (occupant && occupant.player !== piece.player && PIECE_TYPES[occupant.type].isKing) {
                return Infinity;
            }

            // Win condition: Eliminate last non-King piece
            if (occupant && occupant.player !== piece.player && !PIECE_TYPES[occupant.type].isKing) {
                if (countNonKingPieces(occupant.player) === 1) {
                    return Infinity;
                }
            }

            // Capture enemy piece
            if (occupant && occupant.player !== piece.player) {
                score += 500 + pieceValue(occupant);
            }

            // Calculate damage along path (reuse damagePath from validation)
            damagePath.forEach(pos => {
                const target = getPieceAt(pos.q, pos.r);
                if (target && target.player !== piece.player && target !== occupant) {
                    const damageDealt = config.ramDamage;
                    const percentDamage = damageDealt / target.hp;
                    score += 100 + percentDamage * pieceValue(target);
                }
            });

            // Move toward throne (lower ring = better)
            const currentRing = getRing(piece.q, piece.r);
            const newRing = getRing(destination.q, destination.r);
            if (newRing < currentRing) {
                let throneBonus = 30 * (currentRing - newRing);
                // King gets extra incentive to move toward throne
                if (PIECE_TYPES[piece.type].isKing) {
                    throneBonus *= 2; // King is 2x more motivated to approach throne
                }
                score += throneBonus;
            }

            // Penalty: Moving into danger (simple check)
            const enemyPieces = gameState.pieces.filter(p =>
                p.player !== piece.player && p.alive && !p.pinned
            );
            for (const enemy of enemyPieces) {
                if (hexDistance(destination.q, destination.r, enemy.q, enemy.r) <= 1) {
                    if (PIECE_TYPES[piece.type].isKing) {
                        score -= 300; // King in danger is very bad
                    } else {
                        score -= 100;
                    }
                }
            }

            return score;
        }

        function getBestMoveForPiece(pieceIndex) {
            const piece = gameState.pieces[pieceIndex];
            const config = gameState.unitConfigs[piece.type];
            let bestScore = -Infinity;
            let bestPath = null;

            // Get all valid first steps
            const firstSteps = getValidNextSteps(piece, []);

            for (const step of firstSteps) {
                // Skip if this step has a friendly piece - cannot end on friendly
                if (step.hasFriendly) continue;

                // Simple 1-step evaluation
                const path = [{ q: step.q, r: step.r }];
                const score = evaluateMove(pieceIndex, step, path);

                if (score > bestScore) {
                    bestScore = score;
                    bestPath = path;
                }

                // For multi-range pieces, try extending the path
                if (config.range > 1) {
                    const nextSteps = getValidNextSteps(piece, path);
                    for (const step2 of nextSteps) {
                        // Skip if final destination has a friendly piece
                        if (step2.hasFriendly) continue;

                        const path2 = [...path, { q: step2.q, r: step2.r }];
                        const score2 = evaluateMove(pieceIndex, step2, path2);
                        if (score2 > bestScore) {
                            bestScore = score2;
                            bestPath = path2;
                        }
                    }
                }
            }

            return { score: bestScore, path: bestPath };
        }

        // Evaluate a rotation action
        function evaluateRotation(ring, clockwise) {
            // Save current state (including current pin counts)
            const savedPieces = JSON.parse(JSON.stringify(gameState.pieces));
            const savedPinningPaths = [...gameState.pinningPaths];
            const savedPinningMap = new Map(gameState.pinningMap);

            // Count enemy pins BEFORE rotation
            const currentPlayer = gameState.currentPlayer;
            let enemyPinsBefore = 0;
            gameState.pieces.forEach(piece => {
                if (piece.alive && piece.player !== currentPlayer && piece.pinned) {
                    enemyPinsBefore++;
                }
            });

            // Simulate rotation
            const piecesInRing = gameState.pieces.filter(p =>
                p.alive && getRing(p.q, p.r) === ring
            );

            piecesInRing.forEach(piece => {
                const rotated = rotateHexAroundCenter(piece.q, piece.r, clockwise ? 1 : -1);
                piece.q = rotated.q;
                piece.r = rotated.r;
            });

            updatePins();

            // Score the resulting position - ONLY count meaningful changes
            let score = 0;
            let enemyPinsAfter = 0;
            let friendlyPinsAfter = 0;

            gameState.pieces.forEach(piece => {
                if (!piece.alive) return;
                const value = piece.hp + gameState.unitConfigs[piece.type].ramDamage;

                if (piece.player === currentPlayer) {
                    if (piece.pinned) {
                        score -= value * 0.5; // Bad: we got pinned
                        friendlyPinsAfter++;
                    }
                } else {
                    if (piece.pinned) {
                        enemyPinsAfter++;
                        score += value * 2; // Good: enemy pinned

                        if (PIECE_TYPES[piece.type].isKing) {
                            score += 500; // Enemy King pinned is huge
                        }
                    }
                }
            });

            // Restore original state
            gameState.pieces = JSON.parse(JSON.stringify(savedPieces));
            gameState.pinningPaths = savedPinningPaths;
            gameState.pinningMap = savedPinningMap;
            updatePins();

            // Only return positive score if rotation CREATES new pins
            // or significantly improves position
            const newPinsCreated = enemyPinsAfter > enemyPinsBefore;
            const gotOurPiecesPinned = friendlyPinsAfter > 0;

            if (!newPinsCreated && !gotOurPiecesPinned) {
                // Rotation achieved nothing meaningful - don't recommend it
                return -Infinity;
            }

            return score;
        }

        // Find best rotation option (if King is available)
        function getBestRotation(kingIndex) {
            const king = gameState.pieces[kingIndex];
            if (!king || !king.alive || king.pinned || gameState.usedPieces.has(kingIndex)) {
                return { score: -Infinity, ring: null, clockwise: null };
            }

            let bestScore = -Infinity;
            let bestRing = null;
            let bestClockwise = null;

            // Evaluate all 5 rings Ã— 2 directions
            for (let ring = 1; ring <= 5; ring++) {
                for (const clockwise of [true, false]) {
                    const score = evaluateRotation(ring, clockwise);
                    if (score > bestScore) {
                        bestScore = score;
                        bestRing = ring;
                        bestClockwise = clockwise;
                    }
                }
            }

            return { score: bestScore, ring: bestRing, clockwise: bestClockwise };
        }

        // Simulate rotation and find the best second action score
        function evaluateRotationLookahead(kingIndex, ring, clockwise) {
            // Save current state
            const savedPieces = JSON.parse(JSON.stringify(gameState.pieces));
            const savedUsedPieces = new Set(gameState.usedPieces);
            const savedPinningPaths = [...gameState.pinningPaths];
            const savedPinningMap = new Map(gameState.pinningMap);

            // Simulate rotation
            const piecesInRing = gameState.pieces.filter(p =>
                p.alive && getRing(p.q, p.r) === ring
            );

            piecesInRing.forEach(piece => {
                const rotated = rotateHexAroundCenter(piece.q, piece.r, clockwise ? 1 : -1);
                piece.q = rotated.q;
                piece.r = rotated.r;
            });

            // Mark king as used
            gameState.usedPieces.add(kingIndex);

            // Update pins for simulated state
            updatePins();

            // Find best second move
            let bestSecondScore = -Infinity;
            gameState.pieces.forEach((p, idx) => {
                if (p.player === gameState.currentPlayer &&
                    p.alive &&
                    !p.pinned &&
                    !gameState.usedPieces.has(idx)) {
                    const result = getBestMoveForPiece(idx);
                    if (result.score > bestSecondScore) {
                        bestSecondScore = result.score;
                    }
                }
            });

            // Restore original state
            gameState.pieces = JSON.parse(JSON.stringify(savedPieces));
            gameState.usedPieces = savedUsedPieces;
            gameState.pinningPaths = savedPinningPaths;
            gameState.pinningMap = savedPinningMap;
            updatePins();

            return bestSecondScore === -Infinity ? 0 : bestSecondScore;
        }

        // Simulate a move and find the best second action score
        function evaluateLookahead(pieceIndex, path) {
            const piece = gameState.pieces[pieceIndex];
            const destination = path[path.length - 1];

            // Save current state
            const savedPieces = JSON.parse(JSON.stringify(gameState.pieces));
            const savedUsedPieces = new Set(gameState.usedPieces);
            const savedPinningPaths = [...gameState.pinningPaths];
            const savedPinningMap = new Map(gameState.pinningMap);

            // Simulate the move
            const damagePath = calculateDamagePath(piece, path);
            const occupant = getPieceAt(destination.q, destination.r);
            const config = gameState.unitConfigs[piece.type];

            // Apply damage along path
            damagePath.forEach(pos => {
                if (pos.q === destination.q && pos.r === destination.r) return;
                const target = getPieceAt(pos.q, pos.r);
                if (target && target.player !== piece.player) {
                    if (target.pinned || target.hp <= config.ramDamage) {
                        target.alive = false;
                    } else {
                        target.hp -= config.ramDamage;
                    }
                }
            });

            // Kill destination if enemy
            if (occupant && occupant.player !== piece.player) {
                occupant.alive = false;
            }

            // Move the piece
            piece.q = destination.q;
            piece.r = destination.r;

            // Mark piece as used
            gameState.usedPieces.add(pieceIndex);

            // Update pins for simulated state
            updatePins();

            // Find best second move
            let bestSecondScore = -Infinity;
            gameState.pieces.forEach((p, idx) => {
                if (p.player === gameState.currentPlayer &&
                    p.alive &&
                    !p.pinned &&
                    !gameState.usedPieces.has(idx)) {
                    const result = getBestMoveForPiece(idx);
                    if (result.score > bestSecondScore) {
                        bestSecondScore = result.score;
                    }
                }
            });

            // Restore original state
            gameState.pieces = JSON.parse(JSON.stringify(savedPieces));
            gameState.usedPieces = savedUsedPieces;
            gameState.pinningPaths = savedPinningPaths;
            gameState.pinningMap = savedPinningMap;
            updatePins();

            return bestSecondScore === -Infinity ? 0 : bestSecondScore;
        }

        function autoMove() {
            if (gameState.phase !== 'playing') return;

            // Cleanup any active UI modes to prevent state conflicts
            if (gameState.rotationMode) {
                exitRotationMode();
            }
            if (gameState.pathBuilding || gameState.selectedPiece !== null) {
                cancelPathBuilding(); // This also clears selectedPiece
                // Ensure double-check cleanup
                gameState.selectedPiece = null;
                gameState.validMoves = [];
                clearHighlights();
                renderPieces();
            }

            // Get all movable pieces for current player
            const movablePieces = [];
            let kingIndex = null;
            gameState.pieces.forEach((piece, index) => {
                if (piece.player === gameState.currentPlayer &&
                    piece.alive &&
                    !piece.pinned &&
                    !gameState.usedPieces.has(index)) {
                    movablePieces.push(index);
                    if (PIECE_TYPES[piece.type].isKing) {
                        kingIndex = index;
                    }
                }
            });

            if (movablePieces.length === 0) {
                addLog('No available moves!', 'system');
                return;
            }

            // Check if we have 2+ actions remaining for lookahead
            const canLookahead = gameState.actionsRemaining >= 2;

            // Find best movement option
            let bestMoveScore = -Infinity;
            let bestPieceIndex = null;
            let bestPath = null;

            for (const pieceIndex of movablePieces) {
                const result = getBestMoveForPiece(pieceIndex);
                if (!result.path) continue;

                let totalScore = result.score;

                // If we have 2+ actions, simulate this move and find best second move
                if (canLookahead && result.score !== Infinity) {
                    const lookaheadBonus = evaluateLookahead(pieceIndex, result.path);
                    totalScore += lookaheadBonus * 0.9;
                }

                if (totalScore > bestMoveScore) {
                    bestMoveScore = totalScore;
                    bestPieceIndex = pieceIndex;
                    bestPath = result.path;
                }
            }

            // Find best rotation option (if King is available)
            let bestRotation = { score: -Infinity, ring: null, clockwise: null };
            let rotationTotalScore = -Infinity;
            if (kingIndex !== null) {
                bestRotation = getBestRotation(kingIndex);

                if (bestRotation.ring !== null) {
                    rotationTotalScore = bestRotation.score;

                    // Apply lookahead for rotation too
                    if (canLookahead && bestRotation.score !== Infinity) {
                        const lookaheadBonus = evaluateRotationLookahead(kingIndex, bestRotation.ring, bestRotation.clockwise);
                        rotationTotalScore += lookaheadBonus * 0.9;
                    }
                }
            }

            // Decide: rotation or movement?
            const useRotation = rotationTotalScore > bestMoveScore && bestRotation.ring !== null;

            if (useRotation) {
                // Execute rotation
                addLog(`Auto-move: King rotates ring ${bestRotation.ring} ${bestRotation.clockwise ? 'CW' : 'CCW'}`, gameState.currentPlayer);
                executeRotation(bestRotation.ring, bestRotation.clockwise);
                useAction(kingIndex);
                updateArmyDisplay();
                clearHighlights();
                renderPieces();
            } else if (bestPieceIndex !== null && bestPath && bestPath.length > 0) {
                // Execute movement
                const piece = gameState.pieces[bestPieceIndex];
                const destination = bestPath[bestPath.length - 1];
                const damagePath = calculateDamagePath(piece, bestPath);
                const occupant = getPieceAt(destination.q, destination.r);

                const move = {
                    q: destination.q,
                    r: destination.r,
                    damagePath: damagePath,
                    willKill: occupant && occupant.player !== piece.player,
                    path: bestPath
                };

                addLog(`Auto-move: ${PIECE_TYPES[piece.type].name} to (${destination.q}, ${destination.r})`, gameState.currentPlayer);

                const moveSucceeded = executeMove(bestPieceIndex, destination.q, destination.r, move);

                if (moveSucceeded) {
                    useAction(bestPieceIndex);
                    updateArmyDisplay();
                    clearHighlights();
                    renderPieces();
                }
            } else {
                addLog('Could not find a good move!', 'system');
            }
        }

        function updateAutoMoveVisibility() {
            const btn = document.getElementById('btn-auto-move');
            if (!btn) return;

            const isCpuTurn = gameState.gameMode === 'vsCPU' && gameState.currentPlayer === gameState.cpuPlayer;

            const shouldShow = gameState.phase === 'playing' && !isCpuTurn;

            btn.style.display = shouldShow ? 'inline-block' : 'none';
        }

        // ============================================
        // KEYBOARD SHORTCUTS
        // ============================================

        function setupKeyboard() {
            document.addEventListener('keydown', (e) => {
                if (gameState.phase !== 'playing') return;

                // R for rotation mode
                if (e.key === 'r' || e.key === 'R') {
                    if (gameState.selectedPiece !== null) {
                        const piece = gameState.pieces[gameState.selectedPiece];
                        if (PIECE_TYPES[piece.type].isKing && piece.player === gameState.currentPlayer) {
                            enterRotationMode(gameState.selectedPiece);
                        }
                    }
                }

                // Escape to cancel
                if (e.key === 'Escape') {
                    if (gameState.rotationMode) {
                        exitRotationMode();
                    } else if (gameState.pathBuilding) {
                        cancelPathBuilding();
                    } else {
                        gameState.selectedPiece = null;
                        gameState.validMoves = [];
                        clearHighlights();
                        renderPieces();
                    }
                }

                // Number keys for ring selection in rotation mode
                if (gameState.rotationMode && e.key >= '1' && e.key <= '5') {
                    const ring = parseInt(e.key);
                    gameState.selectedRing = ring;
                    document.getElementById('rotation-ring').textContent = ring;
                    document.querySelectorAll('.ring-highlight').forEach(el => el.classList.remove('active'));
                    document.getElementById(`ring-${ring}`).classList.add('active');
                }
            });
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        function init() {
            initUnitConfigs();
            createBoard();
            setupUnitEditor();
            setupParams();
            setupRotationControls();
            setupKeyboard();
            setupFixedPositions();
            updateArmyDisplay();
            updateUI();
            // startGame(); // Removed auto-start

            document.getElementById('btn-reset').addEventListener('click', resetGame);
            document.getElementById('btn-reset-turn').addEventListener('click', resetTurn);
            document.getElementById('btn-end-turn').addEventListener('click', endTurn);
            document.getElementById('btn-new-game').addEventListener('click', resetGame);
            document.getElementById('btn-confirm-path').addEventListener('click', confirmPathMove);
            document.getElementById('btn-cancel-path').addEventListener('click', cancelPathBuilding);
            document.getElementById('btn-rotate').addEventListener('click', () => {
                if (gameState.selectedPiece !== null) {
                    const piece = gameState.pieces[gameState.selectedPiece];
                    if (PIECE_TYPES[piece.type].isKing && piece.player === gameState.currentPlayer && !piece.pinned) {
                        enterRotationMode(gameState.selectedPiece);
                        document.getElementById('btn-rotate').style.display = 'none';
                    } else if (piece.pinned) {
                        addLog('Pinned pieces cannot move or take actions!', 'system');
                    }
                }
            });

            document.getElementById('btn-auto-move').addEventListener('click', autoMove);
            updateAutoMoveVisibility();

            // Mode selection listeners
            document.getElementById('btn-mode-2p').addEventListener('click', () => startGame('2player'));
            document.getElementById('btn-mode-cpu').addEventListener('click', () => startGame('vsCPU'));
        }

        // Start
        init();
    </script>
</body>

</html>
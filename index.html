<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Throne â€” Tactical Hex Duel</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0a0a0c;
            --bg-panel: #111114;
            --bg-hex: #16161a;
            --bg-hex-hover: #1e1e24;
            --border: #2a2a32;
            --text-primary: #e8e6e3;
            --text-muted: #6b6b76;
            --accent-gold: #d4af37;
            --accent-gold-dim: #a68a2a;
            --player1: #c94c4c;
            --player1-dim: #8a3535;
            --player2: #4c8bc9;
            --player2-dim: #35628a;
            --player-cpu: #a855f7;
            --player-cpu-dim: #7c3aed;
            --throne: #d4af37;
            --pin-indicator: #fbbf24;
            /* Bright amber/yellow for pinned pieces */
            --valid-move: rgba(100, 200, 100, 0.3);
            --damage-path: rgba(255, 165, 0, 0.5);
            --path-highlight: rgba(100, 150, 255, 0.4);
            --path-end-highlight: rgba(100, 150, 255, 0.6);
            --shoot-path: rgba(255, 50, 50, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            height: 100vh;
            overflow-x: hidden;
            overflow-y: hidden;
        }

        .game-container {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            min-height: 100vh;
            height: 100vh;
            max-height: 100vh;
            gap: 0;
            overflow: hidden;
        }

        /* Left Panel - Game State */
        .panel {
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }

        .panel-right {
            border-right: none;
            border-left: 1px solid var(--border);
            overflow-y: auto;
            max-height: 100vh;
        }

        .panel-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-muted);
            margin-bottom: 12px;
            font-family: 'JetBrains Mono', monospace;
        }

        .logo {
            font-size: 28px;
            font-weight: 700;
            letter-spacing: 4px;
            text-align: center;
            color: var(--accent-gold);
            padding: 16px 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 8px;
        }

        .turn-indicator {
            text-align: center;
            padding: 20px;
            background: var(--bg-hex);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .timer-display {
            font-family: 'Courier New', monospace;
            font-size: 24px;
            font-weight: bold;
            color: var(--accent-gold);
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
            margin: 4px 0;
            letter-spacing: 1px;
        }

        .timer-toggle {
            margin-top: 6px;
            padding: 6px 10px;
            font-size: 12px;
            min-width: 80px;
        }

        .turn-indicator .player-name {
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .turn-indicator.player1 .player-name {
            color: var(--player1);
        }

        .turn-indicator.player2 .player-name {
            color: var(--player2);
        }

        .actions-remaining {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            color: var(--text-muted);
        }

        .actions-remaining span {
            color: var(--accent-gold);
            font-weight: 500;
        }



        .army-display {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid var(--border);
        }

        .army-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .army-title.player1 {
            color: var(--player1);
        }

        .army-title.player2 {
            color: var(--player2);
        }

        .army-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .army-piece {
            width: 36px;
            height: 36px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.15s;
            border: 2px solid transparent;
        }

        .army-piece:hover {
            transform: scale(1.1);
        }

        .army-piece.player1 {
            background: var(--player1-dim);
        }

        .army-piece.player2 {
            background: var(--player2-dim);
        }

        .army-piece.dead {
            opacity: 0.3;
            pointer-events: none;
        }

        .army-piece.pinned {
            border: 3px solid var(--pin-indicator);
            box-shadow: 0 0 8px var(--pin-indicator);
            background: repeating-linear-gradient(45deg,
                    transparent,
                    transparent 3px,
                    rgba(251, 191, 36, 0.15) 3px,
                    rgba(251, 191, 36, 0.15) 6px);
        }

        /* Board Area */
        .board-area {
            display: flex;
            align-items: center;
            justify-content: center;
            background:
                radial-gradient(ellipse at center, rgba(212, 175, 55, 0.03) 0%, transparent 60%),
                var(--bg-dark);
            position: relative;
        }

        #game-board {
            cursor: default;
        }

        .hex {
            fill: var(--bg-hex);
            stroke: var(--border);
            stroke-width: 1.1;
            transition: all 0.2s;
            cursor: pointer;
        }

        /* Ring colors - distinct variations to help identify pins */
        .hex.ring-0 {
            fill: rgba(212, 175, 55, 0.3);
            /* Throne ring - gold tint */
        }

        .hex.ring-1 {
            fill: #0a0a0e;
            stroke: #ff2e2e;
            stroke-opacity: 0.2;
        }

        .hex.ring-2 {
            fill: #0e0e14;
            stroke: #22c55e;
            stroke-opacity: 0.2;
        }

        .hex.ring-3 {
            fill: #121218;
            stroke: #3b82f6;
            stroke-opacity: 0.2;
        }

        .hex.ring-4 {
            fill: #16161c;
            stroke: #f59e0b;
            stroke-opacity: 0.2;
        }

        .hex.ring-5 {
            fill: #1a1a20;
            stroke: #df24ff;
            stroke-opacity: 0.2;
        }

        .hex:hover {
            fill: var(--bg-hex-hover);
        }

        .hex.throne {
            fill: rgba(212, 175, 55, 0.15);
            stroke: var(--accent-gold);
            stroke-width: 2;
        }

        .hex.force-field {
            fill: rgba(147, 51, 234, 0.05);
            stroke: #d8b4fe;
            stroke-width: 3px;
            filter: drop-shadow(0 0 5px rgba(168, 85, 247, 0.8));
            animation: forceFieldPulse 2s infinite;
        }

        @keyframes forceFieldPulse {
            0% {
                stroke: #d8b4fe;
                stroke-width: 3px;
            }

            50% {
                stroke: #e9d5ff;
                stroke-width: 5px;
            }

            100% {
                stroke: #d8b4fe;
                stroke-width: 3px;
            }
        }



        .hex.valid-move {
            fill: var(--valid-move);
        }

        .hex.damage-path {
            fill: var(--damage-path);
        }

        .hex.selected {
            stroke: var(--accent-gold);
            stroke-width: 3;
        }

        .hex.path-step {
            fill: var(--path-highlight);
            stroke: var(--path-highlight);
            stroke-width: 2;
        }

        .hex.path-end {
            fill: var(--path-end-highlight);
            stroke: var(--path-end-highlight);
            stroke-width: 3;
        }

        /* Keep throne's yellow outline visible even when part of a path */
        .hex.throne.path-step,
        .hex.throne.path-end {
            stroke: var(--accent-gold);
            stroke-width: 3;
        }

        .hex.shoot-path {
            fill: var(--shoot-path);
            stroke: var(--shoot-path);
        }



        .piece {
            cursor: pointer;
        }

        .piece.selected {
            filter: drop-shadow(0 0 8px var(--accent-gold));
        }

        .piece.used {
            opacity: 0.5;
            filter: grayscale(0.7);
        }

        .piece-stat {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-anchor: middle;
            pointer-events: none;
            font-weight: bold;
            filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.8));
        }

        .piece-stat.hp {
            fill: #df24ff;
            letter-spacing: 1px;
        }

        .piece-stat.dmg {
            fill: #e8c34a;
        }

        .piece-stat.rng {
            fill: #22c55e;
            letter-spacing: 1px;
        }

        .bomb-indicator {
            pointer-events: none;
        }

        .bomb-indicator.p1 {
            fill: #f97316;
            filter: drop-shadow(0 0 4px #f97316);
            animation: blink-p1 1.2s infinite ease-in-out;
        }

        .bomb-indicator.p2 {
            fill: #06b6d4;
            filter: drop-shadow(0 0 4px #06b6d4);
            animation: blink-p2 1.2s infinite ease-in-out;
        }

        @keyframes blink-p1 {

            0%,
            100% {
                opacity: 1;
                filter: drop-shadow(0 0 2px #f97316);
            }

            50% {
                opacity: 0.6;
                filter: drop-shadow(0 0 8px #f97316);
            }
        }

        @keyframes blink-p2 {

            0%,
            100% {
                opacity: 1;
                filter: drop-shadow(0 0 2px #06b6d4);
            }

            50% {
                opacity: 0.6;
                filter: drop-shadow(0 0 8px #06b6d4);
            }
        }

        @keyframes explosion-p1 {
            0% {
                transform: scale(0.2);
                opacity: 1;
                fill: #fbbf24;
            }

            100% {
                transform: scale(3.5);
                opacity: 0;
                fill: #ef4444;
            }
        }

        @keyframes explosion-p2 {
            0% {
                transform: scale(0.2);
                opacity: 1;
                fill: #22d3ee;
            }

            100% {
                transform: scale(3.5);
                opacity: 0;
                fill: #0891b2;
            }
        }

        .explosion-ring {
            pointer-events: none;
            stroke-width: 1;
            stroke: white;
            r: 30;
            /* Base radius for scaling */
        }

        .explosion-ring.p1 {
            animation: explosion-p1 0.6s ease-out forwards;
        }

        .explosion-ring.p2 {
            animation: explosion-p2 0.6s ease-out forwards;
        }

        .ring-highlight {
            fill: none;
            stroke: var(--accent-gold);
            stroke-width: 2;
            stroke-dasharray: 5 5;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .ring-highlight.active {
            opacity: 0.6;
        }

        /* Controls */
        .action-controls {
            position: absolute;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 100;
        }

        .game-controls {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 10px 20px;
            border: 1px solid var(--border);
            background: var(--bg-panel);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover {
            background: var(--bg-hex);
            border-color: var(--accent-gold-dim);
        }

        .btn.primary {
            background: var(--accent-gold-dim);
            color: var(--bg-dark);
            border-color: var(--accent-gold);
        }

        @media (max-height: 850px) {
            .game-controls {
                bottom: 8px;
                gap: 8px;
            }

            .btn {
                padding: 8px 16px;
                font-size: 11px;
            }
        }

        .btn.primary:hover {
            background: var(--accent-gold);
        }

        .btn.rotate {
            background: var(--accent-gold);
            color: var(--bg-dark);
            border-color: var(--accent-gold);
            font-weight: 500;
        }

        .btn.rotate:hover {
            background: #e8c34a;
        }

        .btn.alt-move {
            background: #2563eb;
            color: white;
            border-color: #1d4ed8;
            font-weight: 500;
        }

        .btn.alt-move:hover {
            background: #1d4ed8;
        }

        .btn.auto-move {
            background: #a855f7;
            color: white;
            border-color: #9333ea;
            font-weight: 500;
        }

        .btn.auto-move:hover {
            background: #9333ea;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Right Panel - Parameters */
        .param-section {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid var(--border);
        }

        .param-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
        }

        .param-row:last-child {
            border-bottom: none;
        }

        .param-label {
            font-size: 13px;
            color: var(--text-muted);
        }

        .param-input {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            width: 60px;
            padding: 6px 8px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-primary);
            border-radius: 4px;
            text-align: center;
        }

        .param-input:focus {
            outline: none;
            border-color: var(--accent-gold-dim);
        }

        .param-input:disabled {
            background: var(--bg-hex);
            color: var(--text-muted);
            opacity: 0.5;
            cursor: not-allowed;
        }

        select.param-input {
            width: 100px;
        }

        /* Unit Editor */
        .unit-editor {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid var(--border);
        }

        .unit-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }

        .unit-btn {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            border: 2px solid var(--border);
            background: var(--bg-dark);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 18px;
            transition: all 0.15s;
        }

        .unit-btn:hover,
        .unit-btn.active {
            border-color: var(--accent-gold);
        }

        .unit-btn.player1 {
            background: var(--player1-dim);
        }

        .unit-btn.player2 {
            background: var(--player2-dim);
        }

        .template-selector {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 12px 0;
        }

        .template-btn {
            padding: 12px;
            border: 2px solid var(--border);
            background: var(--bg-dark);
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-primary);
            text-align: center;
            transition: all 0.15s;
        }

        .template-btn:hover {
            border-color: var(--accent-gold-dim);
            background: var(--bg-hex);
        }

        .template-btn.active {
            background: var(--accent-gold-dim);
            border-color: var(--accent-gold);
            color: var(--bg-dark);
        }

        /* Victory Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: var(--bg-panel);
            border: 1px solid var(--accent-gold);
            border-radius: 12px;
            padding: 48px;
            text-align: center;
            max-width: 400px;
        }

        .modal h2 {
            font-size: 32px;
            margin-bottom: 16px;
            color: var(--accent-gold);
        }

        .modal p {
            font-size: 18px;
            color: var(--text-muted);
            margin-bottom: 32px;
        }

        /* Placement Mode */
        .placement-palette {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid var(--border);
        }

        .placement-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .placement-piece {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
            position: relative;
        }

        .placement-piece:hover {
            transform: scale(1.05);
        }

        .placement-piece.selected {
            border-color: var(--accent-gold);
            box-shadow: 0 0 12px rgba(212, 175, 55, 0.4);
        }

        .placement-piece.placed {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .placement-piece .count {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: 10px;
            background: var(--bg-dark);
            padding: 1px 4px;
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
        }

        /* Log */
        .game-log {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid var(--border);
            max-height: 200px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }

        .log-entry {
            padding: 4px 0;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry.player1 {
            color: var(--player1);
        }

        .log-entry.player2 {
            color: var(--player2);
        }

        .log-entry.system {
            color: var(--accent-gold);
        }

        /* Rotation UI */
        .rotation-controls {
            position: absolute;
            display: flex;
            gap: 8px;
            background: var(--bg-panel);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--accent-gold);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .rotation-controls button {
            width: 36px;
            height: 36px;
            border-radius: 4px;
            border: 1px solid var(--border);
            background: var(--bg-hex);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 16px;
        }

        .rotation-controls button:hover {
            background: var(--accent-gold-dim);
            color: var(--bg-dark);
        }
    </style>
</head>

<body>
    <div class="game-container">
        <!-- Left Panel -->
        <div class="panel">
            <div class="logo">THRONE</div>

            <div class="turn-indicator player1" id="turn-indicator">
                <div class="player-name">Player 1</div>
                <div class="timer-display" id="active-timer">05:00</div>
                <button class="btn timer-toggle" id="btn-timer-toggle">Pause</button>
                <div class="actions-remaining">Actions: <span id="actions-count">2</span>/2</div>
            </div>

            <div class="placement-palette" id="placement-panel" style="display: none; margin-top: 12px;">
                <div style="font-weight: 600; margin-bottom: 8px;">Placement Phase</div>

                <div class="placement-pieces" id="placement-pieces"></div>
            </div>


            <div class="army-display">
                <div class="army-title player1">â¬¢ Player 1 Army</div>
                <div class="army-pieces" id="army-p1"></div>
            </div>

            <div class="army-display">
                <div class="army-title player2">â¬¢ Player 2 Army</div>
                <div class="army-pieces" id="army-p2"></div>
            </div>

            <div class="game-log" id="game-log">
                <div class="log-entry system">Game initialized.</div>
            </div>
        </div>

        <!-- Board Area -->
        <div class="board-area">
            <svg id="game-board" width="700" height="700"></svg>
            <div class="action-controls" id="action-controls">
                <button class="btn auto-move" id="btn-auto-move">âœ¨ Auto-Move</button>
                <button class="btn rotate" id="btn-rotate" style="display: none;">â†» Rotate Ring</button>
                <button class="btn primary" id="btn-confirm-path" style="display: none;">Confirm Move</button>
            </div>

            <div class="game-controls">
                <button class="btn" id="btn-reset">Reset Game</button>
                <button class="btn" id="btn-reset-turn" disabled>Reset Turn</button>
                <button class="btn" id="btn-cancel-path" style="display: none;">Cancel</button>
                <button class="btn" id="btn-end-turn">End Turn</button>
            </div>
            <div class="rotation-controls" id="rotation-controls" style="display: none;">
                <button id="rotate-ccw">â†º</button>
                <span style="display: flex; align-items: center; font-size: 12px; color: var(--text-muted);">Ring <span
                        id="rotation-ring">1</span></span>
                <button id="rotate-cw">â†»</button>
                <button id="rotate-cancel" style="margin-left: 8px; font-size: 12px;">âœ•</button>
            </div>
        </div>

        <!-- Right Panel - Parameters -->
        <div class="panel panel-right">


            <div class="panel-title" style="margin-top: 16px;">Unit Editor</div>
            <div class="unit-editor">
                <div class="unit-selector" id="unit-selector"></div>
                <div id="unit-details" style="display: none;">
                    <div class="param-row">
                        <span class="param-label">Max HP</span>
                        <input type="number" class="param-input" id="unit-hp" value="3" min="1" max="10">
                    </div>
                    <div class="param-row">
                        <span class="param-label">Ram Damage</span>
                        <input type="number" class="param-input" id="unit-ram-damage" value="1" min="1" max="5">
                    </div>
                    <div class="param-row">
                        <span class="param-label">Move Range</span>
                        <input type="number" class="param-input" id="unit-range" value="3" min="1" max="6">
                    </div>
                    <div class="panel-title" style="margin-top: 12px; margin-bottom: 8px;">Movement Template</div>
                    <div class="template-selector" id="template-selector"></div>
                </div>
            </div>

            <div class="panel-title" style="margin-top: 16px;">Instructions</div>
            <div class="param-section" style="font-size: 13px; color: var(--text-muted); line-height: 1.6;">
                <p><strong>Movement:</strong> Click a piece to start path building. Click adjacent hexes to build your
                    path step-by-step. Click the last hex again or "Confirm Move" to execute. Press Escape or "Cancel"
                    to abort.</p>
                <p style="margin-top: 8px;"><strong>Rotation:</strong> Select your King, then tap "â†» Rotate Ring"
                    button. Select a ring number, then tap â†º or â†» to rotate.</p>
                <p style="margin-top: 8px;"><strong>Victory:</strong> Capture the Throne, eliminate all enemy units, or
                    pin + ram the enemy King.</p>
            </div>
        </div>
    </div>

    <!-- Victory Modal -->
    <div class="modal-overlay" id="victory-modal">
        <div class="modal">
            <h2 id="victory-title">Victory!</h2>
            <p id="victory-message">Player 1 wins by capturing the Throne!</p>
            <button class="btn primary" id="btn-new-game">New Game</button>
        </div>
    </div>

    <!-- Game Mode Selection Modal -->
    <div class="modal-overlay active" id="mode-selection-modal">
        <div class="modal">
            <h2>Ready to Play?</h2>
            <div style="display: flex; gap: 16px; justify-content: center; margin-bottom: 24px;">
                <div style="text-align: left;">
                    <label style="display: block; margin-bottom: 8px; color: var(--text-primary); cursor: pointer;">
                        <input type="checkbox" id="timer-enabled" checked> Enable Timer
                    </label>
                    <div id="timer-config">
                        <div style="margin-bottom: 8px;">
                            <label style="color: var(--text-muted); font-size: 14px;">Seconds per Round:</label>
                            <input type="number" id="timer-round-seconds" value="60" min="5" max="300"
                                style="width: 70px; padding: 4px; background: var(--bg-dark); color: var(--text-primary); border: 1px solid var(--border); border-radius: 4px;">
                        </div>
                        <div>
                            <label style="color: var(--text-muted); font-size: 14px;">Reserve Minutes per Game:</label>
                            <input type="number" id="timer-reserve-minutes" value="15" min="1" max="60"
                                style="width: 70px; padding: 4px; background: var(--bg-dark); color: var(--text-primary); border: 1px solid var(--border); border-radius: 4px;">
                        </div>
                    </div>
                </div>
            </div>
            <div style="display: flex; gap: 16px; justify-content: center;">
                <button class="btn primary" id="btn-start-game" style="padding: 16px 24px;">Start Game</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // THRONE - Tactical Hex Duel Prototype
        // ============================================

        const HEX_SIZE = 38;
        const BOARD_RADIUS = 5;
        const CENTER_X = 350;
        const CENTER_Y = 350;

        // Hex directions (pointy-top)
        const HEX_DIRECTIONS = [
            { q: 1, r: 0 },   // E
            { q: 1, r: -1 },  // NE
            { q: 0, r: -1 },  // NW
            { q: -1, r: 0 },  // W
            { q: -1, r: 1 },  // SW
            { q: 0, r: 1 },   // SE
        ];

        const PIECE_TYPES = {
            KING: { symbol: 'â™š', name: 'King', defaultHP: Infinity, isKing: true },
            PAWN: { symbol: 'â™Ÿ', name: 'Pawn', defaultHP: 2, isKing: false },
            SNAKE: { symbol: 'ðŸ', name: 'Snake', defaultHP: 4, isKing: false },
            SHIELD: { symbol: 'ðŸ›¡ï¸', name: 'Shield', defaultHP: 6, isKing: false },
            BOMBER: { symbol: 'ðŸ’£', name: 'Bomber', defaultHP: 4, isKing: false },
            ARCHER: { symbol: 'â˜¾', name: 'Archer', defaultHP: 4, isKing: false },
            BOXER: { symbol: 'ðŸ¥Š', name: 'Boxer', defaultHP: 2, isKing: false },
            GHOST: { symbol: 'ðŸ‘»', name: 'Soul Echo', defaultHP: 1, isKing: false, isGhost: true },
        };

        // Boxer icon (Muay Thai wrapped fist) source image (black lines on white background)
        const BOXER_ICON_SRC = './boxer_icon.png';
        const BOXER_ICON_W = 900;
        const BOXER_ICON_H = 900;

        function createBoxerIconSvg(size, color) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', size);
            svg.setAttribute('height', size);
            svg.setAttribute('viewBox', `0 0 ${BOXER_ICON_W} ${BOXER_ICON_H}`);

            const uid = Math.random().toString(36).slice(2);
            const filterId = `boxer-invert-${uid}`;
            const maskId = `boxer-mask-${uid}`;

            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

            // Invert the source image so black linework becomes white (opaque in mask),
            // while the white background becomes black (transparent in mask).
            const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
            filter.setAttribute('id', filterId);
            const matrix = document.createElementNS('http://www.w3.org/2000/svg', 'feColorMatrix');
            matrix.setAttribute('type', 'matrix');
            matrix.setAttribute('values', '-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0');
            filter.appendChild(matrix);

            // Boost contrast after inversion so near-black becomes fully transparent in mask
            // (prevents light/gray "background" pixels from showing as a tinted box).
            const ct = document.createElementNS('http://www.w3.org/2000/svg', 'feComponentTransfer');
            const fns = ['feFuncR', 'feFuncG', 'feFuncB', 'feFuncA'];
            fns.forEach(name => {
                const fn = document.createElementNS('http://www.w3.org/2000/svg', name);
                fn.setAttribute('type', 'linear');
                fn.setAttribute('slope', '6');
                fn.setAttribute('intercept', '-2.5');
                ct.appendChild(fn);
            });
            filter.appendChild(ct);
            defs.appendChild(filter);

            const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
            mask.setAttribute('id', maskId);
            mask.setAttribute('maskUnits', 'userSpaceOnUse');
            mask.setAttribute('x', '0');
            mask.setAttribute('y', '0');
            mask.setAttribute('width', String(BOXER_ICON_W));
            mask.setAttribute('height', String(BOXER_ICON_H));

            const maskImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
            maskImage.setAttribute('href', BOXER_ICON_SRC);
            maskImage.setAttribute('x', '0');
            maskImage.setAttribute('y', '0');
            maskImage.setAttribute('width', String(BOXER_ICON_W));
            maskImage.setAttribute('height', String(BOXER_ICON_H));
            maskImage.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            maskImage.setAttribute('filter', `url(#${filterId})`);
            mask.appendChild(maskImage);
            defs.appendChild(mask);
            svg.appendChild(defs);

            // Fill a rect with the desired color, masked by the linework.
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', '0');
            rect.setAttribute('y', '0');
            rect.setAttribute('width', String(BOXER_ICON_W));
            rect.setAttribute('height', String(BOXER_ICON_H));
            rect.setAttribute('fill', color);
            rect.setAttribute('mask', `url(#${maskId})`);
            svg.appendChild(rect);

            return svg;
        }

        // Game state
        let gameState = {
            phase: 'setup', // setup, playing, ended
            gameMode: '2player', // '2player' or 'vsCPU'
            cpuPlayer: 2, // Which player is CPU (only used in vsCPU mode)
            currentPlayer: 1,
            actionsRemaining: 2,
            actionsPerTurn: 2,
            isFirstTurn: true,
            usedPieces: new Set(),
            hasAnyPieceMoved: false,
            pieces: [],
            pinningPaths: [], // Store paths that create pins for visualization
            pinningMap: new Map(), // Map: enemy piece index -> Set of ally piece indices that are pinning it
            previewPinningPaths: [], // Store preview pinning paths when building a move
            selectedPiece: null,
            validMoves: [],
            rotationMode: false,
            selectedRing: null,
            pathBuilding: false,
            currentPath: [],
            pathStartPiece: null,
            placementSelectedType: null,
            placementSlots: { 1: [], 2: [] },
            placementRemaining: { 1: [], 2: [] },
            placementPlacedCount: { 1: 0, 2: 0 },
            boxerSlideMode: false,
            boxerSlideSource: null,
            params: {
                actionsPerTurn: 2
            },
            unitConfigs: {},
            turnSnapshot: null,
            lanceTargetingMode: false,
            lanceTargetingRays: [],
            forceFields: [], // {q, r, player} - Shields create these
            turnHistory: new Map(),

            // Timer State
            timerEnabled: false,
            timerPaused: false,
            roundTimeLimit: 0, // ms per round
            roundTimeRemaining: { 1: 0, 2: 0 },
            reserveTimeRemaining: { 1: 0, 2: 0 }, // ms per game
            lastTimestamp: 0,
            timerInterval: null,

            // Bomb State
            bombs: [], // { id, owner: pieceIndex, type: 'cell'|'unit', q, r, targetUnitIndex }
            pendingBombDetonations: [], // Bombs queued for detonation after move completes
            bombTargetingMode: false,

            // Ghost State
            ghosts: [], // { owner: pieceIndex, q, r, player }
        };

        // Movement templates
        const MOVEMENT_TEMPLATES = {
            FREE_MOTION: 'free_motion',
            STRAIGHT_LINE: 'straight_line',
            DIRECT_JUMP: 'direct_jump'
        };

        // Initialize unit configs with default movement patterns
        function initUnitConfigs() {
            // King: free motion, range 1
            gameState.unitConfigs['KING'] = {
                range: 1,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: Infinity,
                ramDamage: 2
            };
            // Pawn: free motion, range 2
            gameState.unitConfigs['PAWN'] = {
                range: 2,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: 2,
                ramDamage: 1
            };
            // Snake: free motion, range 3
            gameState.unitConfigs['SNAKE'] = {
                range: 3,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: 4,
                ramDamage: 2
            };
            // Shield: free motion
            gameState.unitConfigs['SHIELD'] = {
                range: 2,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: 6,
                ramDamage: 3
            };
            // Bomber: direct jump
            gameState.unitConfigs['BOMBER'] = {
                range: 3,
                template: MOVEMENT_TEMPLATES.DIRECT_JUMP,
                hp: 4,
                ramDamage: 2
            };
            // Archer: free motion
            gameState.unitConfigs['ARCHER'] = {
                range: 1,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: 4,
                ramDamage: 2
            };
            // Boxer: straight line
            gameState.unitConfigs['BOXER'] = {
                range: 5,
                template: MOVEMENT_TEMPLATES.STRAIGHT_LINE,
                hp: 3,
                ramDamage: 2
            };
            // Ghost: cannot move, just a static piece
            gameState.unitConfigs['GHOST'] = {
                range: 0,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: 1,
                ramDamage: 0
            };
        }

        // ============================================
        // HEX MATH
        // ============================================

        function hexKey(q, r) {
            return `${q},${r}`;
        }

        function hexToPixel(q, r) {
            const x = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r) + CENTER_X;
            const y = HEX_SIZE * (3 / 2 * r) + CENTER_Y;
            return { x, y };
        }

        function pixelToHex(x, y) {
            const px = x - CENTER_X;
            const py = y - CENTER_Y;
            const q = (Math.sqrt(3) / 3 * px - 1 / 3 * py) / HEX_SIZE;
            const r = (2 / 3 * py) / HEX_SIZE;
            return hexRound(q, r);
        }

        function hexRound(q, r) {
            const s = -q - r;
            let rq = Math.round(q);
            let rr = Math.round(r);
            let rs = Math.round(s);

            const qDiff = Math.abs(rq - q);
            const rDiff = Math.abs(rr - r);
            const sDiff = Math.abs(rs - s);

            if (qDiff > rDiff && qDiff > sDiff) {
                rq = -rr - rs;
            } else if (rDiff > sDiff) {
                rr = -rq - rs;
            }

            return { q: rq, r: rr };
        }

        function hexDistance(q1, r1, q2, r2) {
            return (Math.abs(q1 - q2) + Math.abs(q1 + r1 - q2 - r2) + Math.abs(r1 - r2)) / 2;
        }

        function getRing(q, r) {
            return hexDistance(0, 0, q, r);
        }

        function isValidHex(q, r) {
            return getRing(q, r) <= BOARD_RADIUS;
        }

        function getHexCorners(cx, cy, size) {
            const corners = [];
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 180 * (60 * i - 30);
                corners.push({
                    x: cx + size * Math.cos(angle),
                    y: cy + size * Math.sin(angle)
                });
            }
            return corners;
        }

        function hexNeighbor(q, r, direction) {
            const d = HEX_DIRECTIONS[direction];
            return { q: q + d.q, r: r + d.r };
        }

        function getHexesInRing(ring) {
            if (ring === 0) return [{ q: 0, r: 0 }];

            const hexes = [];
            let hex = { q: ring, r: 0 }; // Start at E

            for (let dir = 2; dir < 8; dir++) {
                const actualDir = dir % 6;
                for (let i = 0; i < ring; i++) {
                    hexes.push({ ...hex });
                    hex = hexNeighbor(hex.q, hex.r, actualDir);
                }
            }

            return hexes;
        }

        function rotateHexAroundCenter(q, r, steps) {
            // Rotate a hex position around center by steps * 60 degrees
            // Using cube coordinates for rotation
            const s = -q - r;
            let newQ = q, newR = r, newS = s;

            const absSteps = Math.abs(steps);
            const direction = steps > 0 ? 1 : -1;

            for (let i = 0; i < absSteps; i++) {
                if (direction > 0) {
                    // Clockwise
                    [newQ, newR, newS] = [-newR, -newS, -newQ];
                } else {
                    // Counter-clockwise
                    [newQ, newR, newS] = [-newS, -newQ, -newR];
                }
            }

            return { q: newQ, r: newR };
        }

        // ============================================
        // FIXED STARTING POSITIONS
        // ============================================

        function setupFixedPositions(isPlacementPhase = false) {
            gameState.pieces = [];

            // Pick a random corner for player 1 (6 possible corners on ring 5)
            const corners = [
                { q: 5, r: 0 },   // E
                { q: 0, r: -5 }, // NW
                { q: -5, r: 5 }, // W
                { q: -5, r: 0 }, // W (different)
                { q: 0, r: 5 },  // SE
                { q: 5, r: -5 }  // NE
            ];
            const p1Corner = corners[Math.floor(Math.random() * corners.length)];

            // Player 2 gets opposite corner (rotate 180 degrees)
            const p2Corner = rotateHexAroundCenter(p1Corner.q, p1Corner.r, 3);

            // Place Player 1 pieces
            placeArmy(1, p1Corner, isPlacementPhase);

            // Place Player 2 pieces
            placeArmy(2, p2Corner, isPlacementPhase);

            // Update pins after placement
            updatePins();
        }

        function placeArmy(player, kingCorner, isPlacementPhase = false) {
            // 1. King at ring 5 corner
            createPiece('KING', player, kingCorner.q, kingCorner.r);

            // 2. Find all Ring 4 candidates within distance 2 of King
            const r4Candidates = [];
            const allR4 = getHexesInRing(4);
            for (const hex of allR4) {
                if (hexDistance(kingCorner.q, kingCorner.r, hex.q, hex.r) <= 2) {
                    r4Candidates.push(hex);
                }
            }

            // 3. Sort candidates by their "transverse" position relative to the King -> Center axis
            const vQ = -kingCorner.q;
            const vR = -kingCorner.r;

            r4Candidates.sort((a, b) => {
                const aQ = a.q - kingCorner.q;
                const aR = a.r - kingCorner.r;
                const crossA = vQ * aR - vR * aQ;
                const bQ = b.q - kingCorner.q;
                const bR = b.r - kingCorner.r;
                const crossB = vQ * bR - vR * bQ;
                return crossA - crossB;
            });

            if (isPlacementPhase) {
                // Store placement slots for Snake/Shield/Bomber on ring 4
                gameState.placementSlots[player] = r4Candidates.slice(0, 3);
            } else {
                if (r4Candidates.length >= 3) {
                    createPiece('SNAKE', player, r4Candidates[0].q, r4Candidates[0].r);
                    createPiece('SHIELD', player, r4Candidates[1].q, r4Candidates[1].r);
                    createPiece('BOMBER', player, r4Candidates[2].q, r4Candidates[2].r);
                } else if (r4Candidates.length > 0) {
                    createPiece('SHIELD', player, r4Candidates[0].q, r4Candidates[0].r);
                    if (r4Candidates[1]) createPiece('SNAKE', player, r4Candidates[1].q, r4Candidates[1].r);
                }
            }



            // 4. Ring 3 Pawns (3 total)
            const r4Positions = r4Candidates.slice(0, 3);
            const pawnPositions = [];

            // For each R4 piece, find its most inward neighbor on R3
            r4Positions.forEach(r4 => {
                let bestPawn = null;
                let minD = Infinity;
                for (let dir = 0; dir < 6; dir++) {
                    const n = hexNeighbor(r4.q, r4.r, dir);
                    if (getRing(n.q, n.r) === 3 && isValidHex(n.q, n.r)) {
                        const d = hexDistance(0, 0, n.q, n.r);
                        if (d < minD) {
                            minD = d;
                            bestPawn = n;
                        }
                    }
                }
                if (bestPawn && !pawnPositions.some(p => p.q === bestPawn.q && p.r === bestPawn.r)) {
                    pawnPositions.push(bestPawn);
                }
            });

            // Fallback for pawns if overlaps occurred
            if (pawnPositions.length < 3) {
                const allRing3 = getHexesInRing(3);
                allRing3.sort((a, b) => hexDistance(kingCorner.q, kingCorner.r, a.q, a.r) - hexDistance(kingCorner.q, kingCorner.r, b.q, b.r));
                for (const p of allRing3) {
                    if (!pawnPositions.some(prev => prev.q === p.q && prev.r === p.r)) {
                        pawnPositions.push(p);
                        if (pawnPositions.length >= 3) break;
                    }
                }
            }
            pawnPositions.slice(0, 3).forEach(p => createPiece('PAWN', player, p.q, p.r));

            // 5. Ring 2 Archer (Deterministic)
            const ring2Hexes = getHexesInRing(2);
            ring2Hexes.sort((a, b) => {
                let distA = 0, distB = 0;
                pawnPositions.slice(0, 3).forEach(p => {
                    distA += hexDistance(a.q, a.r, p.q, p.r);
                    distB += hexDistance(b.q, b.r, p.q, p.r);
                });
                return distA - distB;
            });

            if (ring2Hexes.length > 0) {
                createPiece('ARCHER', player, ring2Hexes[0].q, ring2Hexes[0].r);
            }
        }

        function createPiece(type, player, q, r) {
            const config = gameState.unitConfigs[type];
            const hp = config.hp === Infinity ? Infinity : config.hp;

            const piece = {
                type,
                player,
                q, r,
                hp,
                maxHP: hp,
                alive: true,
                pinned: false,
                altMoveUnlocked: false
            };

            gameState.pieces.push(piece);
        }

        // ============================================
        // BOARD RENDERING
        // ============================================

        function createBoard() {
            const svg = document.getElementById('game-board');
            svg.innerHTML = '';

            // Create defs for patterns
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

            // Diagonal stripe pattern for pinned pieces
            const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
            pattern.setAttribute('id', 'pin-stripes');
            pattern.setAttribute('patternUnits', 'userSpaceOnUse');
            pattern.setAttribute('width', '8');
            pattern.setAttribute('height', '8');
            pattern.setAttribute('patternTransform', 'rotate(45)');

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            line.setAttribute('x', '0');
            line.setAttribute('y', '0');
            line.setAttribute('width', '4');
            line.setAttribute('height', '8');
            line.setAttribute('fill', 'rgba(251, 191, 36, 0.4)'); // Semi-transparent amber

            pattern.appendChild(line);
            defs.appendChild(pattern);
            svg.appendChild(defs);

            // Create hex group
            const hexGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            hexGroup.id = 'hex-group';
            svg.appendChild(hexGroup);

            // Create ring highlight paths for rotation
            for (let ring = 1; ring <= BOARD_RADIUS; ring++) {
                const ringHexes = getHexesInRing(ring);
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.id = `ring-${ring}`;
                path.classList.add('ring-highlight');

                // Create path around ring
                let d = '';
                ringHexes.forEach((hex, i) => {
                    const { x, y } = hexToPixel(hex.q, hex.r);
                    if (i === 0) {
                        d += `M ${x} ${y}`;
                    } else {
                        d += ` L ${x} ${y}`;
                    }
                });
                d += ' Z';
                path.setAttribute('d', d);
                svg.appendChild(path);
            }

            // Create hexes
            for (let q = -BOARD_RADIUS; q <= BOARD_RADIUS; q++) {
                for (let r = -BOARD_RADIUS; r <= BOARD_RADIUS; r++) {
                    if (!isValidHex(q, r)) continue;

                    const { x, y } = hexToPixel(q, r);
                    const corners = getHexCorners(x, y, HEX_SIZE - 2);

                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', corners.map(c => `${c.x},${c.y}`).join(' '));
                    polygon.classList.add('hex');
                    polygon.dataset.q = q;
                    polygon.dataset.r = r;

                    const ring = getRing(q, r);
                    polygon.classList.add(`ring-${ring}`);
                    polygon.dataset.ring = ring;

                    if (q === 0 && r === 0) {
                        polygon.classList.add('throne');
                    }

                    polygon.addEventListener('click', (e) => onHexClick(q, r, e));
                    hexGroup.appendChild(polygon);
                }
            }

            // Create pinning paths group (rendered behind pieces)
            const pinningGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            pinningGroup.id = 'pinning-paths-group';
            svg.appendChild(pinningGroup);

            // Create piece group
            const pieceGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            pieceGroup.id = 'piece-group';
            svg.appendChild(pieceGroup);
        }

        function renderPieces() {
            const pieceGroup = document.getElementById('piece-group');
            pieceGroup.innerHTML = '';

            gameState.pieces.forEach((piece, index) => {
                if (!piece.alive) return;

                const { x, y } = hexToPixel(piece.q, piece.r);

                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.classList.add('piece');
                g.dataset.index = index;

                if (gameState.selectedPiece === index) {
                    g.classList.add('selected');
                }
                if (piece.pinned) {
                    g.classList.add('pinned');
                }
                if (gameState.usedPieces.has(index)) {
                    g.classList.add('used');
                }

                // Pin border (rendered first, behind everything)
                if (piece.pinned) {
                    const borderCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    borderCircle.setAttribute('cx', x);
                    borderCircle.setAttribute('cy', y);
                    borderCircle.setAttribute('r', HEX_SIZE * 0.6);
                    borderCircle.setAttribute('fill', 'none');
                    borderCircle.setAttribute('stroke', '#fbbf24'); // Amber color
                    borderCircle.setAttribute('stroke-width', 4);
                    borderCircle.setAttribute('pointer-events', 'none');
                    g.appendChild(borderCircle);
                }

                // Piece background (skip for ghosts - they're spectral)
                if (piece.type !== 'GHOST') {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', HEX_SIZE * 0.6);

                    let fillColor, strokeColor;
                    if (piece.player === 1) {
                        fillColor = '#c94c4c'; // var(--player1)
                        strokeColor = '#8a3535'; // var(--player1-dim)
                    } else {
                        if (gameState.gameMode === 'vsCPU' && piece.player === gameState.cpuPlayer) {
                            fillColor = '#a855f7'; // var(--player-cpu)
                            strokeColor = '#7c3aed'; // var(--player-cpu-dim)
                        } else {
                            fillColor = '#4c8bc9'; // var(--player2)
                            strokeColor = '#35628a'; // var(--player2-dim)
                        }
                    }

                    circle.setAttribute('fill', fillColor);
                    circle.setAttribute('stroke', strokeColor);
                    circle.setAttribute('stroke-width', 2);
                    g.appendChild(circle);
                }

                // Diagonal stripe overlay for pinned pieces (behind text)
                if (piece.pinned) {
                    const stripeOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    stripeOverlay.setAttribute('cx', x);
                    stripeOverlay.setAttribute('cy', y);
                    stripeOverlay.setAttribute('r', HEX_SIZE * 0.6);
                    stripeOverlay.setAttribute('fill', 'url(#pin-stripes)');
                    stripeOverlay.setAttribute('pointer-events', 'none');
                    g.appendChild(stripeOverlay);
                }

                if (piece.type === 'SNAKE') {
                    // Cobra SVG
                    const iconGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    iconGroup.setAttribute('transform', `translate(${x}, ${y}) scale(1.1)`);

                    // Body (Stroke)
                    const body = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    body.setAttribute('d', 'M 0 9 Q 1 7 4 7 Q 7 7 7 4 Q 7 1 0 1 Q -7 1 -7 -2 Q -7 -5 0 -5');
                    body.setAttribute('fill', 'none');
                    body.setAttribute('stroke', 'white');
                    body.setAttribute('stroke-width', '2.5');
                    body.setAttribute('stroke-linecap', 'round');
                    iconGroup.appendChild(body);

                    // Head (Diamond Fill)
                    const head = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    head.setAttribute('d', 'M 0 -4 L 3.5 -7.5 L 0 -11 L -3.5 -7.5 Z');
                    head.setAttribute('fill', 'white');
                    iconGroup.appendChild(head);

                    // Tongue
                    const tongue = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    tongue.setAttribute('d', 'M 0 -11 L -1.5 -12.5 M 0 -11 L 1.5 -12.5');
                    tongue.setAttribute('stroke', 'white');
                    tongue.setAttribute('stroke-width', '1.5');
                    tongue.setAttribute('stroke-linecap', 'round');
                    iconGroup.appendChild(tongue);

                    g.appendChild(iconGroup);
                } else if (piece.type === 'ARCHER') {
                    // Use SVG paths for cleaner, non-emoji look
                    const iconGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                    // Center the icon
                    iconGroup.setAttribute('transform', `translate(${x}, ${y}) scale(1.2)`);

                    if (piece.altMoveUnlocked) {
                        // Unlocked: Bow and Arrow
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        // Bow (curve) + Arrow (line + head)
                        path.setAttribute('d', 'M 3 -8 Q -6 0 3 8 M -6 0 L 8 0 M 4 -3 L 8 0 L 4 3');
                        path.setAttribute('stroke', 'white');
                        path.setAttribute('stroke-width', '2');
                        path.setAttribute('fill', 'none');
                        path.setAttribute('stroke-linecap', 'round');
                        path.setAttribute('stroke-linejoin', 'round');
                        iconGroup.appendChild(path);
                    } else {
                        // Locked: Bow only
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        // Bow (curve)
                        path.setAttribute('d', 'M 3 -8 Q -6 0 3 8');
                        path.setAttribute('stroke', 'white');
                        path.setAttribute('stroke-width', '2');
                        path.setAttribute('fill', 'none');
                        path.setAttribute('stroke-linecap', 'round');
                        iconGroup.appendChild(path);

                        // Add a small cross or lock indicator? 
                        // User said "arrowless bow", so maybe just the bow is enough.
                        // Maybe add a string?
                        const string = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        string.setAttribute('d', 'M 3 -8 L 3 8');
                        string.setAttribute('stroke', 'white');
                        string.setAttribute('stroke-width', '1');
                        string.setAttribute('stroke-dasharray', '2.5, 2.5'); // Dashed string to look inactive?
                        string.setAttribute('opacity', '0.7');
                        iconGroup.appendChild(string);
                    }
                    iconGroup.setAttribute('pointer-events', 'none');
                    g.appendChild(iconGroup);
                } else if (piece.type === 'SHIELD') {
                    // Custom SVG Shield Icon (Polished Kite Shield)
                    const iconGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    iconGroup.setAttribute('transform', `translate(${x}, ${y}) scale(1.1)`); // Slightly adjusted scale

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    // Sleek Kite Shield
                    // d: Start top-left (-5.5, -7), Top line to (5.5, -7), 
                    // curve down-right to tip (0, 8), curve up-left to close.
                    path.setAttribute('d', 'M -6 -7 H 6 L 6 -1 Q 6 6 0 9 Q -6 6 -6 -1 Z');
                    path.setAttribute('stroke', 'white');
                    path.setAttribute('stroke-width', '2');
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke-linejoin', 'round');
                    path.setAttribute('stroke-linecap', 'round');

                    // Central Ridge/Spine
                    const detail = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    detail.setAttribute('d', 'M 0 -7 L 0 9');
                    detail.setAttribute('stroke', 'white');
                    detail.setAttribute('stroke-width', '1.5');
                    detail.setAttribute('stroke-linecap', 'round');

                    // Horizontal bar for visual weight
                    const bar = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    bar.setAttribute('d', 'M -5.5 -2 L 5.5 -2');
                    bar.setAttribute('stroke', 'white');
                    bar.setAttribute('stroke-width', '1');

                    iconGroup.appendChild(path);
                    iconGroup.appendChild(detail);
                    iconGroup.appendChild(bar);

                    iconGroup.setAttribute('pointer-events', 'none');
                    g.appendChild(iconGroup);
                } else if (piece.type === 'BOMBER') {
                    // Custom SVG Bomb Icon for Bomber
                    const iconGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    iconGroup.setAttribute('transform', `translate(${x}, ${y}) scale(1.1)`);

                    const fuse = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    // S-shaped fuse
                    fuse.setAttribute('d', 'M 2 -7 Q 5 -10 3 -12');
                    fuse.setAttribute('stroke', 'white');
                    fuse.setAttribute('stroke-width', '1.5');
                    fuse.setAttribute('fill', 'none');
                    fuse.setAttribute('stroke-linecap', 'round');

                    const cap = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    cap.setAttribute('x', -2);
                    cap.setAttribute('y', -8.5);
                    cap.setAttribute('width', 4);
                    cap.setAttribute('height', 2);
                    cap.setAttribute('fill', 'white');
                    cap.setAttribute('rx', 0.5);

                    const body = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    body.setAttribute('cx', 0);
                    body.setAttribute('cy', 1);
                    body.setAttribute('r', 7);
                    body.setAttribute('fill', 'none');
                    body.setAttribute('stroke', 'white');
                    body.setAttribute('stroke-width', '2');

                    const shine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    shine.setAttribute('d', 'M -3 -2 Q -4 1 -3 4');
                    shine.setAttribute('stroke', 'white');
                    shine.setAttribute('stroke-width', '1');
                    shine.setAttribute('fill', 'none');
                    shine.setAttribute('stroke-linecap', 'round');

                    iconGroup.appendChild(fuse);
                    iconGroup.appendChild(cap);
                    iconGroup.appendChild(body);
                    iconGroup.appendChild(shine);
                    iconGroup.setAttribute('pointer-events', 'none');
                    g.appendChild(iconGroup);
                } else if (piece.type === 'BOXER') {
                    const boxerIcon = createBoxerIconSvg(24, 'white');
                    boxerIcon.setAttribute('x', x - 12);
                    boxerIcon.setAttribute('y', y - 12);
                    boxerIcon.setAttribute('pointer-events', 'none');
                    g.appendChild(boxerIcon);
                } else if (piece.type === 'GHOST') {
                    // Click target for ghosts (invisible)
                    const ghostHit = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    ghostHit.setAttribute('cx', x);
                    ghostHit.setAttribute('cy', y);
                    ghostHit.setAttribute('r', HEX_SIZE * 0.6);
                    ghostHit.setAttribute('fill', 'transparent');
                    ghostHit.setAttribute('pointer-events', 'all');
                    g.appendChild(ghostHit);

                    // Ghost piece - use spectral ghost icon
                    const iconGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    // Scale increased to 2.2 (2x original 1.1)
                    iconGroup.setAttribute('transform', `translate(${x}, ${y}) scale(2.2)`);
                    iconGroup.setAttribute('opacity', '0.6');
                    iconGroup.setAttribute('pointer-events', 'none');

                    // Determine ghost color based on player
                    let ghostColor;
                    if (piece.player === 1) {
                        ghostColor = '#c94c4c';
                    } else {
                        if (gameState.gameMode === 'vsCPU' && piece.player === gameState.cpuPlayer) {
                            ghostColor = '#a855f7';
                        } else {
                            ghostColor = '#4c8bc9';
                        }
                    }

                    const ghostBody = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    // Classic ghost shape: rounded top, wavy bottom
                    ghostBody.setAttribute('d', 'M -6 4 L -6 -2 Q -6 -8 0 -8 Q 6 -8 6 -2 L 6 4 Q 4 2 2 4 Q 0 2 -2 4 Q -4 2 -6 4 Z');
                    ghostBody.setAttribute('fill', ghostColor);
                    iconGroup.appendChild(ghostBody);

                    // Small ghost eyes (white)
                    const eye1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    eye1.setAttribute('cx', -2);
                    eye1.setAttribute('cy', -2);
                    eye1.setAttribute('r', 1);
                    eye1.setAttribute('fill', 'white');
                    iconGroup.appendChild(eye1);

                    const eye2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    eye2.setAttribute('cx', 2);
                    eye2.setAttribute('cy', -2);
                    eye2.setAttribute('r', 1);
                    eye2.setAttribute('fill', 'white');
                    iconGroup.appendChild(eye2);

                    g.appendChild(iconGroup);
                } else {
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', x);
                    text.setAttribute('y', y + 6);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', '24');
                    text.setAttribute('fill', 'white');
                    text.setAttribute('pointer-events', 'none');
                    text.textContent = PIECE_TYPES[piece.type].symbol;
                    g.appendChild(text);
                }

                // Stats indicators (skip for ghosts)
                const config = gameState.unitConfigs[piece.type];

                if (piece.type !== 'GHOST') {
                    // HP indicator (not for King)
                    if (!PIECE_TYPES[piece.type].isKing && piece.hp < Infinity) {
                        const hpText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        hpText.setAttribute('x', x + HEX_SIZE * 0.4);
                        hpText.setAttribute('y', y - HEX_SIZE * 0.3);
                        hpText.classList.add('piece-stat', 'hp');
                        hpText.textContent = `â™¥${piece.hp}`;
                        g.appendChild(hpText);
                    }

                    // Damage indicator
                    if (config.ramDamage > 0) {
                        const dmgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        dmgText.setAttribute('x', x - HEX_SIZE * 0.4);
                        dmgText.setAttribute('y', y - HEX_SIZE * 0.3);
                        dmgText.classList.add('piece-stat', 'dmg');
                        dmgText.textContent = `ðŸ—¡${config.ramDamage}`;
                        g.appendChild(dmgText);
                    }
                }

                // Range indicator
                if (config.range > 0 && config.range < Infinity) {
                    const rngText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    rngText.setAttribute('x', x + HEX_SIZE * 0.4);
                    rngText.setAttribute('y', y + HEX_SIZE * 0.5); // Bottom-right
                    rngText.classList.add('piece-stat', 'rng');

                    let moveIcon = 'â†';
                    if (config.template === MOVEMENT_TEMPLATES.STRAIGHT_LINE) {
                        moveIcon = 'â†‘';
                    } else if (config.template === MOVEMENT_TEMPLATES.DIRECT_JUMP) {
                        moveIcon = 'â—Ž';
                    }
                    rngText.textContent = `${moveIcon}${config.range}`;
                    g.appendChild(rngText);
                }

                g.addEventListener('click', (e) => {
                    e.stopPropagation();
                    onPieceClick(index);
                });

                pieceGroup.appendChild(g);
            });

            // Render Sticky Bombs
            if (gameState.bombs) {
                gameState.bombs.forEach(bomb => {
                    let x, y;
                    let isValid = true;

                    if (bomb.type === 'cell') {
                        const pos = hexToPixel(bomb.q, bomb.r);
                        x = pos.x;
                        y = pos.y;
                    } else if (bomb.type === 'unit') {
                        const targetPiece = gameState.pieces[bomb.targetUnitIndex];
                        if (targetPiece && targetPiece.alive) {
                            const pos = hexToPixel(targetPiece.q, targetPiece.r);
                            x = pos.x;
                            y = pos.y;
                        } else {
                            isValid = false;
                        }
                    }

                    if (isValid) {
                        const bombCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');

                        // Position adjustment
                        if (bomb.type === 'unit') {
                            // Bottom-left corner
                            const offsetX = -HEX_SIZE * 0.5;
                            const offsetY = HEX_SIZE * 0.4;
                            bombCircle.setAttribute('cx', x + offsetX);
                            bombCircle.setAttribute('cy', y + offsetY);
                        } else {
                            // Center for cell bomb
                            bombCircle.setAttribute('cx', x);
                            bombCircle.setAttribute('cy', y);
                        }

                        // Determine owner player for color class
                        const ownerPiece = gameState.pieces[bomb.owner];
                        const ownerPlayer = ownerPiece ? ownerPiece.player : 1;

                        bombCircle.setAttribute('r', 6);
                        bombCircle.classList.add('bomb-indicator');
                        bombCircle.classList.add(`p${ownerPlayer}`);
                        bombCircle.setAttribute('pointer-events', 'none');

                        pieceGroup.appendChild(bombCircle);
                    }
                });
            }

            // Ensure piece-group is always on top after rendering pieces
            const svg = document.getElementById('game-board');
            if (svg && pieceGroup.parentNode === svg) {
                svg.appendChild(pieceGroup);
            }
            updateForceFieldVisuals();
        }

        function highlightValidMoves(moves) {
            // Clear previous highlights
            document.querySelectorAll('.hex.valid-move, .hex.damage-path').forEach(el => {
                el.classList.remove('valid-move', 'damage-path');
            });

            moves.forEach(move => {
                const hex = document.querySelector(`.hex[data-q="${move.q}"][data-r="${move.r}"]`);
                if (hex) {
                    hex.classList.add(move.willKill ? 'damage-path' : 'valid-move');
                }

                // Highlight damage path
                if (move.damagePath) {
                    move.damagePath.forEach(pos => {
                        const pathHex = document.querySelector(`.hex[data-q="${pos.q}"][data-r="${pos.r}"]`);
                        if (pathHex) pathHex.classList.add('damage-path');
                    });
                }
            });
        }

        function clearHighlights() {
            document.querySelectorAll('.hex.valid-move, .hex.damage-path, .hex.selected, .hex.path-step, .hex.path-end, .hex.shoot-path').forEach(el => {
                el.classList.remove('valid-move', 'damage-path', 'selected', 'path-step', 'path-end', 'shoot-path');
            });
        }

        // ============================================
        // GAME LOGIC
        // ============================================

        // ============================================
        // LANCE SPECIAL ABILITY
        // ============================================

        function enterLanceTargetingMode(pieceIndex) {
            gameState.lanceTargetingMode = true;
            gameState.pathBuilding = false; // Disable path building

            // Calculate valid rays
            calculateLanceRays(pieceIndex);

            // Draw visualization
            drawLanceTargetingVisualization();

            // Show cancel button
            document.getElementById('btn-cancel-path').style.display = 'inline-block';
            document.getElementById('btn-rotate').style.display = 'none'; // Hide the button itself

            addLog('Select a direction for Arrow Shot', 'system');
        }

        function exitLanceTargetingMode() {
            gameState.lanceTargetingMode = false;
            gameState.lanceTargetingRays = [];
            clearHighlights();
        }

        function calculateLanceRays(pieceIndex) {
            const piece = gameState.pieces[pieceIndex];
            gameState.lanceTargetingRays = [];

            // 6 Directions
            for (let dir = 0; dir < 6; dir++) {
                const ray = [];
                let current = { q: piece.q, r: piece.r };
                let hitUnit = null;

                // Trace ray
                for (let dist = 1; dist <= 10; dist++) { // Max board size roughly
                    const next = hexNeighbor(current.q, current.r, dir);

                    if (!isValidHex(next.q, next.r)) break;

                    // Barrier Check for Projectile
                    const isCurrentInside = isInsideForceField(current.q, current.r);
                    const isNextInside = isInsideForceField(next.q, next.r);

                    if (isCurrentInside !== isNextInside) {
                        // Ray blocked by field
                        break;
                    }

                    ray.push({ q: next.q, r: next.r });
                    current = next;

                    // Check for hit
                    const unit = getPieceAt(next.q, next.r);
                    if (unit && unit.alive) {
                        hitUnit = unit;
                        break; // Stop at first unit
                    }
                }

                if (ray.length > 0) {
                    gameState.lanceTargetingRays.push({
                        dir: dir,
                        path: ray,
                        hitUnit: hitUnit
                    });
                }
            }
        }

        function drawLanceTargetingVisualization() {
            clearHighlights();

            // Highlight all ray paths
            gameState.lanceTargetingRays.forEach(rayData => {
                rayData.path.forEach(pos => {
                    const hex = document.querySelector(`.hex[data-q="${pos.q}"][data-r="${pos.r}"]`);
                    if (hex) {
                        hex.classList.add('shoot-path');
                        // Add data attribute for click handling
                        hex.dataset.shootDir = rayData.dir;
                    }
                });

                // Highlight target if enemy
                if (rayData.hitUnit && rayData.hitUnit.player !== gameState.currentPlayer) {
                    const hex = document.querySelector(`.hex[data-q="${rayData.hitUnit.q}"][data-r="${rayData.hitUnit.r}"]`);
                    if (hex) hex.classList.add('damage-path');
                }
            });
        }

        function handleLanceTargetingClick(q, r) {
            // Check if clicked hex is part of any ray
            const clickedRay = gameState.lanceTargetingRays.find(ray =>
                ray.path.some(step => step.q === q && step.r === r)
            );

            if (clickedRay) {
                executeLanceShot(clickedRay);
            } else {
                // Clicked outside - cancel
                cancelPathBuilding();
            }
        }

        function executeLanceShot(rayData) {
            const piece = gameState.pieces[gameState.selectedPiece];
            const hitUnit = rayData.hitUnit;

            addLog(`${PIECE_TYPES[piece.type].name} fires Arrow!`, piece.player);

            if (hitUnit) {
                if (hitUnit.player !== piece.player) {
                    // Hit enemy - Deal 3 damage
                    addLog(`Arrow hits ${PIECE_TYPES[hitUnit.type].name} for 3 damage!`, 'system');
                    applyDamage(hitUnit, 3, gameState.selectedPiece);
                    updatePins(); // Check logic after damage
                    checkArmyElimination();
                } else {
                    // Hit ally - 0 damage
                    addLog(`Arrow hits ally ${PIECE_TYPES[hitUnit.type].name} (0 damage).`, 'system');
                }
            } else {
                addLog(`Arrow missed!`, 'system');
            }

            useAction(gameState.selectedPiece, 'ALT');
            cancelPathBuilding(); // Deselect and exit mode
        }

        function getValidMoves(piece) {
            if (!piece.alive || piece.pinned) return [];

            const config = gameState.unitConfigs[piece.type];
            const maxRange = config.range;
            if (config.template === MOVEMENT_TEMPLATES.DIRECT_JUMP) {
                const moves = [];
                const pieceIndex = gameState.pieces.findIndex(p => p.alive && p.q === piece.q && p.r === piece.r);
                for (let q = -BOARD_RADIUS; q <= BOARD_RADIUS; q++) {
                    for (let r = -BOARD_RADIUS; r <= BOARD_RADIUS; r++) {
                        if (!isValidHex(q, r)) continue;
                        if (q === piece.q && r === piece.r) continue;
                        if (hexDistance(piece.q, piece.r, q, r) > maxRange) continue;

                        const occupant = getPieceAt(q, r);
                        const isFriendlyGhost = occupant && occupant.type === 'GHOST' && occupant.player === piece.player;
                        if (occupant && occupant.player === piece.player && !isFriendlyGhost) continue;

                        const hasEnemy = !!occupant && occupant.player !== piece.player;
                        const move = {
                            q,
                            r,
                            damagePath: hasEnemy ? [{ q, r, piece: occupant }] : [],
                            willKill: hasEnemy,
                            path: [{ q, r }]
                        };

                        if (hasEnemy) {
                            const ramDamage = gameState.unitConfigs[piece.type].ramDamage;
                            if (!simulateMoveAndValidate(pieceIndex, q, r, move, ramDamage)) {
                                continue;
                            }
                        }

                        moves.push(move);
                    }
                }
                return moves;
            }
            // For templates, all directions are valid for path finding
            // Template restrictions are enforced during path building
            const validDirections = [0, 1, 2, 3, 4, 5];

            // Use BFS to find all reachable positions
            // Track all paths to each destination, then select the best one
            const bestPaths = new Map(); // key -> { move, damageCount, distance }
            const queue = [{
                q: piece.q,
                r: piece.r,
                distance: 0,
                damagePath: [],
                path: [{ q: piece.q, r: piece.r }]
            }];

            // Track visited states: key -> Set of (distance, damageCount) pairs
            // This allows revisiting if we find a better path (more damage or shorter)
            const visited = new Map(); // key -> Set of "distance,damageCount" strings

            function getVisitedKey(distance, damageCount) {
                return `${distance},${damageCount}`;
            }

            function isBetterPath(newDistance, newDamageCount, existing) {
                if (!existing) return true;
                // Prefer paths with more damage, or if same damage, shorter path
                for (const state of existing) {
                    const [dist, dmg] = state.split(',').map(Number);
                    if (dmg > newDamageCount) return false; // Existing has more damage
                    if (dmg === newDamageCount && dist <= newDistance) return false; // Same damage, shorter or equal
                }
                return true;
            }

            function addVisited(key, distance, damageCount) {
                if (!visited.has(key)) {
                    visited.set(key, new Set());
                }
                visited.get(key).add(getVisitedKey(distance, damageCount));
            }

            function shouldExplore(key, distance, damageCount) {
                const existing = visited.get(key);
                if (!existing) return true;
                return isBetterPath(distance, damageCount, existing);
            }

            while (queue.length > 0) {
                const current = queue.shift();

                // Stop if we've reached max range
                if (current.distance >= maxRange) continue;

                // Try moving in all valid directions from current position
                validDirections.forEach(dir => {
                    const next = hexNeighbor(current.q, current.r, dir);
                    const nextKey = hexKey(next.q, next.r);

                    // Check if valid hex
                    if (!isValidHex(next.q, next.r)) return;

                    const newDistance = current.distance + 1;
                    const occupant = getPieceAt(next.q, next.r);
                    const newDamagePath = [...current.damagePath];
                    let newDamageCount = newDamagePath.length;

                    // If there's an enemy here, add to damage path
                    if (occupant && occupant.player !== piece.player) {
                        newDamagePath.push({ q: next.q, r: next.r, piece: occupant });
                        newDamageCount = newDamagePath.length;
                    }

                    // Check if we should explore this path
                    if (!shouldExplore(nextKey, newDistance, newDamageCount)) {
                        return;
                    }

                    const newPath = [...current.path, { q: next.q, r: next.r }];
                    const newState = {
                        q: next.q,
                        r: next.r,
                        distance: newDistance,
                        damagePath: newDamagePath,
                        damageCount: newDamageCount,
                        path: newPath
                    };

                    const isFriendlyGhost = occupant && occupant.type === 'GHOST' && occupant.player === piece.player;
                    // If there's a friendly non-ghost, we can pass through but can't end here
                    if (occupant && occupant.player === piece.player && !isFriendlyGhost) {
                        // Can pass through - continue exploring
                        addVisited(nextKey, newDistance, newDamageCount);
                        queue.push(newState);
                        return;
                    }

                    // Empty hex or enemy hex - can potentially end here
                    addVisited(nextKey, newDistance, newDamageCount);

                    // Check if we can end on this hex
                    let isValidDestination = false;
                    let wouldKill = false;

                    if (occupant && occupant.player !== piece.player) {
                        // Check if the attacker is pinning this target (using coordinates instead of references)
                        const occupantIndex = gameState.pieces.findIndex(p => p.alive && p.q === occupant.q && p.r === occupant.r);
                        const attackerIndex = gameState.pieces.findIndex(p => p.alive && p.q === piece.q && p.r === piece.r);
                        const isPinningPiece = occupantIndex >= 0 &&
                            attackerIndex >= 0 &&
                            gameState.pinningMap.has(occupantIndex) &&
                            gameState.pinningMap.get(occupantIndex).has(attackerIndex);

                        // If the attacker is pinning the target, they can't insta-kill it
                        // They must deal enough damage to kill it normally
                        if (isPinningPiece && occupant.pinned) {
                            // Attacker is pinning the target - must kill with damage, not insta-kill
                            wouldKill = canKillWithRam(piece, occupant, newDamageCount + 1);
                        } else {
                            // Normal case: pinned pieces die instantly (unless pinned by attacker)
                            wouldKill = occupant.pinned || canKillWithRam(piece, occupant, newDamageCount + 1);
                        }
                        isValidDestination = wouldKill;
                    } else {
                        // Empty hex - valid destination
                        isValidDestination = true;
                    }

                    if (isValidDestination) {
                        // Check if this is a better path to this destination
                        const existing = bestPaths.get(nextKey);
                        const isBetter = !existing ||
                            newDamageCount > existing.damageCount ||
                            (newDamageCount === existing.damageCount && newDistance < existing.distance);

                        if (isBetter) {
                            bestPaths.set(nextKey, {
                                q: next.q,
                                r: next.r,
                                damagePath: newDamagePath,
                                damageCount: newDamageCount,
                                willKill: wouldKill,
                                path: newPath,
                                distance: newDistance
                            });
                        }
                    }

                    // Continue exploring from this position
                    queue.push(newState);
                });
            }

            return Array.from(bestPaths.values()).map(({ willKill, damagePath, path, q, r }) => ({
                q, r, damagePath, willKill, path
            }));
        }

        function isInsideForceField(q, r) {
            return gameState.forceFields.some(field => {
                return hexDistance(q, r, field.q, field.r) <= 1;
            });
        }

        function updateForceFieldVisuals() {
            // Clear existing
            document.querySelectorAll('.hex.force-field').forEach(el => el.classList.remove('force-field'));

            // Apply new
            gameState.forceFields.forEach(field => {
                const center = { q: field.q, r: field.r };
                // Get all hexes in range 1
                const hexes = [center];
                for (let i = 0; i < 6; i++) {
                    hexes.push(hexNeighbor(center.q, center.r, i));
                }

                hexes.forEach(pos => {
                    const hex = document.querySelector(`.hex[data-q="${pos.q}"][data-r="${pos.r}"]`);
                    if (hex) hex.classList.add('force-field');
                });
            });
        }

        function activateForceField(pieceIndex) {
            const piece = gameState.pieces[pieceIndex];
            gameState.forceFields.push({
                q: piece.q,
                r: piece.r,
                player: piece.player
            });

            addLog(`${PIECE_TYPES[piece.type].name} activates Force Field!`, piece.player);
            addLog(`${PIECE_TYPES[piece.type].name} activates Force Field!`, piece.player);
            useAction(pieceIndex, 'ALT');
            cancelPathBuilding(); // This calls renderPieces which calls updateForceFieldVisuals
        }

        function getValidNextSteps(piece, currentPath) {
            // Pinned pieces and ghosts cannot move
            if (!piece.alive || piece.pinned || piece.type === 'GHOST') return [];

            // Get valid adjacent hexes for the next step in path building
            const config = gameState.unitConfigs[piece.type];
            const maxRange = config.range;

            // Direct jump: choose destination within range (no path)
            if (config.template === MOVEMENT_TEMPLATES.DIRECT_JUMP) {
                if (currentPath.length > 0) return [];
                const results = [];
                const pieceIndex = gameState.pieces.findIndex(p => p.alive && p.q === piece.q && p.r === piece.r);
                for (let q = -BOARD_RADIUS; q <= BOARD_RADIUS; q++) {
                    for (let r = -BOARD_RADIUS; r <= BOARD_RADIUS; r++) {
                        if (!isValidHex(q, r)) continue;
                        if (q === piece.q && r === piece.r) continue;
                        if (hexDistance(piece.q, piece.r, q, r) > maxRange) continue;

                        const occupant = getPieceAt(q, r);
                        const isFriendlyGhost = occupant && occupant.type === 'GHOST' && occupant.player === piece.player;
                        if (occupant && occupant.player === piece.player && !isFriendlyGhost) continue;

                        const hasEnemy = !!occupant && occupant.player !== piece.player;
                        if (hasEnemy) {
                            const move = {
                                q,
                                r,
                                damagePath: [{ q, r, piece: occupant }],
                                willKill: true,
                                path: [{ q, r }]
                            };
                            const ramDamage = gameState.unitConfigs[piece.type].ramDamage;
                            if (!simulateMoveAndValidate(pieceIndex, q, r, move, ramDamage)) {
                                continue;
                            }
                        }

                        results.push({ q, r, hasEnemy });
                    }
                }
                return results;
            }

            // If path is at max range, no more steps
            if (currentPath.length >= maxRange) return [];

            const currentPos = currentPath.length > 0
                ? currentPath[currentPath.length - 1]
                : { q: piece.q, r: piece.r };

            // Determine valid directions based on template
            let validDirections = [];

            if (config.template === MOVEMENT_TEMPLATES.FREE_MOTION) {
                // Free motion: can move in any direction
                validDirections = [0, 1, 2, 3, 4, 5];
            } else if (config.template === MOVEMENT_TEMPLATES.STRAIGHT_LINE) {
                // Straight line: must continue in the same direction
                if (currentPath.length === 0) {
                    // First step: can choose any direction
                    validDirections = [0, 1, 2, 3, 4, 5];
                } else {
                    // Subsequent steps: must continue in the same direction
                    // Find the direction from the previous position to the current position
                    let fromPos, toPos;
                    if (currentPath.length === 1) {
                        // From piece position to first step
                        fromPos = { q: piece.q, r: piece.r };
                        toPos = currentPath[0];
                    } else {
                        // From previous step to current step
                        fromPos = currentPath[currentPath.length - 2];
                        toPos = currentPath[currentPath.length - 1];
                    }

                    // Find the direction from fromPos to toPos
                    let direction = -1;
                    for (let dir = 0; dir < 6; dir++) {
                        const neighbor = hexNeighbor(fromPos.q, fromPos.r, dir);
                        if (neighbor.q === toPos.q && neighbor.r === toPos.r) {
                            direction = dir;
                            break;
                        }
                    }

                    // If we found the direction, only allow that direction
                    if (direction >= 0) {
                        validDirections = [direction];
                    } else {
                        // Fallback: if we can't determine direction, allow all (shouldn't happen)
                        validDirections = [0, 1, 2, 3, 4, 5];
                    }
                }
            }

            const validNext = [];

            validDirections.forEach(dir => {
                const next = hexNeighbor(currentPos.q, currentPos.r, dir);

                if (!isValidHex(next.q, next.r)) return;

                // Force Field Check (Universal)
                const isCurrentInside = isInsideForceField(currentPos.q, currentPos.r);
                const isNextInside = isInsideForceField(next.q, next.r);
                // Cannot exit if inside, Cannot enter if outside.
                if (isCurrentInside !== isNextInside) {
                    return; // Blocked
                }

                // Check if already in path (can't backtrack)
                const alreadyInPath = currentPath.some(step => step.q === next.q && step.r === next.r);
                if (alreadyInPath) return;

                const occupant = getPieceAt(next.q, next.r);
                const ghostAtPosition = getGhostPieceAt(next.q, next.r);

                // Ghost handling
                if (ghostAtPosition) {
                    // If ghost overlaps with a real piece, use the real piece for occupancy rules.
                    const otherOccupant = gameState.pieces.find(p =>
                        p.alive && p.q === next.q && p.r === next.r && p.type !== 'GHOST'
                    );
                    if (otherOccupant) {
                        validNext.push({
                            q: next.q,
                            r: next.r,
                            hasEnemy: otherOccupant.player !== piece.player,
                            hasFriendly: otherOccupant.player === piece.player,
                            occupant: otherOccupant
                        });
                        return;
                    }

                    // Standalone friendly ghost is landable (treat as empty).
                    if (ghostAtPosition.player === piece.player) {
                        validNext.push({
                            q: next.q,
                            r: next.r,
                            hasEnemy: false,
                            hasFriendly: false,
                            occupant: null
                        });
                        return;
                    }

                    // Enemy ghost behaves like an enemy occupant.
                    validNext.push({
                        q: next.q,
                        r: next.r,
                        hasEnemy: true,
                        hasFriendly: false,
                        occupant: ghostAtPosition
                    });
                    return;
                }

                // Can pass through friendlies, but can't end on them
                // Can pass through enemies (will damage), can end on them if they'd die
                validNext.push({
                    q: next.q,
                    r: next.r,
                    hasEnemy: occupant && occupant.player !== piece.player,
                    hasFriendly: occupant && occupant.player === piece.player,
                    occupant: occupant
                });
            });

            return validNext;
        }

        function calculateDamagePath(piece, path) {
            // Calculate which enemies would be damaged along this path
            const damagePath = [];
            path.forEach(step => {
                const occupant = getPieceAt(step.q, step.r);
                if (occupant && occupant.player !== piece.player) {
                    damagePath.push({ q: step.q, r: step.r, piece: occupant });
                }
            });
            return damagePath;
        }

        function canKillWithRam(attackingPiece, targetPiece, damageTotal) {
            if (PIECE_TYPES[targetPiece.type].isKing) {
                return targetPiece.pinned; // King can only die if pinned
            }
            const ramDamage = gameState.unitConfigs[attackingPiece.type].ramDamage;
            return targetPiece.hp <= damageTotal * ramDamage;
        }

        function getGhostAt(q, r) {
            if (!gameState.ghosts) return null;
            return gameState.ghosts.find(g => g.q === q && g.r === r);
        }

        function getPieceAt(q, r) {
            return gameState.pieces.find(p => p.alive && p.q === q && p.r === r);
        }

        // Simulate killing pieces along path and check if destination would still be killable
        function simulateMoveAndValidate(pieceIndex, targetQ, targetR, move, ramDamage) {
            const piece = gameState.pieces[pieceIndex];
            const destOccupant = getPieceAt(targetQ, targetR);

            // If no destination enemy, move is valid
            if (!destOccupant || destOccupant.player === piece.player) {
                return true;
            }

            // Create list of pieces that would be killed along the path (excluding destination)
            const piecesToKill = [];
            if (move.damagePath) {
                move.damagePath.forEach(pos => {
                    // Skip destination - it will be handled separately
                    if (pos.q === targetQ && pos.r === targetR) return;

                    const targetsAtPos = gameState.pieces.filter(p => p.alive && p.q === pos.q && p.r === pos.r && p.player !== piece.player);
                    if (targetsAtPos.length > 0) {
                        // Only need to add one piece from the cell; simulateMoveAndValidate's logic
                        // will ideally check all enemies later, but for piecesToKill along the path
                        // we should mark all of them as dead.
                        targetsAtPos.forEach(target => {
                            if (target.pinned || canKillWithRam(piece, target, 1)) {
                                piecesToKill.push(target);
                            }
                        });
                    }
                });
            }

            // Temporarily mark pieces as dead to simulate the move
            const originalAliveStates = new Map();
            piecesToKill.forEach(target => {
                originalAliveStates.set(target, target.alive);
                target.alive = false;
            });

            // Recalculate pins with simulated kills
            updatePins();

            // Check if destination would still be killable after simulated kills
            // We must check if ALL enemies at destination would die
            const destEnemies = gameState.pieces.filter(p => p.alive && p.q === targetQ && p.r === targetR && p.player !== piece.player);

            if (destEnemies.length === 0) {
                // Restore original states
                originalAliveStates.forEach((alive, target) => {
                    target.alive = alive;
                });
                updatePins();
                return true; // Destination is gone or friendly, move is valid
            }

            const totalDamageInstances = 1; // Destination always takes 1 instance of damage
            const attackerIndex = pieceIndex;

            // ALL enemies at destination must be killable for the move to be valid
            const allEnemiesWillDie = destEnemies.every(enemy => {
                const occupantIndex = gameState.pieces.indexOf(enemy);
                const isPinningPiece = occupantIndex >= 0 &&
                    gameState.pinningMap.has(occupantIndex) &&
                    gameState.pinningMap.get(occupantIndex).has(attackerIndex);

                let enemyWouldDie = false;

                // Check if target would still be pinned without attacker
                if (enemy.pinned && attackerIndex !== null) {
                    const stillPinnedWithoutAttacker = isStillPinnedWithoutAttacker(enemy, attackerIndex);
                    if (stillPinnedWithoutAttacker) {
                        // Still pinned without attacker - insta-kill allowed
                        enemyWouldDie = true;
                    } else {
                        // Not pinned without attacker - must kill with damage
                        enemyWouldDie = canKillWithRam(piece, enemy, totalDamageInstances);
                    }
                } else if (enemy.pinned) {
                    // Target is pinned, no attacker specified - insta-kill
                    enemyWouldDie = true;
                } else {
                    // Not pinned - must kill with damage
                    enemyWouldDie = canKillWithRam(piece, enemy, totalDamageInstances);
                }

                // Handle King special case
                if (PIECE_TYPES[enemy.type].isKing) {
                    if (enemy.pinned && isPinningPiece) {
                        // Attacker is pinning King - check if still pinned without attacker
                        const stillPinnedWithoutAttacker = isStillPinnedWithoutAttacker(enemy, attackerIndex);
                        if (stillPinnedWithoutAttacker) {
                            enemyWouldDie = true;
                        } else {
                            enemyWouldDie = enemy.hp <= totalDamageInstances * ramDamage;
                        }
                    } else if (enemy.pinned) {
                        enemyWouldDie = true;
                    } else {
                        enemyWouldDie = false;
                    }
                }

                return enemyWouldDie;
            });

            // Restore original states
            originalAliveStates.forEach((alive, target) => {
                target.alive = alive;
            });
            updatePins();

            return allEnemiesWillDie;
        }

        function executeMove(pieceIndex, targetQ, targetR, move) {
            const piece = gameState.pieces[pieceIndex];
            const destOccupant = getPieceAt(targetQ, targetR);
            const ramDamage = gameState.unitConfigs[piece.type].ramDamage;

            // Validate the entire move by simulating it first
            if (!simulateMoveAndValidate(pieceIndex, targetQ, targetR, move, ramDamage)) {
                // Invalid move - don't execute anything
                addLog('Cannot land on enemy that would survive!', 'system');
                return false;
            }

            // Now that validation passed, apply damage along path (excluding destination)
            const piecesToDamage = [];
            if (move.damagePath) {
                move.damagePath.forEach(pos => {
                    // Skip destination - it will be handled separately
                    if (pos.q === targetQ && pos.r === targetR) return;

                    const targets = gameState.pieces.filter(p => p.alive && p.q === pos.q && p.r === pos.r && p.player !== piece.player);
                    if (targets.length > 0) {
                        // Add only one piece per location; applyDamage will handle all occupants
                        piecesToDamage.push(targets[0]);
                    }
                });
            }

            // Apply damage to pieces along path (not destination)
            piecesToDamage.forEach(target => {
                applyDamage(target, ramDamage, pieceIndex);
                // Recalculate pins after each kill (pinned pieces might have been killed)
                updatePins();
            });

            // Handle enemy at destination (we've already validated it will die)
            // Note: applyDamage now automatically hits all pieces at the location, 
            // so calling it once on any occupant is enough to hit both ghost and summoner.
            if (destOccupant && destOccupant.player !== piece.player) {
                applyDamage(destOccupant, ramDamage, pieceIndex);
                // Recalculate pins after damage/kill
                updatePins();

                // Double-check that no enemies remain at destination
                const survivors = gameState.pieces.filter(p => p.alive && p.q === targetQ && p.r === targetR && p.player !== piece.player);
                if (survivors.length > 0) {
                    console.error('Move validation error - destination survived');
                    addLog('Cannot land on enemy that would survive!', 'system');
                    return false;
                }
            }

            // Only move the piece if we got here (all validations passed and destination died if it was an enemy)
            piece.q = targetQ;
            piece.r = targetR;

            // Check for Archer Ascension (reaching outer ring)
            if (piece.type === 'ARCHER' && !piece.altMoveUnlocked) {
                if (getRing(targetQ, targetR) === BOARD_RADIUS) {
                    piece.altMoveUnlocked = true;
                    addLog('ARCHER reached the edge! Shoot Arrow Unlocked.', 'system');
                }
            }

            addLog(`${piece.player === 1 ? 'P1' : 'P2'} ${PIECE_TYPES[piece.type].name} moves to (${targetQ}, ${targetR})`, piece.player);

            // Check victory
            if (targetQ === 0 && targetR === 0 && PIECE_TYPES[piece.type].isKing) {
                endGame(piece.player, 'throne');
                return true;
            }

            // Update pins after move
            updatePins();

            // Process any queued bomb detonations now that the piece has moved
            processPendingBombDetonations();

            // Check army elimination
            checkArmyElimination();

            return true;
        }

        // Check if a piece would still be pinned without the attacker's involvement
        function isStillPinnedWithoutAttacker(targetPiece, attackerIndex) {
            if (!targetPiece || !targetPiece.alive) return false;
            if (attackerIndex === null) return targetPiece.pinned;

            // Find target index using coordinates instead of index (more reliable)
            // Only consider alive pieces to avoid finding dead pieces at same position
            const targetIndex = gameState.pieces.findIndex(p => p.alive && p.q === targetPiece.q && p.r === targetPiece.r);
            if (targetIndex < 0) return false;

            // If attacker is the target itself, removing attacker removes target, so target can't be pinned
            if (targetIndex === attackerIndex) return false;

            // Save current state
            const savedPieces = JSON.parse(JSON.stringify(gameState.pieces));
            const savedPinningPaths = [...gameState.pinningPaths];
            const savedPinningMap = new Map(gameState.pinningMap);

            // Temporarily remove the attacker (mark as not alive for pinning calculation)
            const attacker = gameState.pieces[attackerIndex];
            const attackerWasAlive = attacker.alive;
            attacker.alive = false;

            // Recalculate pins without the attacker using the same logic as updatePins
            // This ensures consistency with the main pinning calculation
            const activePlayer = gameState.currentPlayer;
            const otherPlayer = activePlayer === 1 ? 2 : 1;

            // Reset pin states
            gameState.pieces.forEach(p => {
                if (p.alive) {
                    p.pinned = false;
                }
            });
            gameState.pinningPaths = [];
            gameState.pinningMap.clear();

            // Group pieces by player (attacker is now "dead")
            const piecesByPlayer = { 1: [], 2: [] };
            gameState.pieces.forEach(p => {
                if (p.alive) {
                    piecesByPlayer[p.player].push(p);
                }
            });

            // Step 1: Calculate pinnings from active player (without attacker)
            const activeAllies = piecesByPlayer[activePlayer];
            for (let i = 0; i < activeAllies.length; i++) {
                for (let j = i + 1; j < activeAllies.length; j++) {
                    const ally1 = activeAllies[i];
                    const ally2 = activeAllies[j];
                    const paths = findValidPinningPaths(ally1, ally2, activePlayer);
                    paths.forEach(path => {
                        const ally1Index = gameState.pieces.findIndex(p => p === ally1);
                        const ally2Index = gameState.pieces.findIndex(p => p === ally2);
                        path.forEach(step => {
                            if (step.q === ally1.q && step.r === ally1.r) return;
                            if (step.q === ally2.q && step.r === ally2.r) return;
                            const enemy = getPieceAt(step.q, step.r);
                            if (enemy && enemy.player !== activePlayer && enemy.alive) {
                                enemy.pinned = true;
                                const enemyIndex = gameState.pieces.findIndex(p => p === enemy);
                                if (!gameState.pinningMap.has(enemyIndex)) {
                                    gameState.pinningMap.set(enemyIndex, new Set());
                                }
                                gameState.pinningMap.get(enemyIndex).add(ally1Index);
                                gameState.pinningMap.get(enemyIndex).add(ally2Index);
                            }
                        });
                    });
                }
            }

            // Step 2: Calculate pinnings from other player (excluding pinned pieces)
            const otherAllies = piecesByPlayer[otherPlayer].filter(p => !p.pinned);
            for (let i = 0; i < otherAllies.length; i++) {
                for (let j = i + 1; j < otherAllies.length; j++) {
                    const ally1 = otherAllies[i];
                    const ally2 = otherAllies[j];
                    const paths = findValidPinningPaths(ally1, ally2, otherPlayer);
                    paths.forEach(path => {
                        const ally1Index = gameState.pieces.findIndex(p => p === ally1);
                        const ally2Index = gameState.pieces.findIndex(p => p === ally2);
                        path.forEach(step => {
                            if (step.q === ally1.q && step.r === ally1.r) return;
                            if (step.q === ally2.q && step.r === ally2.r) return;
                            const enemy = getPieceAt(step.q, step.r);
                            if (enemy && enemy.player !== otherPlayer && enemy.alive) {
                                enemy.pinned = true;
                                const enemyIndex = gameState.pieces.findIndex(p => p === enemy);
                                if (!gameState.pinningMap.has(enemyIndex)) {
                                    gameState.pinningMap.set(enemyIndex, new Set());
                                }
                                gameState.pinningMap.get(enemyIndex).add(ally1Index);
                                gameState.pinningMap.get(enemyIndex).add(ally2Index);
                            }
                        });
                    });
                }
            }

            // Check if target is still pinned (use the recalculated piece from gameState.pieces)
            // IMPORTANT: Save this value BEFORE restoring state
            // Use coordinates to find target instead of index (more reliable)
            const recalculatedTarget = getPieceAt(targetPiece.q, targetPiece.r);
            const stillPinned = recalculatedTarget && recalculatedTarget.alive && recalculatedTarget.pinned;

            // Restore state by copying properties back to each piece
            // DO NOT replace the array or objects, as that would break existing references
            const parsedSaved = JSON.parse(JSON.stringify(savedPieces));
            for (let i = 0; i < gameState.pieces.length; i++) {
                if (i < parsedSaved.length) {
                    // Restore all properties from saved state
                    Object.assign(gameState.pieces[i], parsedSaved[i]);
                }
            }
            gameState.pinningPaths = savedPinningPaths;
            gameState.pinningMap = savedPinningMap;

            return stillPinned;
        }

        // Centralized death handler to ensure all cleanup (including ghosts) happens correctly
        function handlePieceDeath(piece) {
            const pieceIndex = gameState.pieces.indexOf(piece);
            if (pieceIndex < 0 || !piece.alive) return;

            piece.alive = false;
            detonateBombsOnUnit(pieceIndex);
            detonateBombsOwnedBy(pieceIndex);

            // If a Ghost dies, remove it from the ghosts tracking array
            if (piece.type === 'GHOST') {
                gameState.ghosts = gameState.ghosts.filter(g =>
                    !(g.q === piece.q && g.r === piece.r && g.owner === piece.summonerIndex)
                );
            }

            // Snake death no longer removes its summoned ghosts.
        }

        function applyDamage(piece, damage, attackerIndex = null) {
            if (gameState.phase === 'ended') return;

            // Find ALL pieces at this location to handle Ghost + Summoner overlap
            // We use coordinates to find everyone sharing the cell
            const q = piece.q;
            const r = piece.r;

            // Collect all alive targets at this location BEFORE starting damage
            const targets = gameState.pieces.filter(p => p.alive && p.q === q && p.r === r);

            targets.forEach(actualPiece => {
                if (gameState.phase === 'ended') return;

                // Find the piece index using reference (most reliable)
                const pieceIndex = gameState.pieces.indexOf(actualPiece);
                if (pieceIndex < 0 || !actualPiece.alive) return;

                // Check if the attacker is one of the pieces pinning this target
                const isPinningPiece = attackerIndex !== null &&
                    gameState.pinningMap.has(pieceIndex) &&
                    gameState.pinningMap.get(pieceIndex).has(attackerIndex);

                // Check if piece would still be pinned without the attacker
                if (actualPiece.pinned) {
                    if (attackerIndex !== null) {
                        const stillPinnedWithoutAttacker = isStillPinnedWithoutAttacker(actualPiece, attackerIndex);
                        if (stillPinnedWithoutAttacker) {
                            handlePieceDeath(actualPiece);
                            if (PIECE_TYPES[actualPiece.type].isKing) {
                                addLog(`${actualPiece.player === 1 ? 'P1' : 'P2'} King destroyed (pinned)!`, 'system');
                                endGame(actualPiece.player === 1 ? 2 : 1, 'kingkill');
                            } else {
                                addLog(`${actualPiece.player === 1 ? 'P1' : 'P2'} ${PIECE_TYPES[actualPiece.type].name} destroyed (pinned)`, actualPiece.player);
                            }
                            return;
                        }
                    } else {
                        handlePieceDeath(actualPiece);
                        if (PIECE_TYPES[actualPiece.type].isKing) {
                            addLog(`${actualPiece.player === 1 ? 'P1' : 'P2'} King destroyed (pinned)!`, 'system');
                            endGame(actualPiece.player === 1 ? 2 : 1, 'kingkill');
                        } else {
                            addLog(`${actualPiece.player === 1 ? 'P1' : 'P2'} ${PIECE_TYPES[actualPiece.type].name} destroyed (pinned)`, actualPiece.player);
                        }
                        return;
                    }
                }

                // Handle King special case
                if (PIECE_TYPES[actualPiece.type].isKing) {
                    if (!actualPiece.pinned) return;
                    actualPiece.hp -= damage;
                    if (actualPiece.hp <= 0) {
                        handlePieceDeath(actualPiece);
                        addLog(`${actualPiece.player === 1 ? 'P1' : 'P2'} King destroyed!`, 'system');
                        endGame(actualPiece.player === 1 ? 2 : 1, 'kingkill');
                    }
                    return;
                }

                actualPiece.hp -= damage;
                if (actualPiece.hp <= 0) {
                    handlePieceDeath(actualPiece);
                    addLog(`${actualPiece.player === 1 ? 'P1' : 'P2'} ${PIECE_TYPES[actualPiece.type].name} destroyed`, actualPiece.player);
                }
            });
        }

        function updatePins() {
            const activePlayer = gameState.currentPlayer;
            const otherPlayer = activePlayer === 1 ? 2 : 1;

            // Reset all pin states
            gameState.pieces.forEach(piece => {
                if (piece.alive) {
                    piece.pinned = false;
                }
            });

            // Clear pinning paths and pinning map
            gameState.pinningPaths = [];
            gameState.pinningMap.clear();

            // Group pieces by player
            const piecesByPlayer = { 1: [], 2: [] };
            gameState.pieces.forEach(piece => {
                if (piece.alive) {
                    piecesByPlayer[piece.player].push(piece);
                }
            });

            // Step 1: Calculate pinnings from active player
            const activeAllies = piecesByPlayer[activePlayer];
            const activeEnemies = piecesByPlayer[otherPlayer];

            // Check all pairs of allies from the active player
            for (let i = 0; i < activeAllies.length; i++) {
                for (let j = i + 1; j < activeAllies.length; j++) {
                    const ally1 = activeAllies[i];
                    const ally2 = activeAllies[j];

                    // Find all valid paths between these allies
                    const paths = findValidPinningPaths(ally1, ally2, activePlayer);

                    paths.forEach(path => {
                        // Store this pinning path for visualization (with player info)
                        gameState.pinningPaths.push({ path: path, player: activePlayer });

                        // Find the indices of the pinning allies
                        const ally1Index = gameState.pieces.findIndex(p => p === ally1);
                        const ally2Index = gameState.pieces.findIndex(p => p === ally2);

                        // Mark all enemies on this path as pinned and track which allies are pinning them
                        path.forEach(step => {
                            if (step.q === ally1.q && step.r === ally1.r) return;
                            if (step.q === ally2.q && step.r === ally2.r) return;

                            const enemies = gameState.pieces.filter(p => p.alive && p.q === step.q && p.r === step.r && p.player !== activePlayer);
                            enemies.forEach(enemy => {
                                enemy.pinned = true;

                                // Track which allies are pinning this enemy
                                const enemyIndex = gameState.pieces.indexOf(enemy);
                                if (!gameState.pinningMap.has(enemyIndex)) {
                                    gameState.pinningMap.set(enemyIndex, new Set());
                                }
                                gameState.pinningMap.get(enemyIndex).add(ally1Index);
                                gameState.pinningMap.get(enemyIndex).add(ally2Index);
                            });
                        });
                    });
                }
            }

            // Step 2: Calculate pinnings from other player
            // Pieces already pinned cannot be used to pin other pieces
            const otherAllies = piecesByPlayer[otherPlayer].filter(piece => !piece.pinned);
            const otherEnemies = piecesByPlayer[activePlayer];

            // Check all pairs of allies from the other player (excluding pinned pieces)
            for (let i = 0; i < otherAllies.length; i++) {
                for (let j = i + 1; j < otherAllies.length; j++) {
                    const ally1 = otherAllies[i];
                    const ally2 = otherAllies[j];

                    // Find all valid paths between these allies
                    const paths = findValidPinningPaths(ally1, ally2, otherPlayer);

                    paths.forEach(path => {
                        // Store this pinning path for visualization (with player info)
                        gameState.pinningPaths.push({ path: path, player: otherPlayer });

                        // Find the indices of the pinning allies
                        const ally1Index = gameState.pieces.findIndex(p => p === ally1);
                        const ally2Index = gameState.pieces.findIndex(p => p === ally2);

                        // Mark all enemies on this path as pinned and track which allies are pinning them
                        path.forEach(step => {
                            if (step.q === ally1.q && step.r === ally1.r) return;
                            if (step.q === ally2.q && step.r === ally2.r) return;

                            const enemies = gameState.pieces.filter(p => p.alive && p.q === step.q && p.r === step.r && p.player !== otherPlayer);
                            enemies.forEach(enemy => {
                                enemy.pinned = true;

                                // Track which allies are pinning this enemy
                                const enemyIndex = gameState.pieces.indexOf(enemy);
                                if (!gameState.pinningMap.has(enemyIndex)) {
                                    gameState.pinningMap.set(enemyIndex, new Set());
                                }
                                gameState.pinningMap.get(enemyIndex).add(ally1Index);
                                gameState.pinningMap.get(enemyIndex).add(ally2Index);
                            });
                        });
                    });
                }
            }

            // Render pinning paths
            renderPinningPaths();

            // Check if all enemies are pinned (win condition)
            checkAllEnemiesPinned();
        }

        // Calculate preview pinning paths for a simulated move
        function calculatePreviewPinning(pieceIndex, destination, path) {
            // Save current state
            const savedPieces = JSON.parse(JSON.stringify(gameState.pieces));
            const savedPinningPaths = [...gameState.pinningPaths];
            const savedPinningMap = new Map(gameState.pinningMap);

            const piece = gameState.pieces[pieceIndex];
            const config = gameState.unitConfigs[piece.type];
            const ramDamage = config.ramDamage;
            const destOccupant = getPieceAt(destination.q, destination.r);

            // Simulate damage along path (excluding destination)
            const damagePath = calculateDamagePath(piece, path);
            damagePath.forEach(pos => {
                if (pos.q === destination.q && pos.r === destination.r) return;
                const target = pos.piece || getPieceAt(pos.q, pos.r);
                if (target && target.player !== piece.player) {
                    // Apply damage - kill if HP would drop to 0 or below
                    if (target.hp <= ramDamage) {
                        target.alive = false;
                    } else {
                        target.hp -= ramDamage;
                    }
                }
            });

            // Kill destination if enemy
            if (destOccupant && destOccupant.player !== piece.player) {
                destOccupant.alive = false;
            }

            // Move the piece
            piece.q = destination.q;
            piece.r = destination.r;

            // Calculate pins after simulated move using two-step process
            const activePlayer = gameState.currentPlayer;
            const otherPlayer = activePlayer === 1 ? 2 : 1;
            const previewPaths = [];

            // Reset pin states for preview calculation
            gameState.pieces.forEach(p => {
                if (p.alive) {
                    p.pinned = false;
                }
            });

            // Group pieces by player
            const piecesByPlayer = { 1: [], 2: [] };
            gameState.pieces.forEach(p => {
                if (p.alive) {
                    piecesByPlayer[p.player].push(p);
                }
            });

            // Step 1: Calculate pinnings from active player
            const activeAllies = piecesByPlayer[activePlayer];
            const activeEnemies = piecesByPlayer[otherPlayer];

            // Check all pairs of allies from the active player
            for (let i = 0; i < activeAllies.length; i++) {
                for (let j = i + 1; j < activeAllies.length; j++) {
                    const ally1 = activeAllies[i];
                    const ally2 = activeAllies[j];

                    // Find all valid paths between these allies
                    const paths = findValidPinningPaths(ally1, ally2, activePlayer);

                    paths.forEach(path => {
                        previewPaths.push({ path: path, player: activePlayer });

                        // Mark enemies on this path as pinned
                        path.forEach(step => {
                            if (step.q === ally1.q && step.r === ally1.r) return;
                            if (step.q === ally2.q && step.r === ally2.r) return;

                            const enemy = getPieceAt(step.q, step.r);
                            if (enemy && enemy.player !== activePlayer && enemy.alive) {
                                enemy.pinned = true;
                            }
                        });
                    });
                }
            }

            // Step 2: Calculate pinnings from other player
            // Pieces already pinned cannot be used to pin other pieces
            const otherAllies = piecesByPlayer[otherPlayer].filter(p => !p.pinned);
            const otherEnemies = piecesByPlayer[activePlayer];

            // Check all pairs of allies from the other player (excluding pinned pieces)
            for (let i = 0; i < otherAllies.length; i++) {
                for (let j = i + 1; j < otherAllies.length; j++) {
                    const ally1 = otherAllies[i];
                    const ally2 = otherAllies[j];

                    // Find all valid paths between these allies
                    const paths = findValidPinningPaths(ally1, ally2, otherPlayer);

                    paths.forEach(path => {
                        previewPaths.push({ path: path, player: otherPlayer });

                        // Mark enemies on this path as pinned
                        path.forEach(step => {
                            if (step.q === ally1.q && step.r === ally1.r) return;
                            if (step.q === ally2.q && step.r === ally2.r) return;

                            const enemy = getPieceAt(step.q, step.r);
                            if (enemy && enemy.player !== otherPlayer && enemy.alive) {
                                enemy.pinned = true;
                            }
                        });
                    });
                }
            }

            // Restore original state
            gameState.pieces = JSON.parse(JSON.stringify(savedPieces));
            gameState.pinningPaths = savedPinningPaths;
            gameState.pinningMap = savedPinningMap;

            return previewPaths;
        }

        function renderPinningPaths() {
            const pinningGroup = document.getElementById('pinning-paths-group');
            if (!pinningGroup) return;

            // Clear existing paths
            pinningGroup.innerHTML = '';

            // If there are preview paths, only show preview (hide current pinning)
            if (gameState.previewPinningPaths.length > 0) {
                // Render preview pinning paths using player colors (red/blue)
                gameState.previewPinningPaths.forEach(pinningData => {
                    const path = pinningData.path;
                    const player = pinningData.player;

                    if (path.length < 2) return;

                    // Create a path element for preview
                    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                    // Build path data
                    let pathData = '';
                    path.forEach((step, index) => {
                        const { x, y } = hexToPixel(step.q, step.r);
                        if (index === 0) {
                            pathData += `M ${x} ${y}`;
                        } else {
                            pathData += ` L ${x} ${y}`;
                        }
                    });

                    // Use player team colors for preview pinning
                    // Player 1: brighter red, Player 2: brighter blue for preview
                    const previewColor = player === 1 ? '#ff6b6b' : '#6bb5ff';
                    const opacity = '0.95';
                    const strokeWidth = '5';

                    pathElement.setAttribute('d', pathData);
                    pathElement.setAttribute('stroke', previewColor);
                    pathElement.setAttribute('stroke-width', strokeWidth);
                    pathElement.setAttribute('fill', 'none');
                    pathElement.setAttribute('opacity', opacity);
                    pathElement.setAttribute('stroke-dasharray', '4 4'); // Dashed line for preview
                    pathElement.style.pointerEvents = 'none';
                    pathElement.classList.add('preview-pin');

                    pinningGroup.appendChild(pathElement);
                });
            } else {
                // No preview - render current pinning paths (solid lines)
                gameState.pinningPaths.forEach(pinningData => {
                    const path = pinningData.path;
                    const player = pinningData.player;

                    if (path.length < 2) return;

                    // Create a path element
                    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                    // Build path data
                    let pathData = '';
                    path.forEach((step, index) => {
                        const { x, y } = hexToPixel(step.q, step.r);
                        if (index === 0) {
                            pathData += `M ${x} ${y}`;
                        } else {
                            pathData += ` L ${x} ${y}`;
                        }
                    });

                    // Use team color for the pin line
                    const teamColor = player === 1 ? 'var(--player1)' : 'var(--player2)';
                    // Make both pins highly visible
                    const opacity = '0.9';
                    const strokeWidth = '5';

                    pathElement.setAttribute('d', pathData);
                    pathElement.setAttribute('stroke', teamColor);
                    pathElement.setAttribute('stroke-width', strokeWidth);
                    pathElement.setAttribute('fill', 'none');
                    pathElement.setAttribute('opacity', opacity);
                    pathElement.setAttribute('stroke-dasharray', '4 4');
                    pathElement.style.pointerEvents = 'none';

                    pinningGroup.appendChild(pathElement);
                });
            }

            // Ensure piece-group is always on top by moving it to the end
            const svg = document.getElementById('game-board');
            const pieceGroup = document.getElementById('piece-group');
            if (svg && pieceGroup) {
                svg.appendChild(pieceGroup);
            }
        }

        // Get relative direction from entry direction
        // Returns: { straight, left, right } as direction indices
        // When entering from entryDir, valid exits are:
        // - Straight: opposite side (entryDir + 3) % 6
        // - Left: one step counterclockwise from straight: (straight + 1) % 6 = (entryDir + 4) % 6
        // - Right: one step clockwise from straight: (straight - 1 + 6) % 6 = (entryDir + 2) % 6
        function getRelativeDirections(entryDir) {
            const straight = (entryDir + 3) % 6; // Opposite
            const left = (entryDir + 4) % 6;     // One step left (counterclockwise) of straight
            const right = (entryDir + 2) % 6;    // One step right (clockwise) of straight
            return { straight, left, right };
        }

        // Determine turn direction: 'straight', 'left', or 'right'
        function getTurnDirection(entryDir, exitDir) {
            const rel = getRelativeDirections(entryDir);
            if (exitDir === rel.straight) return 'straight';
            if (exitDir === rel.left) return 'left';
            if (exitDir === rel.right) return 'right';
            return null; // Invalid (backward or sideways)
        }

        // Update lean state based on turn
        // lean: 'none' | 'left' | 'right'
        // turn: 'straight' | 'left' | 'right'
        function updateLean(lean, turn) {
            if (turn === 'straight') return lean; // Straight doesn't change lean
            if (turn === 'left') {
                if (lean === 'left') return null; // Can't turn left twice
                return 'left'; // Now leaning left
            }
            if (turn === 'right') {
                if (lean === 'right') return null; // Can't turn right twice
                return 'right'; // Now leaning right
            }
            return null;
        }

        function findValidPinningPaths(start, end, pinningPlayer = null) {
            const paths = [];
            // Use provided pinningPlayer or default to currentPlayer for backwards compatibility
            const activePlayer = pinningPlayer !== null ? pinningPlayer : gameState.currentPlayer;
            const enemies = gameState.pieces.filter(p =>
                p.alive && p.player !== activePlayer
            );

            // Verify that start and end are both allies of the pinning player
            const startPiece = getPieceAt(start.q, start.r);
            const endPiece = getPieceAt(end.q, end.r);
            if (!startPiece || !startPiece.alive || startPiece.player !== activePlayer) return paths;
            if (!endPiece || !endPiece.alive || endPiece.player !== activePlayer) return paths;

            // Try all possible starting directions from start hex
            for (let startDir = 0; startDir < 6; startDir++) {
                const neighbor = hexNeighbor(start.q, start.r, startDir);
                if (!isValidHex(neighbor.q, neighbor.r)) continue;

                // Check if first step has an enemy (path must travel through enemies)
                const firstStepPiece = getPieceAt(neighbor.q, neighbor.r);
                if (!firstStepPiece || !firstStepPiece.alive || firstStepPiece.player === activePlayer) {
                    continue; // Must start with an enemy
                }

                // When we move from start to neighbor in direction startDir,
                // the neighbor sees us entering from the opposite direction: (startDir + 3) % 6
                const entryDirForNeighbor = (startDir + 3) % 6;

                // Start pathfinding with entry direction from neighbor's perspective
                findPathWithRules(
                    neighbor.q, neighbor.r,
                    entryDirForNeighbor,
                    end.q, end.r,
                    [{ q: start.q, r: start.r }, { q: neighbor.q, r: neighbor.r }],
                    'none' // Initial lean state
                );
            }

            function findPathWithRules(q, r, entryDir, targetQ, targetR, path, lean) {
                const currentPath = [...path, { q, r }];

                // Limit path length to prevent infinite loops
                if (currentPath.length >= 20) return;

                // Get valid exit directions (relative to entry)
                const rel = getRelativeDirections(entryDir);
                const validExits = [rel.straight, rel.left, rel.right];

                // Try each valid exit direction
                for (const exitDir of validExits) {
                    const neighbor = hexNeighbor(q, r, exitDir);
                    if (!isValidHex(neighbor.q, neighbor.r)) continue;

                    // Check if already in path (no backtracking)
                    if (currentPath.some(step => step.q === neighbor.q && step.r === neighbor.r)) continue;

                    // Determine turn direction
                    const turn = getTurnDirection(entryDir, exitDir);
                    if (turn === null) continue; // Invalid direction

                    // Update lean state
                    const newLean = updateLean(lean, turn);
                    if (newLean === null) continue; // Violates zig-zag rule

                    // Check if this neighbor is the target (must check before checking occupant)
                    if (neighbor.q === targetQ && neighbor.r === targetR) {
                        // Reached target! Create final path and validate
                        const finalPath = [...currentPath, { q: neighbor.q, r: neighbor.r }];
                        if (isPathValidForPinning(finalPath, activePlayer, enemies)) {
                            paths.push(finalPath);
                        }
                        continue; // Don't continue from target
                    }

                    // Check if this cell has an enemy (path must travel through enemies)
                    const occupant = getPieceAt(neighbor.q, neighbor.r);
                    if (!occupant || !occupant.alive) continue; // Must have a piece
                    if (occupant.player === activePlayer) continue; // Can't be an ally (except endpoints which we already checked above)

                    // Continue pathfinding
                    // Entry direction for next hex is the direction we came from (opposite of exitDir)
                    const nextEntryDir = (exitDir + 3) % 6;
                    findPathWithRules(
                        neighbor.q, neighbor.r,
                        nextEntryDir,
                        targetQ, targetR,
                        currentPath,
                        newLean
                    );
                }
            }

            return paths;
        }

        function getDirectionFrom(from, to) {
            // Find which direction from 'from' to 'to'
            for (let dir = 0; dir < 6; dir++) {
                const neighbor = hexNeighbor(from.q, from.r, dir);
                if (neighbor.q === to.q && neighbor.r === to.r) {
                    return dir;
                }
            }
            return -1;
        }

        // Verify that a path travels exclusively through enemies (excluding endpoints which are allies)
        function isPathValidForPinning(path, activePlayer, enemies) {
            // Path must have at least 3 cells (start ally, middle enemies, end ally)
            if (path.length < 3) return false;

            // Check that endpoints are allies
            const startPiece = getPieceAt(path[0].q, path[0].r);
            const endPiece = getPieceAt(path[path.length - 1].q, path[path.length - 1].r);
            if (!startPiece || !startPiece.alive || startPiece.player !== activePlayer) return false;
            if (!endPiece || !endPiece.alive || endPiece.player !== activePlayer) return false;

            // Check that every cell along the path (excluding endpoints) has an enemy
            for (let i = 1; i < path.length - 1; i++) {
                const step = path[i];
                const occupant = getPieceAt(step.q, step.r);

                // Must have an enemy at this position
                if (!occupant || !occupant.alive) return false;
                if (occupant.player === activePlayer) return false; // Can't be an ally
                if (!enemies.includes(occupant)) return false; // Must be in enemies list
            }

            return true;
        }

        function isPathPinned(path, enemies) {
            // Legacy function - now just checks that middle cells have enemies
            // The pathfinding already ensures paths travel through enemies, but keep this for safety
            for (let i = 1; i < path.length - 1; i++) {
                const step = path[i];
                const occupant = getPieceAt(step.q, step.r);

                // Must have an enemy at this position
                if (!occupant || !occupant.alive) return false;
                if (!enemies.includes(occupant)) return false;
            }

            return path.length > 2; // Path must have at least 3 cells (start, middle, end)
        }

        function executeRotation(ring, clockwise) {
            const ringHexes = getHexesInRing(ring);
            const piecesInRing = gameState.pieces.filter(p =>
                p.alive && getRing(p.q, p.r) === ring
            );

            // Rotate each piece
            piecesInRing.forEach(piece => {
                const rotated = rotateHexAroundCenter(piece.q, piece.r, clockwise ? 1 : -1);
                piece.q = rotated.q;
                piece.r = rotated.r;
            });

            // Rotate each bomb (cell-based)
            if (gameState.bombs) {
                gameState.bombs.forEach(bomb => {
                    if (bomb.type === 'cell' && getRing(bomb.q, bomb.r) === ring) {
                        const rotated = rotateHexAroundCenter(bomb.q, bomb.r, clockwise ? 1 : -1);
                        bomb.q = rotated.q;
                        bomb.r = rotated.r;
                    }
                });
            }



            // Rotate each ghost
            if (gameState.ghosts) {
                gameState.ghosts.forEach(ghost => {
                    if (getRing(ghost.q, ghost.r) === ring) {
                        const rotated = rotateHexAroundCenter(ghost.q, ghost.r, clockwise ? 1 : -1);
                        ghost.q = rotated.q;
                        ghost.r = rotated.r;
                    }
                });
            }

            addLog(`${gameState.currentPlayer === 1 ? 'P1' : 'P2'} King rotates ring ${ring} ${clockwise ? 'CW' : 'CCW'}`, gameState.currentPlayer);

            // Update pins after rotation
            updatePins();

            // Check for pin + ram kills
            checkPinnedKings();
        }

        function checkPinnedKings() {
            gameState.pieces.forEach(piece => {
                if (piece.alive && PIECE_TYPES[piece.type].isKing && piece.pinned) {
                    // Check if any adjacent enemy can ram
                    // This is evaluated after rotation
                }
            });
        }

        function checkArmyElimination() {
            [1, 2].forEach(player => {
                const nonKingPieces = gameState.pieces.filter(p =>
                    p.player === player && p.alive && !PIECE_TYPES[p.type].isKing && p.type !== 'GHOST'
                );
                if (nonKingPieces.length === 0) {
                    endGame(player === 1 ? 2 : 1, 'elimination');
                }
            });
        }

        function checkAllEnemiesPinned() {
            [1, 2].forEach(player => {
                const enemyPlayer = player === 1 ? 2 : 1;
                const enemyPieces = gameState.pieces.filter(p =>
                    p.player === enemyPlayer && p.alive && p.type !== 'GHOST'
                );

                // If there are no enemy pieces, skip (already handled by elimination check)
                if (enemyPieces.length === 0) return;

                // Check if all enemy pieces are pinned
                const allPinned = enemyPieces.every(piece => piece.pinned);

                if (allPinned) {
                    endGame(player, 'allpinned');
                }
            });
        }

        function endGame(winner, reason) {
            gameState.phase = 'ended';

            const reasons = {
                throne: `Player ${winner} captures the Throne!`,
                kingkill: `Player ${winner} destroys the enemy King!`,
                elimination: `Player ${winner} eliminates all enemy units!`,
                allpinned: `Player ${winner} pins all enemy pieces!`,
                timeout: `Player ${winner} wins on time!`
            };

            if (gameState.timerInterval) cancelAnimationFrame(gameState.timerInterval);
            // Clear bombs on game end
            gameState.bombs = [];
            gameState.pendingBombDetonations = [];
            renderPieces();

            document.getElementById('victory-title').textContent = `Player ${winner} Wins!`;
            document.getElementById('victory-message').textContent = reasons[reason];
            document.getElementById('victory-modal').classList.add('active');

            addLog(`VICTORY: ${reasons[reason]}`, 'system');
        }

        function getPieceActionHistory(pieceIndex) {
            if (!gameState.turnHistory.has(pieceIndex)) {
                gameState.turnHistory.set(pieceIndex, new Set());
            }
            return gameState.turnHistory.get(pieceIndex);
        }

        function canPiecePerformAction(pieceIndex, actionType) {
            if (gameState.actionsRemaining <= 0) return false;
            const piece = gameState.pieces[pieceIndex];
            const history = getPieceActionHistory(pieceIndex);

            if (piece.type === 'PAWN') {
                return history.size === 0;
            }

            return !history.has(actionType);
        }

        function isPieceFullyUsed(pieceIndex) {
            const piece = gameState.pieces[pieceIndex];
            const history = getPieceActionHistory(pieceIndex);

            if (piece.type === 'PAWN') {
                return history.size > 0;
            }

            // Other pieces can move and alt-move
            return history.has('MOVE') && history.has('ALT');
        }

        function useAction(pieceIndex, actionType = 'MOVE') {
            if (gameState.actionsRemaining <= 0) {
                addLog('No actions remaining. End your turn.', 'system');
                return;
            }
            const history = getPieceActionHistory(pieceIndex);
            history.add(actionType);

            if (isPieceFullyUsed(pieceIndex)) {
                gameState.usedPieces.add(pieceIndex);
            }

            gameState.hasAnyPieceMoved = true;
            gameState.actionsRemaining--;

            updateUI();
            updateAutoMoveVisibility();
        }

        function endTurn() {
            if (gameState.pathBuilding) {
                cancelPathBuilding();
            }

            // Clear all pins at the end of the turn
            gameState.pieces.forEach(piece => {
                if (piece.alive) {
                    piece.pinned = false;
                }
            });
            gameState.pinningPaths = [];
            gameState.pinningMap.clear();
            gameState.previewPinningPaths = []; // Clear preview pinning
            gameState.turnHistory.clear();

            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
            gameState.lastTimestamp = performance.now();
            gameState.timerPaused = false;
            if (gameState.timerEnabled && gameState.roundTimeLimit > 0) {
                gameState.roundTimeRemaining[gameState.currentPlayer] = gameState.roundTimeLimit;
            }

            // Expire Force Fields: Remove fields belonging to the player who is about to start their turn
            // (Meaning they lasted through the enemy's turn)
            gameState.forceFields = gameState.forceFields.filter(f => f.player !== gameState.currentPlayer);

            // After the first turn, all players get 2 actions
            if (gameState.isFirstTurn) {
                gameState.isFirstTurn = false;
            }
            gameState.actionsRemaining = gameState.params.actionsPerTurn;

            gameState.usedPieces.clear();
            gameState.selectedPiece = null;
            gameState.validMoves = [];

            updatePins();
            saveTurnSnapshot();

            updateUI();
            updateTimerUI();
            updateArmyDisplay(); // Update army panel to reflect new pinning status
            clearHighlights();
            renderPieces();
            document.getElementById('btn-rotate').style.display = 'none';

            addLog(`--- Player ${gameState.currentPlayer}'s Turn ---`, 'system');

            // Trigger CPU turn if applicable
            if (gameState.gameMode === 'vsCPU' && gameState.currentPlayer === gameState.cpuPlayer) {
                setTimeout(cpuTakeTurn, 800);
            }
        }

        async function cpuTakeTurn() {
            if (gameState.phase !== 'playing') return;
            const myPlayer = gameState.cpuPlayer;

            addLog('CPU thinking...', gameState.currentPlayer);

            // Loop until no actions remaining or game ends
            while (gameState.actionsRemaining > 0 && gameState.phase === 'playing') {
                // SAFETY: Stop if it's no longer my turn (e.g. game reset, or turn ended externally)
                if (gameState.currentPlayer !== myPlayer) return;

                const thoughtTime = 600 + Math.random() * 400; // Random delay for realism
                await new Promise(r => setTimeout(r, thoughtTime));

                // SAFETY: Check again after await
                if (gameState.currentPlayer !== myPlayer || gameState.phase !== 'playing') return;

                // Execute best move
                autoMove();

                // Check if game ended during autoMove (e.g. invalid move causing issues, or win)
                if (gameState.phase !== 'playing') break;
            }

            // End turn automatically - ONLY if it's still my turn
            if (gameState.phase === 'playing' && gameState.currentPlayer === myPlayer) {
                await new Promise(r => setTimeout(r, 600));
                if (gameState.phase === 'playing' && gameState.currentPlayer === myPlayer) {
                    endTurn();
                }
            }
        }

        function saveTurnSnapshot() {
            gameState.turnSnapshot = {
                pieces: JSON.parse(JSON.stringify(gameState.pieces)),
                actionsRemaining: gameState.actionsRemaining,
                hasAnyPieceMoved: gameState.hasAnyPieceMoved,
                forceFields: JSON.parse(JSON.stringify(gameState.forceFields)),
                bombs: JSON.parse(JSON.stringify(gameState.bombs)),
                ghosts: JSON.parse(JSON.stringify(gameState.ghosts)),
                roundTimeRemaining: JSON.parse(JSON.stringify(gameState.roundTimeRemaining)),
                reserveTimeRemaining: JSON.parse(JSON.stringify(gameState.reserveTimeRemaining))
            };
        }

        function resetTurn() {
            if (gameState.phase === 'placement') {
                const player = gameState.currentPlayer;
                const replacableTypes = ['SNAKE', 'SHIELD', 'BOMBER', 'BOXER'];

                // Remove current player's placed pieces from the board
                gameState.pieces = gameState.pieces.filter(piece => {
                    return !(piece.alive && piece.player === player && replacableTypes.includes(piece.type));
                });

                // Reset placement state for current player only
                gameState.placementSelectedType = null;
                gameState.placementRemaining[player] = ['SNAKE', 'SHIELD', 'BOMBER', 'BOXER'];
                gameState.placementPlacedCount[player] = 0;

                updatePins();
                updateUI();
                updateArmyDisplay();
                updatePlacementUI();
                renderPieces();

                addLog(`Player ${player} placement reset.`, 'system');
                return;
            }
            if (!gameState.turnSnapshot) return;

            gameState.pieces = JSON.parse(JSON.stringify(gameState.turnSnapshot.pieces));
            gameState.actionsRemaining = gameState.turnSnapshot.actionsRemaining;
            gameState.hasAnyPieceMoved = gameState.turnSnapshot.hasAnyPieceMoved;
            // Do not reset timers on turn reset
            // Restore bombs from snapshot (removes bombs placed this turn)
            if (gameState.turnSnapshot.bombs) {
                gameState.bombs = JSON.parse(JSON.stringify(gameState.turnSnapshot.bombs));
            } else {
                gameState.bombs = [];
                gameState.pendingBombDetonations = [];
            }
            if (gameState.turnSnapshot.ghosts) {
                gameState.ghosts = JSON.parse(JSON.stringify(gameState.turnSnapshot.ghosts));
            } else {
                gameState.ghosts = [];
            }

            gameState.lastTimestamp = performance.now();

            gameState.usedPieces.clear();
            gameState.turnHistory.clear();
            gameState.selectedPiece = null;
            gameState.validMoves = [];

            if (gameState.pathBuilding) cancelPathBuilding();
            if (gameState.rotationMode) exitRotationMode();
            if (gameState.lanceTargetingMode) exitLanceTargetingMode();
            if (gameState.bombTargetingMode) exitBombTargetingMode();
            if (gameState.boxerSlideMode) exitBoxerSlideMode();

            gameState.forceFields = []; // Reset force fields on turn reset (simple approach) or restore from snapshot if we added it?
            // Snapshot doesn't have forceFields yet. We should add it to snapshot.
            if (gameState.turnSnapshot && gameState.turnSnapshot.forceFields) {
                gameState.forceFields = JSON.parse(JSON.stringify(gameState.turnSnapshot.forceFields));
            } else {
                gameState.forceFields = [];
            }

            updatePins();
            updateUI();
            updateTimerUI();
            updateArmyDisplay();
            clearHighlights();
            updateForceFieldVisuals();
            renderPieces();

            addLog(`Turn reset to start of Player ${gameState.currentPlayer}'s turn.`, 'system');
        }

        // ============================================
        // INPUT HANDLING
        // ============================================

        function handlePlacementClick(q, r) {
            const player = gameState.currentPlayer;
            const selectedType = gameState.placementSelectedType;
            const slots = gameState.placementSlots[player] || [];

            if (!selectedType) {
                addLog('Select a piece to place.', 'system');
                return;
            }

            if (!slots.some(s => s.q === q && s.r === r)) {
                addLog('Must place on the orange ring slots.', 'system');
                return;
            }

            const occupant = getPieceAt(q, r);
            const replacableTypes = ['SNAKE', 'SHIELD', 'BOMBER', 'BOXER'];

            if (!selectedType) {
                if (!occupant) {
                    addLog('Select a piece to place.', 'system');
                    return;
                }
                if (occupant.player !== player || !replacableTypes.includes(occupant.type)) {
                    addLog('That hex is already occupied.', 'system');
                    return;
                }

                // Return the placed piece to the pool
                const removeIndex = gameState.pieces.findIndex(p => p.alive && p.q === occupant.q && p.r === occupant.r);
                if (removeIndex >= 0) {
                    gameState.pieces.splice(removeIndex, 1);
                }
                const remaining = gameState.placementRemaining[player] || [];
                if (!remaining.includes(occupant.type)) {
                    remaining.push(occupant.type);
                }
                gameState.placementRemaining[player] = remaining;
                gameState.placementPlacedCount[player] = Math.max(
                    0,
                    (gameState.placementPlacedCount[player] || 0) - 1
                );

                updatePins();
                renderPieces();
                updateArmyDisplay();
                updatePlacementUI();
                updatePlacementHighlights();
                return;
            }

            if (occupant) {
                if (occupant.player !== player || !replacableTypes.includes(occupant.type)) {
                    addLog('That hex is already occupied.', 'system');
                    return;
                }

                // Replace existing placed piece
                const removeIndex = gameState.pieces.findIndex(p => p.alive && p.q === occupant.q && p.r === occupant.r);
                if (removeIndex >= 0) {
                    gameState.pieces.splice(removeIndex, 1);
                }
                const remaining = gameState.placementRemaining[player] || [];
                if (!remaining.includes(occupant.type)) {
                    remaining.push(occupant.type);
                }
                gameState.placementRemaining[player] = remaining;
                gameState.placementPlacedCount[player] = Math.max(
                    0,
                    (gameState.placementPlacedCount[player] || 0) - 1
                );
            }

            createPiece(selectedType, player, q, r);
            gameState.placementRemaining[player] = (gameState.placementRemaining[player] || []).filter(t => t !== selectedType);
            gameState.placementPlacedCount[player] = (gameState.placementPlacedCount[player] || 0) + 1;
            gameState.placementSelectedType = null;

            updatePins();
            renderPieces();
            updateArmyDisplay();
            updatePlacementUI();

            // Advance placement to next player or start battle
            const otherPlayer = player === 1 ? 2 : 1;
            if (gameState.placementPlacedCount[player] >= 3) {
                if ((gameState.placementPlacedCount[otherPlayer] || 0) >= 3) {
                    startBattleFromPlacement();
                } else {
                    gameState.currentPlayer = otherPlayer;
                    updateUI();
                    updatePlacementUI();
                    addLog(`Player ${gameState.currentPlayer} Placement`, 'system');
                }
            }
        }

        function startBattleFromPlacement() {
            gameState.phase = 'playing';
            gameState.currentPlayer = 1;
            gameState.isFirstTurn = true;
            gameState.actionsRemaining = 1;
            gameState.usedPieces.clear();
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            gameState.placementSelectedType = null;

            if (gameState.timerEnabled) {
                gameState.timerPaused = false;
                gameState.lastTimestamp = performance.now();
                if (gameState.timerInterval) cancelAnimationFrame(gameState.timerInterval);
                requestAnimationFrame(gameLoop);
            }

            updatePins();
            saveTurnSnapshot();
            updateUI();
            updateTimerUI();
            renderPieces();
            updateArmyDisplay();
            addLog('=== BATTLE STARTED ===', 'system');
            addLog(`Player 1's Turn (1 action)`, 'system');
        }

        function activateBoxerSlide(pieceIndex) {
            const piece = gameState.pieces[pieceIndex];
            if (piece.pinned) {
                addLog('Pinned pieces cannot move or take actions!', 'system');
                return;
            }
            if (!canPiecePerformAction(pieceIndex, 'ALT')) {
                addLog('Alt action already used this turn.', 'system');
                return;
            }
            gameState.boxerSlideMode = true;
            gameState.boxerSlideSource = pieceIndex;
            gameState.selectedPiece = pieceIndex;
            addLog('Select an adjacent unit to slide.', 'system');

            clearHighlights();
            for (let dir = 0; dir < 6; dir++) {
                const n = hexNeighbor(piece.q, piece.r, dir);
                if (!isValidHex(n.q, n.r)) continue;
                const target = getPieceAt(n.q, n.r);
                if (target) {
                    const hex = document.querySelector(`.hex[data-q="${n.q}"][data-r="${n.r}"]`);
                    if (hex) hex.classList.add('valid-move');
                }
            }
        }

        function exitBoxerSlideMode() {
            gameState.boxerSlideMode = false;
            gameState.boxerSlideSource = null;
            clearHighlights();
            renderPieces();
        }

        function executeBoxerSlide(boxerIndex, targetIndex) {
            const boxer = gameState.pieces[boxerIndex];
            const target = gameState.pieces[targetIndex];
            if (!boxer || !target) return;

            // Determine direction from boxer to target
            let direction = -1;
            for (let dir = 0; dir < 6; dir++) {
                const n = hexNeighbor(boxer.q, boxer.r, dir);
                if (n.q === target.q && n.r === target.r) {
                    direction = dir;
                    break;
                }
            }
            if (direction < 0) {
                addLog('Slide target must be adjacent.', 'system');
                exitBoxerSlideMode();
                return;
            }

            // Slide target in the same direction away from boxer
            let current = { q: target.q, r: target.r };
            let next = hexNeighbor(current.q, current.r, direction);
            let moved = false;
            let insideForceField = isInsideForceField(current.q, current.r);

            while (isValidHex(next.q, next.r) && !getPieceAt(next.q, next.r)) {
                const nextInside = isInsideForceField(next.q, next.r);
                // Stop at force field boundary from either side
                if (nextInside !== insideForceField) break;
                current = { q: next.q, r: next.r };
                insideForceField = nextInside;
                next = hexNeighbor(current.q, current.r, direction);
                moved = true;
            }

            if (!moved) {
                addLog('No space to slide.', 'system');
                exitBoxerSlideMode();
                return;
            }

            // Move all alive pieces sharing the target cell together
            const oldStackQ = target.q;
            const oldStackR = target.r;
            const stackedUnits = gameState.pieces.filter(p => p.alive && p.q === oldStackQ && p.r === oldStackR);
            stackedUnits.forEach(unit => {
                unit.q = current.q;
                unit.r = current.r;
            });
            addLog(`${PIECE_TYPES[boxer.type].name} slides ${stackedUnits.length > 1 ? 'stack' : PIECE_TYPES[target.type].name} to (${current.q}, ${current.r})`, boxer.player);

            // Keep ghost metadata in sync for all moved ghosts
            stackedUnits.forEach(unit => {
                if (unit.type === 'GHOST') {
                    const matchingEntries = gameState.ghosts.filter(g =>
                        g.owner === unit.summonerIndex && g.q === oldStackQ && g.r === oldStackR
                    );
                    matchingEntries.forEach(entry => {
                        entry.q = unit.q;
                        entry.r = unit.r;
                    });
                }
            });

            // Post-move effects for all moved units
            stackedUnits.forEach(unit => {
                if (unit.type === 'ARCHER' && !unit.altMoveUnlocked) {
                    if (getRing(unit.q, unit.r) === BOARD_RADIUS) {
                        unit.altMoveUnlocked = true;
                        addLog('ARCHER reached the edge! Shoot Arrow Unlocked.', 'system');
                    }
                }
            });

            // Check victory (any moved King reaching throne)
            const kingOnThrone = stackedUnits.find(unit =>
                PIECE_TYPES[unit.type].isKing && unit.q === 0 && unit.r === 0
            );
            if (kingOnThrone) {
                endGame(kingOnThrone.player, 'throne');
                return;
            }

            useAction(boxerIndex, 'ALT');
            exitBoxerSlideMode();
            updatePins();
            renderPieces();
            updateArmyDisplay();
        }

        function onHexClick(q, r, e) {
            if (gameState.phase === 'placement') {
                handlePlacementClick(q, r);
                return;
            }
            if (gameState.phase !== 'playing') return;

            if (gameState.rotationMode) {
                handleRotationClick(q, r);
                return;
            }

            // Lance targeting mode
            if (gameState.lanceTargetingMode) {
                handleLanceTargetingClick(q, r);
                return;
            }




            // Sticky Bomb targeting mode
            if (gameState.bombTargetingMode) {
                // Must be a neighbor
                const piece = gameState.pieces[gameState.selectedPiece];
                if (hexDistance(piece.q, piece.r, q, r) === 1) {
                    const targetPiece = getPieceAt(q, r);

                    if (targetPiece) {
                        if (targetPiece.player === gameState.currentPlayer) {
                            addLog('Cannot place bomb on an ally!', 'system');
                            return;
                        }

                        // Enemy - stick to unit
                        const targetIndex = gameState.pieces.indexOf(targetPiece);
                        gameState.bombs.push({
                            id: Date.now(),
                            owner: gameState.selectedPiece,
                            type: 'unit',
                            targetUnitIndex: targetIndex
                        });
                        addLog('Bomb stuck to enemy!', gameState.currentPlayer);
                    } else {
                        // Empty cell
                        gameState.bombs.push({
                            id: Date.now(),
                            owner: gameState.selectedPiece,
                            type: 'cell',
                            q: q,
                            r: r
                        });
                        addLog('Stick Bomb placed!', gameState.currentPlayer);
                    }

                    useAction(gameState.selectedPiece, 'ALT');
                    exitBombTargetingMode();
                    renderPieces(); // Update visual
                } else {
                    addLog('Cancelled Sticky Bomb (Must select a neighboring cell)', 'system');
                    exitBombTargetingMode();
                }
                return;
            }

            // Boxer Slide targeting mode (must select adjacent unit)
            if (gameState.boxerSlideMode) {
                addLog('Select an adjacent unit to slide.', 'system');
                return;
            }

            // Path building mode
            if (gameState.pathBuilding && gameState.pathStartPiece !== null) {
                const piece = gameState.pieces[gameState.pathStartPiece];
                const validNext = getValidNextSteps(piece, gameState.currentPath);
                const clickedStep = validNext.find(step => step.q === q && step.r === r);

                if (clickedStep) {
                    // Add this step to path
                    gameState.currentPath.push({ q, r });
                    updatePathVisualization();
                } else {
                    // Check if clicking the last step again
                    if (gameState.currentPath.length > 0) {
                        const last = gameState.currentPath[gameState.currentPath.length - 1];
                        if (last.q === q && last.r === r) {
                            // Do nothing - user must click Confirm Move button
                            return;
                        }
                    }
                    // Invalid step - cancel path building
                    cancelPathBuilding();
                }
                return;
            }

            // Old behavior - deselect
            if (gameState.selectedPiece !== null) {
                gameState.selectedPiece = null;
                gameState.validMoves = [];
                clearHighlights();
                renderPieces();
                document.getElementById('btn-rotate').style.display = 'none';
            }
        }

        function onPieceClick(index) {
            let resolvedIndex = index;
            let piece = gameState.pieces[resolvedIndex];

            // Prefer selecting non-ghost piece when stacked with a ghost.
            if (piece && piece.alive && piece.type === 'GHOST') {
                const stackedRealIndex = gameState.pieces.findIndex((p, i) =>
                    i !== resolvedIndex &&
                    p.alive &&
                    p.type !== 'GHOST' &&
                    p.q === piece.q &&
                    p.r === piece.r
                );
                if (stackedRealIndex >= 0) {
                    resolvedIndex = stackedRealIndex;
                    piece = gameState.pieces[resolvedIndex];
                }
            }

            if (gameState.phase !== 'playing') return;

            // In rotation mode, treat piece clicks same as hex clicks - select the ring
            if (gameState.rotationMode) {
                handleRotationClick(piece.q, piece.r);
                return;
            }

            // In lance targeting mode, clicking on a piece might be a valid target selection
            if (gameState.lanceTargetingMode) {
                handleLanceTargetingClick(piece.q, piece.r);
                return;
            }

            // Boxer slide targeting mode
            if (gameState.boxerSlideMode && gameState.boxerSlideSource !== null) {
                const boxerIndex = gameState.boxerSlideSource;
                if (resolvedIndex === boxerIndex) return;
                const boxer = gameState.pieces[boxerIndex];
                if (hexDistance(boxer.q, boxer.r, piece.q, piece.r) !== 1) {
                    addLog('Slide target must be adjacent.', 'system');
                    exitBoxerSlideMode();
                    return;
                }
                executeBoxerSlide(boxerIndex, resolvedIndex);
                return;
            }

            // If selecting a different piece, check for bomb targeting
            if (gameState.bombTargetingMode && gameState.selectedPiece !== resolvedIndex) {
                const targetPiece = gameState.pieces[resolvedIndex];
                const sourcePiece = gameState.pieces[gameState.selectedPiece];

                // Check if it's a neighbor
                if (hexDistance(sourcePiece.q, sourcePiece.r, targetPiece.q, targetPiece.r) === 1) {
                    if (targetPiece.player === gameState.currentPlayer) {
                        addLog('Cannot place bomb on an ally!', 'system');
                        return; // Stay in targeting mode
                    } else {
                        // Enemy - stick to unit
                        gameState.bombs.push({
                            id: Date.now(),
                            owner: gameState.selectedPiece,
                            type: 'unit',
                            targetUnitIndex: resolvedIndex
                        });
                        addLog('Bomb stuck to enemy!', gameState.currentPlayer);
                        useAction(gameState.selectedPiece, 'ALT');
                        exitBombTargetingMode();
                        renderPieces();
                        return;
                    }
                }

                // If not a neighbor, exit mode
                exitBombTargetingMode();
            }



            // If we're in path building mode, check if this piece is on a valid next step
            if (gameState.pathBuilding && gameState.pathStartPiece !== null) {
                const pathPiece = gameState.pieces[gameState.pathStartPiece];
                const validNext = getValidNextSteps(pathPiece, gameState.currentPath);
                const clickedStep = validNext.find(step => step.q === piece.q && step.r === piece.r);

                if (clickedStep) {
                    // This piece is on a valid move tile - continue the path
                    gameState.currentPath.push({ q: piece.q, r: piece.r });
                    updatePathVisualization();
                    return;
                } else {
                    // This piece is not on a valid move tile - cancel path building
                    cancelPathBuilding();
                }
            }

            // Select the piece type in the unit editor
            selectUnitForEdit(piece.type);

            // Select own piece - start path building
            if (piece.player === gameState.currentPlayer && !isPieceFullyUsed(resolvedIndex)) {
                // Pinned pieces cannot be selected
                if (piece.pinned) {
                    addLog('Pinned pieces cannot move or take actions!', 'system');
                    return;
                }
                startPathBuilding(resolvedIndex);
            }
        }

        function startPathBuilding(pieceIndex) {
            const piece = gameState.pieces[pieceIndex];

            // Pinned pieces cannot take actions
            if (piece.pinned) {
                addLog('Pinned pieces cannot move or take actions!', 'system');
                return;
            }

            gameState.pathBuilding = true;
            gameState.pathStartPiece = pieceIndex;
            gameState.currentPath = [];
            gameState.selectedPiece = pieceIndex;

            // Show Alt Move button for power pieces (King, Snake, Shield, Bomber, Lance)
            // Power pieces are everyone except Pawns and Ghosts
            const rotateBtn = document.getElementById('btn-rotate');
            if (piece.type !== 'PAWN' && piece.type !== 'GHOST' && !piece.pinned) {
                rotateBtn.style.display = 'flex';
                // Unified style for all power pieces as requested
                rotateBtn.className = 'btn alt-move';

                // Reset disabled state default
                rotateBtn.disabled = false;
                rotateBtn.style.opacity = '1';
                rotateBtn.style.cursor = 'pointer';

                if (PIECE_TYPES[piece.type].isKing) {
                    rotateBtn.innerHTML = 'âš¡ Rotate Ring';
                } else if (piece.type === 'ARCHER') {
                    rotateBtn.innerHTML = 'âš¡ Shoot Arrow';
                    if (!piece.altMoveUnlocked) {
                        rotateBtn.disabled = true;
                        rotateBtn.style.opacity = '0.5';
                        rotateBtn.style.cursor = 'not-allowed';
                    }
                } else if (piece.type === 'SHIELD') {
                    rotateBtn.innerHTML = 'âš¡ Force Field';
                } else if (piece.type === 'BOMBER') {
                    const hasBomb = gameState.bombs && gameState.bombs.some(b => b.owner === pieceIndex);
                    rotateBtn.innerHTML = hasBomb ? 'âš¡ Remove Bomb' : 'âš¡ Sticky Bomb';
                } else if (piece.type === 'BOXER') {
                    rotateBtn.innerHTML = 'âš¡ Slide';
                } else if (piece.type === 'SNAKE') {
                    rotateBtn.innerHTML = 'âš¡ Summon Ghost';
                } else {
                    rotateBtn.innerHTML = 'âš¡ Alt Move';
                }

                // Disable if Alt action already used
                if (!canPiecePerformAction(pieceIndex, 'ALT')) {
                    rotateBtn.disabled = true;
                    rotateBtn.style.opacity = '0.5';
                    rotateBtn.style.cursor = 'not-allowed';
                    rotateBtn.title = 'Alt action already used this turn';
                }
            } else {
                rotateBtn.style.display = 'none';
            }

            updatePathVisualization();
            updateAutoMoveVisibility();
        }

        function cancelPathBuilding() {
            gameState.pathBuilding = false;
            gameState.currentPath = [];
            gameState.pathStartPiece = null;
            gameState.selectedPiece = null;
            gameState.previewPinningPaths = []; // Clear preview pinning

            if (gameState.lanceTargetingMode) {
                exitLanceTargetingMode();
            }
            if (gameState.bombTargetingMode) {
                gameState.bombTargetingMode = false;
            }
            if (gameState.boxerSlideMode) {
                exitBoxerSlideMode();
            }

            clearHighlights();
            renderPieces();
            renderPinningPaths(); // Re-render to clear preview paths
            document.getElementById('btn-rotate').style.display = 'none';
            document.getElementById('btn-confirm-path').style.display = 'none';
            document.getElementById('btn-cancel-path').style.display = 'none';
            updateAutoMoveVisibility();
        }

        function updatePathVisualization() {
            if (!gameState.pathBuilding || gameState.pathStartPiece === null) return;

            // Only show move path if piece can still Move
            const canMove = canPiecePerformAction(gameState.pathStartPiece, 'MOVE');
            if (!canMove) {
                clearHighlights();
                return;
            }

            const piece = gameState.pieces[gameState.pathStartPiece];
            const validNext = getValidNextSteps(piece, gameState.currentPath);

            clearHighlights();

            // Highlight current path
            gameState.currentPath.forEach((step, idx) => {
                const hex = document.querySelector(`.hex[data-q="${step.q}"][data-r="${step.r}"]`);
                if (hex) {
                    if (idx === gameState.currentPath.length - 1) {
                        hex.classList.add('path-end'); // Last step highlighted more prominently
                    } else {
                        hex.classList.add('path-step'); // Intermediate steps
                    }
                }
            });

            // Highlight valid next steps
            validNext.forEach(step => {
                const hex = document.querySelector(`.hex[data-q="${step.q}"][data-r="${step.r}"]`);
                if (hex) {
                    if (step.hasEnemy) {
                        hex.classList.add('damage-path');
                    } else {
                        hex.classList.add('valid-move');
                    }
                }
            });

            // Calculate and show preview pinning if path is complete
            gameState.previewPinningPaths = [];
            if (gameState.currentPath.length > 0) {
                const destination = gameState.currentPath[gameState.currentPath.length - 1];
                // Only calculate preview if destination is valid
                const occupant = getPieceAt(destination.q, destination.r);
                const isFriendlyGhost = occupant && occupant.type === 'GHOST' && occupant.player === piece.player;

                if (!occupant || occupant.player !== piece.player || isFriendlyGhost) {
                    try {
                        const previewPaths = calculatePreviewPinning(
                            gameState.pathStartPiece,
                            destination,
                            gameState.currentPath
                        );
                        gameState.previewPinningPaths = previewPaths;
                    } catch (e) {
                        // If preview calculation fails, just don't show preview
                        console.warn('Preview pinning calculation failed:', e);
                    }
                }
            }

            // Show confirm/cancel buttons
            const confirmBtn = document.getElementById('btn-confirm-path');
            const cancelBtn = document.getElementById('btn-cancel-path');
            if (gameState.currentPath.length > 0) {
                confirmBtn.style.display = 'flex';
            } else {
                confirmBtn.style.display = 'none';
            }
            cancelBtn.style.display = 'inline-block';

            renderPieces();
            renderPinningPaths(); // Re-render to show preview paths
        }

        function confirmPathMove() {
            if (!gameState.pathBuilding || gameState.pathStartPiece === null || gameState.currentPath.length === 0) {
                return;
            }

            const piece = gameState.pieces[gameState.pathStartPiece];
            const destination = gameState.currentPath[gameState.currentPath.length - 1];
            const damagePath = calculateDamagePath(piece, gameState.currentPath);

            // Check if destination is valid
            const occupant = getPieceAt(destination.q, destination.r);
            const isFriendlyGhost = occupant && occupant.type === 'GHOST' && occupant.player === piece.player;

            // Cannot land on friendly non-ghost
            if (occupant && occupant.player === piece.player && !isFriendlyGhost) {
                addLog('Cannot land on friendly unit!', 'system');
                return;
            }

            // If landing on enemy, must kill it
            // Use simulateMoveAndValidate to check if move is valid (reuses same logic as applyDamage)
            if (occupant && occupant.player !== piece.player) {
                const move = {
                    q: destination.q,
                    r: destination.r,
                    damagePath: damagePath,
                    willKill: true,
                    path: gameState.currentPath
                };
                const ramDamage = gameState.unitConfigs[piece.type].ramDamage;

                if (!simulateMoveAndValidate(gameState.pathStartPiece, destination.q, destination.r, move, ramDamage)) {
                    addLog('Cannot land on enemy that would survive!', 'system');
                    return;
                }
            }

            // Execute the move
            const move = {
                q: destination.q,
                r: destination.r,
                damagePath: damagePath,
                willKill: occupant && occupant.player !== piece.player,
                path: gameState.currentPath
            };

            // Only consume action if move succeeds
            const moveSucceeded = executeMove(gameState.pathStartPiece, destination.q, destination.r, move);
            if (!moveSucceeded) {
                // Move was rejected - don't consume action, don't clean up path building
                // User can try a different move
                return;
            }

            useAction(gameState.pathStartPiece, 'MOVE');

            // Clean up
            cancelPathBuilding();
            updateArmyDisplay();
        }


        function handleRotationClick(q, r) {
            const ring = getRing(q, r);
            if (ring === 0 || ring > BOARD_RADIUS) return;

            gameState.selectedRing = ring;
            document.getElementById('rotation-ring').textContent = ring;

            // Highlight selected ring
            document.querySelectorAll('.ring-highlight').forEach(el => el.classList.remove('active'));
            document.getElementById(`ring-${ring}`).classList.add('active');
        }

        function setupRotationControls() {
            document.getElementById('rotate-cw').addEventListener('click', () => {
                if (gameState.selectedRing) {
                    executeRotation(gameState.selectedRing, true);
                    exitRotationMode();
                    useAction(gameState.selectedPiece, 'ALT');
                    gameState.selectedPiece = null;
                    updateArmyDisplay(); // Update army panel to reflect new pinning status
                    renderPieces();
                }
            });

            document.getElementById('rotate-ccw').addEventListener('click', () => {
                if (gameState.selectedRing) {
                    executeRotation(gameState.selectedRing, false);
                    exitRotationMode();
                    useAction(gameState.selectedPiece, 'ALT');
                    gameState.selectedPiece = null;
                    updateArmyDisplay(); // Update army panel to reflect new pinning status
                    renderPieces();
                }
            });

            document.getElementById('rotate-cancel').addEventListener('click', () => {
                exitRotationMode();
            });
        }

        // ============================================
        // BOMBER STICKY BOMB
        // ============================================

        function activateStickyBomb(pieceIndex) {
            gameState.bombTargetingMode = true;
            gameState.selectedPiece = pieceIndex;
            addLog('Select a neighboring cell (Bomber Alt Move)', 'system');

            // Show cancel button
            document.getElementById('btn-cancel-path').style.display = 'inline-block';
            updateUI();

            // Highlight neighbors
            const piece = gameState.pieces[pieceIndex];
            for (let dir = 0; dir < 6; dir++) {
                const n = hexNeighbor(piece.q, piece.r, dir);
                if (isValidHex(n.q, n.r)) {
                    const hex = document.querySelector(`.hex[data-q="${n.q}"][data-r="${n.r}"]`);
                    if (hex) hex.classList.add('valid-move');
                }
            }
        }

        function createExplosionEffect(q, r, player) {
            const pos = hexToPixel(q, r);
            const svg = document.getElementById('game-board');
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);

            const effect = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            effect.setAttribute('cx', 0);
            effect.setAttribute('cy', 0);
            effect.classList.add('explosion-ring', `p${player}`);

            g.appendChild(effect);
            svg.appendChild(g);

            // Remove element after animation completes
            setTimeout(() => {
                if (g.parentNode) svg.removeChild(g);
            }, 700);
        }

        // ============================================
        // SNAKE GHOST
        // ============================================
        function activateGhost(pieceIndex) {
            const piece = gameState.pieces[pieceIndex];
            // SUMMON GHOST mode - create a new ghost (unlimited)
            const ghostAtCell = getGhostPieceAt(piece.q, piece.r);
            if (ghostAtCell) {
                addLog('Cannot summon Ghost on an occupied ghost cell.', 'system');
                return;
            }

            // Create ghost as an actual piece
            const ghostPiece = {
                type: 'GHOST',
                player: piece.player,
                q: piece.q,
                r: piece.r,
                hp: 1,
                maxHP: 1,
                alive: true,
                pinned: false,
                altMoveUnlocked: false,
                summonerIndex: pieceIndex // Track which Snake created this ghost
            };

            gameState.pieces.push(ghostPiece);

            // Also add to ghosts array for visual rendering and rotation logic
            gameState.ghosts.push({
                owner: pieceIndex,
                q: piece.q,
                r: piece.r,
                player: piece.player
            });

            addLog(`${PIECE_TYPES[piece.type].name} summons a Soul Echo!`, piece.player);
            useAction(pieceIndex, 'ALT');
            cancelPathBuilding();
        }

        // Helper to find ghost piece by position
        function getGhostPieceAt(q, r) {
            return gameState.pieces.find(p => p.alive && p.type === 'GHOST' && p.q === q && p.r === r);
        }

        function detonateBomb(bomb) {
            if (!bomb) return;

            // Get explosion center
            let q, r;
            if (bomb.type === 'cell') {
                q = bomb.q;
                r = bomb.r;
            } else {
                const target = gameState.pieces[bomb.targetUnitIndex];
                if (!target) {
                    const idx = gameState.bombs.indexOf(bomb);
                    if (idx !== -1) gameState.bombs.splice(idx, 1);
                    return;
                }
                q = target.q;
                r = target.r;
            }

            const ownerPiece = gameState.pieces[bomb.owner];
            const ownerPlayer = ownerPiece ? ownerPiece.player : (gameState.currentPlayer);

            // Visual effect
            createExplosionEffect(q, r, ownerPlayer);

            addLog(`Bomb detonates at (${q}, ${r})!`, 'system');

            // Remove bomb first so it doesn't trigger again
            const idx = gameState.bombs.indexOf(bomb);
            if (idx !== -1) {
                gameState.bombs.splice(idx, 1);
            }

            // Find all enemy pieces in radius 1
            const piecesToDamage = [];
            gameState.pieces.forEach((p, i) => {
                if (p.alive && hexDistance(p.q, p.r, q, r) <= 1) {
                    // Shield check: Only enemy pieces of the bomb owner take damage
                    if (p.player !== ownerPlayer) {
                        piecesToDamage.push(p);
                    }
                }
            });

            // Apply damage: center cell = 3, surrounding cells = 2
            piecesToDamage.forEach(p => {
                const dmg = (p.q === q && p.r === r) ? 3 : 2;
                applyDamage(p, dmg, bomb.owner);
            });

            renderPieces();
        }

        function detonateBombsOnUnit(unitIndex) {
            if (!gameState.bombs) return;
            // Identify bombs attached to this unit and queue them for deferred detonation
            const bombsToTrigger = gameState.bombs.filter(b => b.type === 'unit' && b.targetUnitIndex === unitIndex);
            bombsToTrigger.forEach(b => {
                if (!gameState.pendingBombDetonations.includes(b)) {
                    gameState.pendingBombDetonations.push(b);
                }
            });
        }

        function detonateBombsOwnedBy(unitIndex) {
            if (!gameState.bombs) return;
            // Identify bombs owned by this unit and queue them for deferred detonation
            const bombsToTrigger = gameState.bombs.filter(b => b.owner === unitIndex);
            bombsToTrigger.forEach(b => {
                if (!gameState.pendingBombDetonations.includes(b)) {
                    gameState.pendingBombDetonations.push(b);
                }
            });
        }

        function processPendingBombDetonations() {
            // Detonate all queued bombs after the move is complete
            const bombsToDetonate = [...gameState.pendingBombDetonations];
            gameState.pendingBombDetonations = [];
            bombsToDetonate.forEach(b => detonateBomb(b));
        }


        function exitBombTargetingMode() {
            gameState.bombTargetingMode = false;
            clearHighlights();
            // Important: Handle cleanup to prevent game lock
            if (gameState.selectedPiece !== null) {
                cancelPathBuilding(); // Clears selection and UI state
            } else {
                document.getElementById('btn-cancel-path').style.display = 'none';
                updateUI();
            }
        }





        function enterRotationMode(pieceIndex) {
            const piece = gameState.pieces[pieceIndex];
            if (!PIECE_TYPES[piece.type].isKing) return;

            // Pinned pieces cannot take actions
            if (piece.pinned) {
                addLog('Pinned pieces cannot move or take actions!', 'system');
                return;
            }

            gameState.rotationMode = true;
            gameState.selectedRing = 1;

            document.getElementById('action-controls').style.display = 'none';
            const controls = document.getElementById('rotation-controls');
            controls.style.display = 'flex';
            controls.style.top = '24px';
            controls.style.left = '50%';
            controls.style.transform = 'translateX(-50%)';

            document.getElementById('rotation-ring').textContent = '1';
            document.getElementById(`ring-1`).classList.add('active');
            updateAutoMoveVisibility();
        }

        function exitRotationMode() {
            gameState.rotationMode = false;
            gameState.selectedRing = null;
            document.getElementById('rotation-controls').style.display = 'none';
            document.getElementById('action-controls').style.display = 'flex';
            document.querySelectorAll('.ring-highlight').forEach(el => el.classList.remove('active'));
            updateAutoMoveVisibility();
        }

        // ============================================
        // UI UPDATES
        // ============================================

        function updateUI() {
            const indicator = document.getElementById('turn-indicator');
            const nameEl = indicator.querySelector('.player-name');

            indicator.className = `turn-indicator player${gameState.currentPlayer}`;
            nameEl.textContent = `Player ${gameState.currentPlayer}`;

            // CPU overrides
            if (gameState.gameMode === 'vsCPU' && gameState.currentPlayer === gameState.cpuPlayer) {
                nameEl.textContent = 'CPU (Thinking...)';
                nameEl.style.color = 'var(--player-cpu)';
                indicator.style.borderColor = 'var(--player-cpu)';
            } else {
                nameEl.style.color = '';
                indicator.style.borderColor = '';
            }

            document.getElementById('actions-count').textContent = gameState.actionsRemaining;

            const isCpuTurn = gameState.gameMode === 'vsCPU' && gameState.currentPlayer === gameState.cpuPlayer;
            const canInteract = gameState.phase === 'playing' && !isCpuTurn;

            document.getElementById('btn-end-turn').disabled = !canInteract;

            // Reset Turn button enablement
            const resetTurnBtn = document.getElementById('btn-reset-turn');
            if (resetTurnBtn) {
                if (gameState.phase === 'placement') {
                    resetTurnBtn.disabled = false;
                } else {
                    const totalActionsForTurn = gameState.isFirstTurn ? 1 : gameState.params.actionsPerTurn;
                    resetTurnBtn.disabled = !canInteract || gameState.actionsRemaining >= totalActionsForTurn;
                }
            }

            updatePlacementUI();
        }

        function updatePlacementUI() {
            const panel = document.getElementById('placement-panel');
            const piecesContainer = document.getElementById('placement-pieces');
            if (!panel || !piecesContainer) return;

            if (gameState.phase !== 'placement') {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';
            piecesContainer.innerHTML = '';

            const player = gameState.currentPlayer;
            const remaining = gameState.placementRemaining[player] || [];
            const allTypes = ['SNAKE', 'SHIELD', 'BOMBER', 'BOXER'];

            allTypes.forEach(type => {
                const div = document.createElement('div');
                div.className = 'placement-piece';
                if (type === 'SNAKE') {
                    div.innerHTML = `<svg width="26" height="26" viewBox="-10 -13 20 26" style="vertical-align: middle;">
                        <path d="M 0 9 Q 1 7 4 7 Q 7 7 7 4 Q 7 1 0 1 Q -7 1 -7 -2 Q -7 -5 0 -5" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
                        <path d="M 0 -4 L 3.5 -7.5 L 0 -11 L -3.5 -7.5 Z" fill="white"/>
                        <path d="M 0 -11 L -1.5 -12.5 M 0 -11 L 1.5 -12.5" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>`;
                    div.style.display = 'flex';
                    div.style.alignItems = 'center';
                    div.style.justifyContent = 'center';
                } else if (type === 'SHIELD') {
                    div.innerHTML = `<svg width="26" height="26" viewBox="-10 -10 20 20" style="vertical-align: middle; fill: none; stroke: white; stroke-width: 1.5; stroke-linecap: round; stroke-linejoin: round;">
                        <path d="M -6 -7 H 6 L 6 -1 Q 6 6 0 9 Q -6 6 -6 -1 Z" stroke-width="2"/>
                        <path d="M 0 -7 L 0 9" stroke-width="1.5"/>
                        <path d="M -5.5 -2 L 5.5 -2" stroke-width="1"/>
                    </svg>`;
                    div.style.display = 'flex';
                    div.style.alignItems = 'center';
                    div.style.justifyContent = 'center';
                } else if (type === 'BOMBER') {
                    div.innerHTML = `<svg width="26" height="26" viewBox="-10 -10 20 20" style="vertical-align: middle; fill: none; stroke: white; stroke-width: 1.5; stroke-linecap: round; stroke-linejoin: round;">
                        <path d="M 2 -6 Q 5 -9 3 -11" stroke-width="1.5"/>
                        <rect x="-1.5" y="-7.5" width="3" height="1.5" fill="white" rx="0.3"/>
                        <circle cx="0" cy="1.5" r="6" stroke-width="2"/>
                        <path d="M -2.5 -1 Q -3.5 1.5 -2.5 4" stroke-width="1"/>
                    </svg>`;
                    div.style.display = 'flex';
                    div.style.alignItems = 'center';
                    div.style.justifyContent = 'center';
                } else if (type === 'BOXER') {
                    div.innerHTML = '';
                    div.appendChild(createBoxerIconSvg(26, 'white'));
                    div.style.display = 'flex';
                    div.style.alignItems = 'center';
                    div.style.justifyContent = 'center';
                } else {
                    div.textContent = PIECE_TYPES[type].symbol;
                }
                div.dataset.type = type;

                if (!remaining.includes(type)) {
                    div.classList.add('placed');
                }
                if (gameState.placementSelectedType === type) {
                    div.classList.add('selected');
                }

                div.addEventListener('click', () => {
                    if (!remaining.includes(type)) return;
                    gameState.placementSelectedType = type;
                    updatePlacementUI();
                    updatePlacementHighlights();
                });

                piecesContainer.appendChild(div);
            });

            updatePlacementHighlights();
        }

        function updatePlacementHighlights() {
            clearHighlights();
            if (gameState.phase !== 'placement') return;
            const slots = gameState.placementSlots[gameState.currentPlayer] || [];
            slots.forEach(slot => {
                const hex = document.querySelector(`.hex[data-q="${slot.q}"][data-r="${slot.r}"]`);
                if (hex) hex.classList.add('valid-move');
            });
        }


        function updateArmyDisplay() {
            // Update titles
            const p2Title = document.querySelector('.army-title.player2');
            if (gameState.gameMode === 'vsCPU') {
                p2Title.textContent = 'â¬¢ CPU Army';
                p2Title.style.color = 'var(--player-cpu)';
            } else {
                p2Title.textContent = 'â¬¢ Player 2 Army';
                p2Title.style.color = 'var(--player2)';
            }

            [1, 2].forEach(player => {
                const container = document.getElementById(`army-p${player}`);
                container.innerHTML = '';

                gameState.pieces.filter(p => p.player === player && p.type !== 'GHOST').forEach((piece, idx) => {
                    const div = document.createElement('div');
                    div.className = `army-piece player${player}`;

                    if (gameState.gameMode === 'vsCPU' && player === gameState.cpuPlayer) {
                        div.style.background = 'var(--player-cpu-dim)';
                    }

                    if (!piece.alive) div.classList.add('dead');
                    if (piece.pinned) div.classList.add('pinned');

                    if (piece.type === 'ARCHER') {
                        // Use inline SVG for army display
                        const svgSize = 20;
                        const svgContent = piece.altMoveUnlocked
                            ? `<svg width="${svgSize}" height="${svgSize}" viewBox="-10 -10 20 20" style="vertical-align: middle; fill: none; stroke: ${piece.pinned ? '#5a5a5a' : 'white'}; stroke-width: 2;">
                                 <path d="M 3 -7 Q -6 0 3 7 M -6 0 L 7 0 M 3 -3 L 7 0 L 3 3" stroke-linecap="round" stroke-linejoin="round"/>
                               </svg>`
                            : `<svg width="${svgSize}" height="${svgSize}" viewBox="-10 -10 20 20" style="vertical-align: middle; fill: none; stroke: ${piece.pinned ? '#5a5a5a' : 'white'}; stroke-width: 2;">
                                 <path d="M 3 -7 Q -6 0 3 7" stroke-linecap="round"/>
                                 <path d="M 3 -7 L 3 7" stroke-width="1" stroke-dasharray="2,2" opacity="0.7"/>
                               </svg>`;
                        div.innerHTML = svgContent;
                        // Center flex if not already
                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                    } else if (piece.type === 'BOMBER') {
                        const svgSize = 24;
                        const strokeColor = piece.pinned ? '#5a5a5a' : 'white';
                        // Consistent SVG Bomb icon
                        div.innerHTML = `<svg width="${svgSize}" height="${svgSize}" viewBox="-10 -10 20 20" style="vertical-align: middle; fill: none; stroke: ${strokeColor}; stroke-width: 1.5; stroke-linecap: round; stroke-linejoin: round;">
                            <path d="M 2 -6 Q 5 -9 3 -11" stroke-width="1.5"/>
                            <rect x="-1.5" y="-7.5" width="3" height="1.5" fill="${strokeColor}" rx="0.3"/>
                            <circle cx="0" cy="1.5" r="6" stroke-width="2"/>
                            <path d="M -2.5 -1 Q -3.5 1.5 -2.5 4" stroke-width="1"/>
                        </svg>`;
                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                    } else if (piece.type === 'SNAKE') {
                        const svgSize = 24;
                        const strokeColor = piece.pinned ? '#5a5a5a' : 'white';
                        // Uploaded Snake Icon
                        div.innerHTML = `<svg width="${svgSize}" height="${svgSize}" viewBox="-10 -13 20 26" style="vertical-align: middle;">
                            <path d="M 0 9 Q 1 7 4 7 Q 7 7 7 4 Q 7 1 0 1 Q -7 1 -7 -2 Q -7 -5 0 -5" fill="none" stroke="${strokeColor}" stroke-width="2.5" stroke-linecap="round"/>
                            <path d="M 0 -4 L 3.5 -7.5 L 0 -11 L -3.5 -7.5 Z" fill="${strokeColor}"/>
                            <path d="M 0 -11 L -1.5 -12.5 M 0 -11 L 1.5 -12.5" stroke="${strokeColor}" stroke-width="1.5" stroke-linecap="round"/>
                        </svg>`;
                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                    } else if (piece.type === 'SHIELD') {
                        const svgSize = 24;
                        const strokeColor = piece.pinned ? '#5a5a5a' : 'white';
                        // Matches polished Kite Shield design
                        div.innerHTML = `<svg width="${svgSize}" height="${svgSize}" viewBox="-10 -10 20 20" style="vertical-align: middle; fill: none; stroke: ${strokeColor}; stroke-width: 1.5; stroke-linecap: round; stroke-linejoin: round;">
                            <path d="M -6 -7 H 6 L 6 -1 Q 6 6 0 9 Q -6 6 -6 -1 Z" stroke-width="2"/>
                            <path d="M 0 -7 L 0 9" stroke-width="1.5"/>
                            <path d="M -5.5 -2 L 5.5 -2" stroke-width="1"/>
                        </svg>`;
                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                    } else if (piece.type === 'BOXER') {
                        const svgSize = 24;
                        const strokeColor = piece.pinned ? '#5a5a5a' : 'white';
                        div.innerHTML = '';
                        div.appendChild(createBoxerIconSvg(svgSize, strokeColor));
                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                    } else {
                        div.textContent = PIECE_TYPES[piece.type].symbol;
                    }

                    div.title = `${PIECE_TYPES[piece.type].name} HP: ${piece.hp}`;
                    container.appendChild(div);
                });
            });
        }


        function addLog(message, type = 'system') {
            const log = document.getElementById('game-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type === 1 ? 'player1' : type === 2 ? 'player2' : 'system'}`;
            entry.textContent = message;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // ============================================
        // UNIT EDITOR
        // ============================================

        function setupUnitEditor() {
            const selector = document.getElementById('unit-selector');

            Object.entries(PIECE_TYPES).filter(([type]) => type !== 'GHOST').forEach(([type, info]) => {
                const btn = document.createElement('button');
                btn.className = 'unit-btn';
                btn.dataset.type = type;

                if (type === 'ARCHER') {
                    // Use loaded bow SVG for clear icon
                    btn.innerHTML = `<svg width="24" height="24" viewBox="-10 -10 20 20" style="vertical-align: middle; fill: none; stroke: currentColor; stroke-width: 2;">
                                 <path d="M 3 -7 Q -6 0 3 7 M -6 0 L 7 0 M 3 -3 L 7 0 L 3 3" stroke-linecap="round" stroke-linejoin="round"/>
                               </svg>`;
                    btn.style.display = 'flex';
                    btn.style.alignItems = 'center';
                    btn.style.justifyContent = 'center';
                } else if (type === 'BOMBER') {
                    // Use Bomb SVG for Bomber
                    btn.innerHTML = `<svg width="24" height="24" viewBox="-10 -10 20 20" style="vertical-align: middle; fill: none; stroke: currentColor; stroke-width: 1.5; stroke-linecap: round; stroke-linejoin: round;">
                             <path d="M 2 -6 Q 5 -9 3 -11" stroke-width="1.5"/>
                             <rect x="-1.5" y="-7.5" width="3" height="1.5" fill="currentColor" rx="0.3"/>
                             <circle cx="0" cy="1.5" r="6" stroke-width="2"/>
                             <path d="M -2.5 -1 Q -3.5 1.5 -2.5 4" stroke-width="1"/>
                         </svg>`;
                    btn.style.display = 'flex';
                    btn.style.alignItems = 'center';
                    btn.style.justifyContent = 'center';
                } else if (type === 'SHIELD') {
                    // Use Kite Shield SVG
                    btn.innerHTML = `<svg width="24" height="24" viewBox="-10 -10 20 20" style="vertical-align: middle; fill: none; stroke: currentColor; stroke-width: 1.5; stroke-linecap: round; stroke-linejoin: round;">
                            <path d="M -6 -7 H 6 L 6 -1 Q 6 6 0 9 Q -6 6 -6 -1 Z" stroke-width="2"/>
                            <path d="M 0 -7 L 0 9" stroke-width="1.5"/>
                            <path d="M -5.5 -2 L 5.5 -2" stroke-width="1"/>
                        </svg>`;
                    btn.style.display = 'flex';
                    btn.style.alignItems = 'center';
                    btn.style.justifyContent = 'center';
                } else if (type === 'SNAKE') {
                    // Uploaded Snake Icon
                    btn.innerHTML = `<svg width="24" height="24" viewBox="-10 -13 20 26" style="vertical-align: middle;">
                            <path d="M 0 9 Q 1 7 4 7 Q 7 7 7 4 Q 7 1 0 1 Q -7 1 -7 -2 Q -7 -5 0 -5" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"/>
                            <path d="M 0 -4 L 3.5 -7.5 L 0 -11 L -3.5 -7.5 Z" fill="currentColor"/>
                            <path d="M 0 -11 L -1.5 -12.5 M 0 -11 L 1.5 -12.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                        </svg>`;
                    btn.style.display = 'flex';
                    btn.style.alignItems = 'center';
                    btn.style.justifyContent = 'center';
                } else if (type === 'BOXER') {
                    btn.innerHTML = '';
                    btn.appendChild(createBoxerIconSvg(24, 'currentColor'));
                    btn.style.display = 'flex';
                    btn.style.alignItems = 'center';
                    btn.style.justifyContent = 'center';
                } else {
                    btn.textContent = info.symbol;
                }

                btn.title = info.name;
                btn.addEventListener('click', () => selectUnitForEdit(type));
                selector.appendChild(btn);
            });

            setupTemplateSelector();
        }

        function selectUnitForEdit(type) {
            document.querySelectorAll('.unit-btn').forEach(b => b.classList.remove('active'));
            // Find and activate the button for this unit type
            const btn = document.querySelector(`.unit-btn[data-type="${type}"]`);
            if (btn) {
                btn.classList.add('active');
            }

            document.getElementById('unit-details').style.display = 'block';

            const config = gameState.unitConfigs[type];
            const rangeInput = document.getElementById('unit-range');
            rangeInput.value = config.range;

            // Disable range input for King (always 1)
            if (type === 'KING') {
                rangeInput.disabled = true;
                rangeInput.title = 'King move range is always 1';
            } else {
                rangeInput.disabled = false;
                rangeInput.title = '';
            }

            document.getElementById('unit-hp').value = config.hp === Infinity ? 999 : config.hp;

            // Disable Max HP if it's Infinity (King)
            const hpInput = document.getElementById('unit-hp');
            hpInput.disabled = config.hp === Infinity;
            hpInput.title = '';

            document.getElementById('unit-ram-damage').value = config.ramDamage;

            // Update template selector
            document.querySelectorAll('.template-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.template === config.template);
            });

            // Store current editing type
            document.getElementById('unit-details').dataset.type = type;
        }

        function setupTemplateSelector() {
            const selector = document.getElementById('template-selector');
            selector.innerHTML = '';

            // Create template buttons
            const templates = [
                { id: MOVEMENT_TEMPLATES.FREE_MOTION, label: 'Free Motion', desc: 'Move in any direction' },
                { id: MOVEMENT_TEMPLATES.STRAIGHT_LINE, label: 'Straight Line', desc: 'Pick one direction, continue straight' },
                { id: MOVEMENT_TEMPLATES.DIRECT_JUMP, label: 'Direct Jump', desc: 'Teleport to destination in range' }
            ];

            templates.forEach(template => {
                const btn = document.createElement('button');
                btn.className = 'template-btn';
                btn.dataset.template = template.id;
                btn.innerHTML = `<div style="font-weight: 600; margin-bottom: 4px;">${template.label}</div><div style="font-size: 10px; color: var(--text-muted);">${template.desc}</div>`;
                btn.addEventListener('click', () => selectTemplate(template.id));
                selector.appendChild(btn);
            });

            // Range input handler
            document.getElementById('unit-range').addEventListener('input', (e) => {
                const type = document.getElementById('unit-details').dataset.type;
                if (type) {
                    gameState.unitConfigs[type].range = parseInt(e.target.value);
                    renderPieces();
                }
            });

            // HP input handler
            document.getElementById('unit-hp').addEventListener('input', (e) => {
                const type = document.getElementById('unit-details').dataset.type;
                if (type) {
                    const value = parseInt(e.target.value);
                    const newHP = value === 999 ? Infinity : value;
                    gameState.unitConfigs[type].hp = newHP;

                    // Update all existing pieces of this type
                    gameState.pieces.forEach(piece => {
                        if (piece.type === type && piece.alive) {
                            piece.maxHP = newHP;
                            // Set current HP to new max HP (heal to full)
                            piece.hp = newHP;
                        }
                    });

                    // Update the display
                    renderPieces();
                    updateArmyDisplay();
                }
            });

            // Ram damage input handler
            document.getElementById('unit-ram-damage').addEventListener('input', (e) => {
                const type = document.getElementById('unit-details').dataset.type;
                if (type) {
                    gameState.unitConfigs[type].ramDamage = parseInt(e.target.value);
                    renderPieces();
                }
            });
        }

        function selectTemplate(templateId) {
            const type = document.getElementById('unit-details').dataset.type;
            if (!type) return;

            gameState.unitConfigs[type].template = templateId;

            // Update UI
            document.querySelectorAll('.template-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.template === templateId);
            });
            renderPieces();
        }

        // ============================================
        // PARAMETERS
        // ============================================



        // ============================================
        // GAME CONTROLS
        // ============================================

        function startGame(mode = '2player') {
            gameState.gameMode = mode;
            // Start in placement phase
            gameState.phase = 'placement';
            gameState.currentPlayer = 1;
            gameState.isFirstTurn = true;
            // First player gets only 1 action on their first turn (after placement)
            gameState.actionsRemaining = 1;
            gameState.actionsPerTurn = gameState.params.actionsPerTurn;

            // Reset state
            gameState.usedPieces = new Set();
            gameState.hasAnyPieceMoved = false;
            gameState.pieces = [];
            gameState.board = new Map();
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            gameState.rotationMode = false;
            gameState.selectedRing = null;
            gameState.pathBuilding = false;
            gameState.lanceTargetingMode = false;
            gameState.lanceTargetingRays = [];
            gameState.currentPath = [];
            gameState.pathStartPiece = null;
            gameState.pinningPaths = [];
            gameState.pinningPaths = [];
            gameState.pinningMap.clear();
            gameState.forceFields = [];
            gameState.turnHistory = new Map(); // pieceIndex -> Set<ActionType>
            gameState.placementSelectedType = null;
            gameState.placementSlots = { 1: [], 2: [] };
            gameState.placementRemaining = { 1: ['SNAKE', 'SHIELD', 'BOMBER', 'BOXER'], 2: ['SNAKE', 'SHIELD', 'BOMBER', 'BOXER'] };
            gameState.placementPlacedCount = { 1: 0, 2: 0 };

            // Setup Timer
            const timerEnabled = document.getElementById('timer-enabled').checked;
            gameState.timerEnabled = timerEnabled;


            if (timerEnabled) {
                const roundSeconds = parseInt(document.getElementById('timer-round-seconds').value) || 60;
                const reserveMinutes = parseInt(document.getElementById('timer-reserve-minutes').value) || 15;
                const roundMs = roundSeconds * 1000;
                const reserveMs = reserveMinutes * 60 * 1000;

                gameState.roundTimeLimit = roundMs;
                gameState.roundTimeRemaining = { 1: roundMs, 2: roundMs };
                gameState.reserveTimeRemaining = { 1: reserveMs, 2: reserveMs };
                gameState.timerPaused = false;
                gameState.lastTimestamp = performance.now();
            }
            updateTimerUI();

            // Hide modals
            document.getElementById('victory-modal').classList.remove('active');
            document.getElementById('mode-selection-modal').classList.remove('active');

            // Setup board
            setupFixedPositions(true);
            saveTurnSnapshot();
            updatePins();
            updateUI();
            updateTimerUI();
            renderPieces();
            updateArmyDisplay();
            updatePlacementUI();

            addLog('=== GAME STARTED ===', 'system');
            addLog('Placement Phase: place Snake, Shield, Bomber on ring 4.', 'system');
            addLog(`Player 1 Placement`, 'system');
        }

        function resetGame() {
            if (gameState.timerInterval) cancelAnimationFrame(gameState.timerInterval);

            gameState.bombs = []; // Clear bombs
            gameState.pendingBombDetonations = [];
            gameState.timerEnabled = false;
            gameState.timerPaused = false;

            // Just show mode selection
            document.getElementById('victory-modal').classList.remove('active');
            document.getElementById('mode-selection-modal').classList.add('active');
            gameState.phase = 'setup';
            document.getElementById('game-log').innerHTML = '<div class="log-entry system">Game reset.</div>';

            renderPieces(); // Update visual to remove bombs
            updateTimerUI();
        }



        // ============================================
        // HELPERS
        // ============================================

        function updateAutoMoveVisibility() {
            // Deprecated - kept for compatibility
        }

        // ============================================
        // KEYBOARD SHORTCUTS
        // ============================================

        function setupKeyboard() {
            document.addEventListener('keydown', (e) => {
                if (gameState.phase !== 'playing') return;

                // R for rotation mode
                if (e.key === 'r' || e.key === 'R') {
                    if (gameState.selectedPiece !== null) {
                        const piece = gameState.pieces[gameState.selectedPiece];
                        if (PIECE_TYPES[piece.type].isKing && piece.player === gameState.currentPlayer) {
                            enterRotationMode(gameState.selectedPiece);
                        }
                    }
                }

                // Escape to cancel
                if (e.key === 'Escape') {
                    if (gameState.rotationMode) {
                        exitRotationMode();
                    } else if (gameState.pathBuilding) {
                        cancelPathBuilding();
                    } else if (gameState.lanceTargetingMode) {
                        cancelPathBuilding();
                    } else if (gameState.bombTargetingMode) {
                        exitBombTargetingMode();
                    } else if (gameState.boxerSlideMode) {
                        exitBoxerSlideMode();
                    } else {
                        gameState.selectedPiece = null;
                        gameState.validMoves = [];
                        clearHighlights();
                        renderPieces();
                    }
                }

                // Number keys for ring selection in rotation mode
                if (gameState.rotationMode && e.key >= '1' && e.key <= '5') {
                    const ring = parseInt(e.key);
                    gameState.selectedRing = ring;
                    document.getElementById('rotation-ring').textContent = ring;
                    document.querySelectorAll('.ring-highlight').forEach(el => el.classList.remove('active'));
                    document.getElementById(`ring-${ring}`).classList.add('active');
                }
            });
        }

        // ============================================
        // GAME LOOP & TIMER
        // ============================================

        function gameLoop(timestamp) {
            if (gameState.phase !== 'playing' || !gameState.timerEnabled) return;

            const delta = timestamp - gameState.lastTimestamp;
            gameState.lastTimestamp = timestamp;

            if (gameState.timerPaused) {
                updateTimerUI();
                gameState.timerInterval = requestAnimationFrame(gameLoop);
                return;
            }

            const player = gameState.currentPlayer;
            let roundRemaining = gameState.roundTimeRemaining[player];
            let reserveRemaining = gameState.reserveTimeRemaining[player];

            let deltaLeft = delta;
            if (roundRemaining > 0) {
                const used = Math.min(roundRemaining, deltaLeft);
                roundRemaining -= used;
                deltaLeft -= used;
            }
            if (deltaLeft > 0) {
                reserveRemaining -= deltaLeft;
            }

            gameState.roundTimeRemaining[player] = Math.max(0, roundRemaining);
            gameState.reserveTimeRemaining[player] = Math.max(0, reserveRemaining);

            // Check for timeout (both round and reserve exhausted)
            if (gameState.roundTimeRemaining[player] <= 0 && gameState.reserveTimeRemaining[player] <= 0) {
                updateTimerUI();
                const winner = player === 1 ? 2 : 1;
                endGame(winner, 'timeout');
                return;
            }

            updateTimerUI();
            gameState.timerInterval = requestAnimationFrame(gameLoop);
        }

        function updateTimerUI() {
            const el = document.getElementById('active-timer');
            if (el) {
                const player = gameState.currentPlayer;
                const roundMs = Math.max(0, gameState.roundTimeRemaining[player]);
                const reserveMs = Math.max(0, gameState.reserveTimeRemaining[player]);
                el.innerHTML = `<div>R ${formatTime(roundMs)}</div><div>B ${formatTime(reserveMs)}</div>`;
            }
            updateTimerControls();
        }

        function updateTimerControls() {
            const btn = document.getElementById('btn-timer-toggle');
            if (!btn) return;
            if (!gameState.timerEnabled) {
                btn.disabled = true;
                btn.textContent = 'Pause';
                return;
            }
            btn.disabled = false;
            btn.textContent = gameState.timerPaused ? 'Resume' : 'Pause';
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        function init() {
            initUnitConfigs();
            createBoard();
            setupUnitEditor();

            setupRotationControls();
            setupKeyboard();
            setupFixedPositions();
            updateArmyDisplay();
            updateUI();
            // startGame(); // Removed auto-start

            document.getElementById('btn-reset').addEventListener('click', resetGame);
            document.getElementById('btn-reset-turn').addEventListener('click', resetTurn);
            document.getElementById('btn-end-turn').addEventListener('click', endTurn);
            document.getElementById('btn-new-game').addEventListener('click', resetGame);
            document.getElementById('btn-confirm-path').addEventListener('click', confirmPathMove);
            document.getElementById('btn-cancel-path').addEventListener('click', cancelPathBuilding);
            document.getElementById('btn-timer-toggle').addEventListener('click', () => {
                if (!gameState.timerEnabled) return;
                gameState.timerPaused = !gameState.timerPaused;
                if (!gameState.timerPaused) {
                    gameState.lastTimestamp = performance.now();
                }
                updateTimerUI();
            });
            document.getElementById('btn-rotate').addEventListener('click', () => {
                if (gameState.selectedPiece !== null) {
                    const piece = gameState.pieces[gameState.selectedPiece];

                    if (piece.pinned) {
                        addLog('Pinned pieces cannot move or take actions!', 'system');
                        return;
                    }

                    if (piece.player !== gameState.currentPlayer) return;

                    if (PIECE_TYPES[piece.type].isKing) {
                        enterRotationMode(gameState.selectedPiece);
                        document.getElementById('btn-rotate').style.display = 'none';
                    } else if (piece.type === 'ARCHER') {
                        if (gameState.lanceTargetingMode) {
                            cancelPathBuilding(); // Lance also uses cancelPathBuilding to exit
                        } else {
                            enterLanceTargetingMode(gameState.selectedPiece);
                        }
                    } else if (piece.type === 'SNAKE') {
                        activateGhost(gameState.selectedPiece);
                    } else if (piece.type === 'BOMBER') {
                        const bomb = gameState.bombs.find(b => b.owner === gameState.selectedPiece);
                        if (bomb) {
                            // Detonate existing bomb
                            detonateBomb(bomb);
                            useAction(gameState.selectedPiece, 'ALT');
                            cancelPathBuilding();
                        } else {
                            // No bomb, enter placement mode
                            if (gameState.bombTargetingMode) {
                                exitBombTargetingMode();
                            } else {
                                activateStickyBomb(gameState.selectedPiece);
                            }
                        }
                    } else if (piece.type === 'SHIELD') {
                        activateForceField(gameState.selectedPiece);
                    } else if (piece.type === 'BOXER') {
                        if (gameState.boxerSlideMode) {
                            exitBoxerSlideMode();
                        } else {
                            activateBoxerSlide(gameState.selectedPiece);
                        }
                    } else if (piece.type !== 'PAWN') {
                        // Execute Alt Move for other power pieces
                        // For now, just consumes an action
                        addLog(`${PIECE_TYPES[piece.type].name} uses Alt Move (Pass)`, piece.player);
                        useAction(gameState.selectedPiece, 'ALT');
                        cancelPathBuilding(); // Deselect after action
                    }
                }
            });

            document.getElementById('btn-auto-move').style.display = 'none';

            // Mode selection listeners
            document.getElementById('btn-start-game').addEventListener('click', () => startGame('2player'));
        }

        // Start
        init();
    </script>
</body>

</html>
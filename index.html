<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Throne — Tactical Hex Duel</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0a0a0c;
            --bg-panel: #111114;
            --bg-hex: #16161a;
            --bg-hex-hover: #1e1e24;
            --border: #2a2a32;
            --text-primary: #e8e6e3;
            --text-muted: #6b6b76;
            --accent-gold: #d4af37;
            --accent-gold-dim: #a68a2a;
            --player1: #c94c4c;
            --player1-dim: #8a3535;
            --player2: #4c8bc9;
            --player2-dim: #35628a;
            --throne: #d4af37;
            --pin-indicator: #ff6b6b;
            --valid-move: rgba(100, 200, 100, 0.3);
            --damage-path: rgba(255, 165, 0, 0.5);
            --path-highlight: rgba(100, 150, 255, 0.4);
            --path-end-highlight: rgba(100, 150, 255, 0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .game-container {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            min-height: 100vh;
            gap: 0;
        }

        /* Left Panel - Game State */
        .panel {
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel-right {
            border-right: none;
            border-left: 1px solid var(--border);
            overflow-y: auto;
            max-height: 100vh;
        }

        .panel-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-muted);
            margin-bottom: 12px;
            font-family: 'JetBrains Mono', monospace;
        }

        .logo {
            font-size: 28px;
            font-weight: 700;
            letter-spacing: 4px;
            text-align: center;
            color: var(--accent-gold);
            padding: 16px 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 8px;
        }

        .turn-indicator {
            text-align: center;
            padding: 20px;
            background: var(--bg-hex);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .turn-indicator .player-name {
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .turn-indicator.player1 .player-name { color: var(--player1); }
        .turn-indicator.player2 .player-name { color: var(--player2); }

        .actions-remaining {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            color: var(--text-muted);
        }

        .actions-remaining span {
            color: var(--accent-gold);
            font-weight: 500;
        }

        .game-phase {
            text-align: center;
            padding: 12px;
            background: var(--accent-gold-dim);
            color: var(--bg-dark);
            border-radius: 6px;
            font-weight: 600;
            font-size: 14px;
        }

        .army-display {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid var(--border);
        }

        .army-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .army-title.player1 { color: var(--player1); }
        .army-title.player2 { color: var(--player2); }

        .army-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .army-piece {
            width: 36px;
            height: 36px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.15s;
            border: 2px solid transparent;
        }

        .army-piece:hover {
            transform: scale(1.1);
        }

        .army-piece.player1 { background: var(--player1-dim); }
        .army-piece.player2 { background: var(--player2-dim); }
        .army-piece.dead { opacity: 0.3; pointer-events: none; }
        .army-piece.pinned { border-color: var(--pin-indicator); }

        /* Board Area */
        .board-area {
            display: flex;
            align-items: center;
            justify-content: center;
            background: 
                radial-gradient(ellipse at center, rgba(212, 175, 55, 0.03) 0%, transparent 60%),
                var(--bg-dark);
            position: relative;
        }

        #game-board {
            cursor: default;
        }

        .hex {
            fill: var(--bg-hex);
            stroke: var(--border);
            stroke-width: 1;
            transition: fill 0.15s;
            cursor: pointer;
        }

        /* Ring colors - distinct variations to help identify pins */
        .hex.ring-0 {
            fill: rgba(212, 175, 55, 0.3); /* Throne ring - gold tint */
        }

        .hex.ring-1 {
            fill: #0a0a0e;
            stroke: rgba(80, 20, 20, 0.7);
        }

        .hex.ring-2 {
            fill: #0e0e14;
            stroke: rgba(20, 80, 20, 0.7);
        }

        .hex.ring-3 {
            fill: #121218;
            stroke: rgba(20, 20, 80, 0.7);
        }

        .hex.ring-4 {
            fill: #16161c;
            stroke: rgba(80, 40, 20, 0.7);
        }

        .hex.ring-5 {
            fill: #1a1a20;
            stroke: rgba(40, 20, 80, 0.7);
        }

        .hex:hover {
            fill: var(--bg-hex-hover);
        }

        .hex.throne {
            fill: rgba(212, 175, 55, 0.15);
            stroke: var(--accent-gold);
            stroke-width: 2;
        }

        .hex.valid-move {
            fill: var(--valid-move);
        }

        .hex.damage-path {
            fill: var(--damage-path);
        }

        .hex.selected {
            stroke: var(--accent-gold);
            stroke-width: 3;
        }

        .hex.path-step {
            fill: var(--path-highlight);
            stroke: var(--path-highlight);
            stroke-width: 2;
        }

        .hex.path-end {
            fill: var(--path-end-highlight);
            stroke: var(--path-end-highlight);
            stroke-width: 3;
        }

        /* Keep throne's yellow outline visible even when part of a path */
        .hex.throne.path-step,
        .hex.throne.path-end {
            stroke: var(--accent-gold);
            stroke-width: 3;
        }

        .piece {
            cursor: pointer;
        }

        .piece.selected {
            filter: drop-shadow(0 0 8px var(--accent-gold));
        }

        .piece.pinned {
            filter: drop-shadow(0 0 6px var(--pin-indicator));
        }

        .piece.used {
            opacity: 0.5;
            filter: grayscale(0.7);
        }

        .piece.used.pinned {
            opacity: 0.5;
            filter: grayscale(0.7) drop-shadow(0 0 6px var(--pin-indicator));
        }

        .piece-hp {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            fill: white;
            text-anchor: middle;
            pointer-events: none;
        }

        .ring-highlight {
            fill: none;
            stroke: var(--accent-gold);
            stroke-width: 2;
            stroke-dasharray: 5 5;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .ring-highlight.active {
            opacity: 0.6;
        }

        /* Controls */
        .game-controls {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
        }

        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 10px 20px;
            border: 1px solid var(--border);
            background: var(--bg-panel);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover {
            background: var(--bg-hex);
            border-color: var(--accent-gold-dim);
        }

        .btn.primary {
            background: var(--accent-gold-dim);
            color: var(--bg-dark);
            border-color: var(--accent-gold);
        }

        .btn.primary:hover {
            background: var(--accent-gold);
        }

        .btn.rotate {
            background: var(--accent-gold);
            color: var(--bg-dark);
            border-color: var(--accent-gold);
            font-weight: 500;
        }

        .btn.rotate:hover {
            background: #e8c34a;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Right Panel - Parameters */
        .param-section {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid var(--border);
        }

        .param-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
        }

        .param-row:last-child {
            border-bottom: none;
        }

        .param-label {
            font-size: 13px;
            color: var(--text-muted);
        }

        .param-input {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            width: 60px;
            padding: 6px 8px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-primary);
            border-radius: 4px;
            text-align: center;
        }

        .param-input:focus {
            outline: none;
            border-color: var(--accent-gold-dim);
        }

        .param-input:disabled {
            background: var(--bg-hex);
            color: var(--text-muted);
            opacity: 0.5;
            cursor: not-allowed;
        }

        select.param-input {
            width: 100px;
        }

        /* Unit Editor */
        .unit-editor {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid var(--border);
        }

        .unit-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }

        .unit-btn {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            border: 2px solid var(--border);
            background: var(--bg-dark);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 18px;
            transition: all 0.15s;
        }

        .unit-btn:hover, .unit-btn.active {
            border-color: var(--accent-gold);
        }

        .unit-btn.player1 { background: var(--player1-dim); }
        .unit-btn.player2 { background: var(--player2-dim); }

        .template-selector {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 12px 0;
        }

        .template-btn {
            padding: 12px;
            border: 2px solid var(--border);
            background: var(--bg-dark);
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-primary);
            text-align: center;
            transition: all 0.15s;
        }

        .template-btn:hover {
            border-color: var(--accent-gold-dim);
            background: var(--bg-hex);
        }

        .template-btn.active {
            background: var(--accent-gold-dim);
            border-color: var(--accent-gold);
            color: var(--bg-dark);
        }

        /* Victory Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: var(--bg-panel);
            border: 1px solid var(--accent-gold);
            border-radius: 12px;
            padding: 48px;
            text-align: center;
            max-width: 400px;
        }

        .modal h2 {
            font-size: 32px;
            margin-bottom: 16px;
            color: var(--accent-gold);
        }

        .modal p {
            font-size: 18px;
            color: var(--text-muted);
            margin-bottom: 32px;
        }

        /* Placement Mode */
        .placement-palette {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid var(--border);
        }

        .placement-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .placement-piece {
            width: 44px;
            height: 44px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s;
            position: relative;
        }

        .placement-piece:hover {
            transform: scale(1.05);
        }

        .placement-piece.selected {
            border-color: var(--accent-gold);
            box-shadow: 0 0 12px rgba(212, 175, 55, 0.4);
        }

        .placement-piece.placed {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .placement-piece .count {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: 10px;
            background: var(--bg-dark);
            padding: 1px 4px;
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
        }

        /* Log */
        .game-log {
            background: var(--bg-hex);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid var(--border);
            max-height: 200px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }

        .log-entry {
            padding: 4px 0;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry.player1 { color: var(--player1); }
        .log-entry.player2 { color: var(--player2); }
        .log-entry.system { color: var(--accent-gold); }

        /* Rotation UI */
        .rotation-controls {
            position: absolute;
            display: flex;
            gap: 8px;
            background: var(--bg-panel);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--accent-gold);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .rotation-controls button {
            width: 36px;
            height: 36px;
            border-radius: 4px;
            border: 1px solid var(--border);
            background: var(--bg-hex);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 16px;
        }

        .rotation-controls button:hover {
            background: var(--accent-gold-dim);
            color: var(--bg-dark);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Left Panel -->
        <div class="panel">
            <div class="logo">THRONE</div>
            
            <div class="turn-indicator player1" id="turn-indicator">
                <div class="player-name">Player 1</div>
                <div class="actions-remaining">Actions: <span id="actions-count">2</span>/2</div>
            </div>

            <div class="game-phase" id="game-phase">BATTLE PHASE</div>

            <div class="army-display">
                <div class="army-title player1">⬢ Player 1 Army</div>
                <div class="army-pieces" id="army-p1"></div>
            </div>

            <div class="army-display">
                <div class="army-title player2">⬢ Player 2 Army</div>
                <div class="army-pieces" id="army-p2"></div>
            </div>

            <div class="game-log" id="game-log">
                <div class="log-entry system">Game initialized.</div>
            </div>
        </div>

        <!-- Board Area -->
        <div class="board-area">
            <svg id="game-board" width="700" height="700"></svg>
            <div class="game-controls">
                <button class="btn" id="btn-reset">Reset Game</button>
                <button class="btn rotate" id="btn-rotate" style="display: none;">↻ Rotate Ring</button>
                <button class="btn primary" id="btn-confirm-path" style="display: none;">Confirm Move</button>
                <button class="btn" id="btn-cancel-path" style="display: none;">Cancel</button>
                <button class="btn" id="btn-end-turn">End Turn</button>
            </div>
            <div class="rotation-controls" id="rotation-controls" style="display: none;">
                <button id="rotate-ccw">↺</button>
                <span style="display: flex; align-items: center; font-size: 12px; color: var(--text-muted);">Ring <span id="rotation-ring">1</span></span>
                <button id="rotate-cw">↻</button>
                <button id="rotate-cancel" style="margin-left: 8px; font-size: 12px;">✕</button>
            </div>
        </div>

        <!-- Right Panel - Parameters -->
        <div class="panel panel-right">
            <div class="panel-title">Game Parameters</div>
            <div class="param-section">
                <div class="param-row">
                    <span class="param-label">Actions/Turn</span>
                    <input type="number" class="param-input" id="param-actions" value="2" min="1" max="4">
                </div>
            </div>

            <div class="panel-title" style="margin-top: 16px;">Unit Editor</div>
            <div class="unit-editor">
                <div class="unit-selector" id="unit-selector"></div>
                <div id="unit-details" style="display: none;">
                    <div class="param-row">
                        <span class="param-label">Max HP</span>
                        <input type="number" class="param-input" id="unit-hp" value="3" min="1" max="10">
                    </div>
                    <div class="param-row">
                        <span class="param-label">Ram Damage</span>
                        <input type="number" class="param-input" id="unit-ram-damage" value="1" min="1" max="5">
                    </div>
                    <div class="param-row">
                        <span class="param-label">Move Range</span>
                        <input type="number" class="param-input" id="unit-range" value="3" min="1" max="6">
                    </div>
                    <div class="panel-title" style="margin-top: 12px; margin-bottom: 8px;">Movement Template</div>
                    <div class="template-selector" id="template-selector"></div>
                </div>
            </div>

            <div class="panel-title" style="margin-top: 16px;">Instructions</div>
            <div class="param-section" style="font-size: 13px; color: var(--text-muted); line-height: 1.6;">
                <p><strong>Movement:</strong> Click a piece to start path building. Click adjacent hexes to build your path step-by-step. Click the last hex again or "Confirm Move" to execute. Press Escape or "Cancel" to abort.</p>
                <p style="margin-top: 8px;"><strong>Rotation:</strong> Select your King, then tap "↻ Rotate Ring" button. Select a ring number, then tap ↺ or ↻ to rotate.</p>
                <p style="margin-top: 8px;"><strong>Victory:</strong> Capture the Throne, eliminate all enemy units, or pin + ram the enemy King.</p>
            </div>
        </div>
    </div>

    <!-- Victory Modal -->
    <div class="modal-overlay" id="victory-modal">
        <div class="modal">
            <h2 id="victory-title">Victory!</h2>
            <p id="victory-message">Player 1 wins by capturing the Throne!</p>
            <button class="btn primary" id="btn-new-game">New Game</button>
        </div>
    </div>

    <script>
        // ============================================
        // THRONE - Tactical Hex Duel Prototype
        // ============================================

        const HEX_SIZE = 38;
        const BOARD_RADIUS = 5;
        const CENTER_X = 350;
        const CENTER_Y = 350;

        // Hex directions (pointy-top)
        const HEX_DIRECTIONS = [
            { q: 1, r: 0 },   // E
            { q: 1, r: -1 },  // NE
            { q: 0, r: -1 },  // NW
            { q: -1, r: 0 },  // W
            { q: -1, r: 1 },  // SW
            { q: 0, r: 1 },   // SE
        ];

        const PIECE_TYPES = {
            KING: { symbol: '♚', name: 'King', defaultHP: Infinity, isKing: true },
            PAWN: { symbol: '♟', name: 'Pawn', defaultHP: 2, isKing: false },
            KNIGHT: { symbol: '♞', name: 'Knight', defaultHP: 4, isKing: false },
            ROOK: { symbol: '♜', name: 'Rook', defaultHP: 6, isKing: false },
            BISHOP: { symbol: '♝', name: 'Bishop', defaultHP: 4, isKing: false },
            LANCE: { symbol: '⚔', name: 'Lance', defaultHP: 4, isKing: false },
        };

        // Game state
        let gameState = {
            phase: 'playing', // playing, ended
            currentPlayer: 1,
            actionsRemaining: 2,
            actionsPerTurn: 2,
            isFirstTurn: true,
            usedPieces: new Set(),
            hasAnyPieceMoved: false,
            pieces: [],
            board: new Map(), // hex key -> piece
            pinningPaths: [], // Store paths that create pins for visualization
            pinningMap: new Map(), // Map: enemy piece index -> Set of ally piece indices that are pinning it
            selectedPiece: null,
            validMoves: [],
            rotationMode: false,
            selectedRing: null,
            pathBuilding: false,
            currentPath: [],
            pathStartPiece: null,
            params: {
                actionsPerTurn: 2
            },
            unitConfigs: {}
        };

        // Movement templates
        const MOVEMENT_TEMPLATES = {
            FREE_MOTION: 'free_motion',
            STRAIGHT_LINE: 'straight_line'
        };

        // Initialize unit configs with default movement patterns
        function initUnitConfigs() {
            // King: free motion, range 1
            gameState.unitConfigs['KING'] = {
                range: 1,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: Infinity,
                ramDamage: 4
            };
            // Pawn: free motion, range 2
            gameState.unitConfigs['PAWN'] = {
                range: 2,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: 2,
                ramDamage: 1
            };
            // Knight: free motion, range 3
            gameState.unitConfigs['KNIGHT'] = {
                range: 3,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: 4,
                ramDamage: 2
            };
            // Rook: free motion
            gameState.unitConfigs['ROOK'] = {
                range: 2,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: 6,
                ramDamage: 3
            };
            // Bishop: straight line
            gameState.unitConfigs['BISHOP'] = {
                range: 5,
                template: MOVEMENT_TEMPLATES.STRAIGHT_LINE,
                hp: 4,
                ramDamage: 2
            };
            // Lance: free motion
            gameState.unitConfigs['LANCE'] = {
                range: 1,
                template: MOVEMENT_TEMPLATES.FREE_MOTION,
                hp: 4,
                ramDamage: 2
            };
        }

        // ============================================
        // HEX MATH
        // ============================================

        function hexKey(q, r) {
            return `${q},${r}`;
        }

        function parseHexKey(key) {
            const [q, r] = key.split(',').map(Number);
            return { q, r };
        }

        function hexToPixel(q, r) {
            const x = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r) + CENTER_X;
            const y = HEX_SIZE * (3 / 2 * r) + CENTER_Y;
            return { x, y };
        }

        function pixelToHex(x, y) {
            const px = x - CENTER_X;
            const py = y - CENTER_Y;
            const q = (Math.sqrt(3) / 3 * px - 1 / 3 * py) / HEX_SIZE;
            const r = (2 / 3 * py) / HEX_SIZE;
            return hexRound(q, r);
        }

        function hexRound(q, r) {
            const s = -q - r;
            let rq = Math.round(q);
            let rr = Math.round(r);
            let rs = Math.round(s);

            const qDiff = Math.abs(rq - q);
            const rDiff = Math.abs(rr - r);
            const sDiff = Math.abs(rs - s);

            if (qDiff > rDiff && qDiff > sDiff) {
                rq = -rr - rs;
            } else if (rDiff > sDiff) {
                rr = -rq - rs;
            }

            return { q: rq, r: rr };
        }

        function hexDistance(q1, r1, q2, r2) {
            return (Math.abs(q1 - q2) + Math.abs(q1 + r1 - q2 - r2) + Math.abs(r1 - r2)) / 2;
        }

        function getRing(q, r) {
            return hexDistance(0, 0, q, r);
        }

        function isValidHex(q, r) {
            return getRing(q, r) <= BOARD_RADIUS;
        }

        function getHexCorners(cx, cy, size) {
            const corners = [];
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 180 * (60 * i - 30);
                corners.push({
                    x: cx + size * Math.cos(angle),
                    y: cy + size * Math.sin(angle)
                });
            }
            return corners;
        }

        function hexNeighbor(q, r, direction) {
            const d = HEX_DIRECTIONS[direction];
            return { q: q + d.q, r: r + d.r };
        }

        function getHexesInRing(ring) {
            if (ring === 0) return [{ q: 0, r: 0 }];
            
            const hexes = [];
            let hex = { q: ring, r: 0 }; // Start at E
            
            for (let dir = 2; dir < 8; dir++) {
                const actualDir = dir % 6;
                for (let i = 0; i < ring; i++) {
                    hexes.push({ ...hex });
                    hex = hexNeighbor(hex.q, hex.r, actualDir);
                }
            }
            
            return hexes;
        }

        function rotateHexAroundCenter(q, r, steps) {
            // Rotate a hex position around center by steps * 60 degrees
            // Using cube coordinates for rotation
            const s = -q - r;
            let newQ = q, newR = r, newS = s;
            
            const absSteps = Math.abs(steps);
            const direction = steps > 0 ? 1 : -1;
            
            for (let i = 0; i < absSteps; i++) {
                if (direction > 0) {
                    // Clockwise
                    [newQ, newR, newS] = [-newR, -newS, -newQ];
                } else {
                    // Counter-clockwise
                    [newQ, newR, newS] = [-newS, -newQ, -newR];
                }
            }
            
            return { q: newQ, r: newR };
        }

        // ============================================
        // FIXED STARTING POSITIONS
        // ============================================

        function setupFixedPositions() {
            gameState.pieces = [];
            
            // Pick a random corner for player 1 (6 possible corners on ring 5)
            const corners = [
                { q: 5, r: 0 },   // E
                { q: 0, r: -5 }, // NW
                { q: -5, r: 5 }, // W
                { q: -5, r: 0 }, // W (different)
                { q: 0, r: 5 },  // SE
                { q: 5, r: -5 }  // NE
            ];
            const p1Corner = corners[Math.floor(Math.random() * corners.length)];
            
            // Player 2 gets opposite corner (rotate 180 degrees)
            const p2Corner = rotateHexAroundCenter(p1Corner.q, p1Corner.r, 3);
            
            // Place Player 1 pieces
            placeArmy(1, p1Corner);
            
            // Place Player 2 pieces
            placeArmy(2, p2Corner);
            
            // Update pins after placement
            updatePins();
        }

        function placeArmy(player, kingCorner) {
            // King at ring 5 corner
            createPiece('KING', player, kingCorner.q, kingCorner.r);
            
            // Find direction toward center from king corner
            // Calculate which direction points most toward (0,0)
            let bestDir = 0;
            let minDist = Infinity;
            for (let dir = 0; dir < 6; dir++) {
                const neighbor = hexNeighbor(kingCorner.q, kingCorner.r, dir);
                const dist = hexDistance(0, 0, neighbor.q, neighbor.r);
                if (dist < minDist) {
                    minDist = dist;
                    bestDir = dir;
                }
            }
            
            // Find hexes on ring 4 that are neighbors of the king
            const ring4Candidates = [];
            for (let dir = 0; dir < 6; dir++) {
                const neighbor = hexNeighbor(kingCorner.q, kingCorner.r, dir);
                if (getRing(neighbor.q, neighbor.r) === 4 && isValidHex(neighbor.q, neighbor.r)) {
                    ring4Candidates.push({ pos: neighbor, dir: dir });
                }
            }
            
            // Sort by proximity to the "inward" direction
            ring4Candidates.sort((a, b) => {
                const aDist = Math.abs((a.dir - bestDir + 6) % 6);
                const bDist = Math.abs((b.dir - bestDir + 6) % 6);
                return aDist - bDist;
            });
            
            // Take first 3 positions for Bishop, Knight, Rook
            const ring4Positions = ring4Candidates.slice(0, 3).map(c => c.pos);
            
            // Ensure we have 3 positions (fallback to any ring 4 neighbors)
            if (ring4Positions.length < 3) {
                const allRing4 = getHexesInRing(4);
                for (const hex of allRing4) {
                    if (hexDistance(kingCorner.q, kingCorner.r, hex.q, hex.r) <= 2) {
                        if (!ring4Positions.some(p => p.q === hex.q && p.r === hex.r)) {
                            ring4Positions.push(hex);
                            if (ring4Positions.length >= 3) break;
                        }
                    }
                }
            }
            
            // Place Rook, Knight, Bishop on ring 4 (guaranteed 3 positions)
            if (ring4Positions.length >= 1) {
                createPiece('ROOK', player, ring4Positions[0].q, ring4Positions[0].r);
            }
            if (ring4Positions.length >= 2) {
                createPiece('KNIGHT', player, ring4Positions[1].q, ring4Positions[1].r);
            }
            if (ring4Positions.length >= 3) {
                createPiece('BISHOP', player, ring4Positions[2].q, ring4Positions[2].r);
            }
            
            // Ring 3: 3 Pawns next to the ring 4 pieces
            const pawnPositions = [];
            
            // Find hexes on ring 3 that are neighbors of the ring 4 pieces
            for (const ring4Pos of ring4Positions) {
                for (let dir = 0; dir < 6; dir++) {
                    const neighbor = hexNeighbor(ring4Pos.q, ring4Pos.r, dir);
                    if (getRing(neighbor.q, neighbor.r) === 3 && 
                        isValidHex(neighbor.q, neighbor.r) &&
                        !pawnPositions.some(p => p.q === neighbor.q && p.r === neighbor.r)) {
                        pawnPositions.push(neighbor);
                    }
                }
            }
            
            // If we don't have 3 pawn positions, find more from ring 3
            if (pawnPositions.length < 3) {
                const allRing3 = getHexesInRing(3);
                for (const hex of allRing3) {
                    // Check if it's near any ring 4 piece
                    let isNear = false;
                    for (const ring4Pos of ring4Positions) {
                        if (hexDistance(hex.q, hex.r, ring4Pos.q, ring4Pos.r) <= 2) {
                            isNear = true;
                            break;
                        }
                    }
                    if (isNear && !pawnPositions.some(p => p.q === hex.q && p.r === hex.r)) {
                        pawnPositions.push(hex);
                        if (pawnPositions.length >= 3) break;
                    }
                }
            }
            
            // Place 3 Pawns (guaranteed to place all 3)
            for (let i = 0; i < 3 && i < pawnPositions.length; i++) {
                createPiece('PAWN', player, pawnPositions[i].q, pawnPositions[i].r);
            }
            
            // If we still don't have 3 pawns, place them anywhere on ring 3
            let currentPawnCount = gameState.pieces.filter(p => p.player === player && p.type === 'PAWN').length;
            if (currentPawnCount < 3) {
                const allRing3 = getHexesInRing(3);
                for (const hex of allRing3) {
                    if (!getPieceAt(hex.q, hex.r) && currentPawnCount < 3) {
                        createPiece('PAWN', player, hex.q, hex.r);
                        currentPawnCount++;
                    }
                }
            }
            
            // Get all pawn positions for lance placement check
            const pawnPositionsList = gameState.pieces
                .filter(p => p.player === player && p.type === 'PAWN')
                .map(p => ({ q: p.q, r: p.r }));
            
            // Ring 2: Lance should be adjacent to all ally pawns (which are on ring 3)
            const ring2Hexes = getHexesInRing(2);
            let lancePosition = null;
            let maxAdjacentPawns = 0;
            
            // Find a hex on ring 2 that is adjacent to as many pawns as possible
            // Ideally adjacent to all 3 pawns
            for (const hex of ring2Hexes) {
                if (getPieceAt(hex.q, hex.r)) continue; // Skip if occupied
                
                // Count how many pawns this hex is adjacent to
                let adjacentPawnCount = 0;
                for (const pawn of pawnPositionsList) {
                    if (hexDistance(hex.q, hex.r, pawn.q, pawn.r) === 1) {
                        adjacentPawnCount++;
                    }
                }
                
                // Prefer positions adjacent to more pawns
                if (adjacentPawnCount > maxAdjacentPawns) {
                    maxAdjacentPawns = adjacentPawnCount;
                    lancePosition = hex;
                }
            }
            
            // If we found a position adjacent to at least one pawn, use it
            // Otherwise, find any ring 2 hex that's adjacent to at least one pawn
            if (!lancePosition || maxAdjacentPawns === 0) {
                for (const hex of ring2Hexes) {
                    if (getPieceAt(hex.q, hex.r)) continue;
                    
                    // Check if adjacent to any pawn
                    for (const pawn of pawnPositionsList) {
                        if (hexDistance(hex.q, hex.r, pawn.q, pawn.r) === 1) {
                            lancePosition = hex;
                            break;
                        }
                    }
                    if (lancePosition) break;
                }
            }
            
            // Final fallback: just pick first available ring 2 hex
            if (!lancePosition && ring2Hexes.length > 0) {
                for (const hex of ring2Hexes) {
                    if (!getPieceAt(hex.q, hex.r)) {
                        lancePosition = hex;
                        break;
                    }
                }
            }
            
            if (lancePosition) {
                createPiece('LANCE', player, lancePosition.q, lancePosition.r);
            }
            
            // Verify all pieces were created
            const pieces = gameState.pieces.filter(p => p.player === player);
            const pieceCounts = {
                KING: pieces.filter(p => p.type === 'KING').length,
                PAWN: pieces.filter(p => p.type === 'PAWN').length,
                KNIGHT: pieces.filter(p => p.type === 'KNIGHT').length,
                ROOK: pieces.filter(p => p.type === 'ROOK').length,
                BISHOP: pieces.filter(p => p.type === 'BISHOP').length,
                LANCE: pieces.filter(p => p.type === 'LANCE').length
            };
            
            // Ensure we have all required pieces, create missing ones if needed
            if (pieceCounts.KING === 0) {
                createPiece('KING', player, kingCorner.q, kingCorner.r);
            }
            if (pieceCounts.ROOK === 0 && ring4Positions.length > 0) {
                createPiece('ROOK', player, ring4Positions[0].q, ring4Positions[0].r);
            }
            if (pieceCounts.KNIGHT === 0 && ring4Positions.length > 1) {
                createPiece('KNIGHT', player, ring4Positions[1].q, ring4Positions[1].r);
            }
            if (pieceCounts.BISHOP === 0 && ring4Positions.length > 2) {
                createPiece('BISHOP', player, ring4Positions[2].q, ring4Positions[2].r);
            }
            if (pieceCounts.PAWN < 3) {
                const allRing3 = getHexesInRing(3);
                for (const hex of allRing3) {
                    if (!getPieceAt(hex.q, hex.r) && pieceCounts.PAWN < 3) {
                        createPiece('PAWN', player, hex.q, hex.r);
                        pieceCounts.PAWN++;
                    }
                }
            }
            if (pieceCounts.LANCE === 0) {
                const allRing2 = getHexesInRing(2);
                for (const hex of allRing2) {
                    if (!getPieceAt(hex.q, hex.r)) {
                        createPiece('LANCE', player, hex.q, hex.r);
                        break;
                    }
                }
            }
        }


        function createPiece(type, player, q, r) {
            const config = gameState.unitConfigs[type];
            const hp = config.hp === Infinity ? Infinity : config.hp;
            
            const piece = {
                type,
                player,
                q, r,
                hp,
                maxHP: hp,
                alive: true,
                pinned: false
            };
            
            gameState.pieces.push(piece);
        }

        // ============================================
        // BOARD RENDERING
        // ============================================

        function createBoard() {
            const svg = document.getElementById('game-board');
            svg.innerHTML = '';

            // Create hex group
            const hexGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            hexGroup.id = 'hex-group';
            svg.appendChild(hexGroup);

            // Create ring highlight paths for rotation
            for (let ring = 1; ring <= BOARD_RADIUS; ring++) {
                const ringHexes = getHexesInRing(ring);
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.id = `ring-${ring}`;
                path.classList.add('ring-highlight');
                
                // Create path around ring
                let d = '';
                ringHexes.forEach((hex, i) => {
                    const { x, y } = hexToPixel(hex.q, hex.r);
                    if (i === 0) {
                        d += `M ${x} ${y}`;
                    } else {
                        d += ` L ${x} ${y}`;
                    }
                });
                d += ' Z';
                path.setAttribute('d', d);
                svg.appendChild(path);
            }

            // Create hexes
            for (let q = -BOARD_RADIUS; q <= BOARD_RADIUS; q++) {
                for (let r = -BOARD_RADIUS; r <= BOARD_RADIUS; r++) {
                    if (!isValidHex(q, r)) continue;

                    const { x, y } = hexToPixel(q, r);
                    const corners = getHexCorners(x, y, HEX_SIZE - 2);
                    
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', corners.map(c => `${c.x},${c.y}`).join(' '));
                    polygon.classList.add('hex');
                    polygon.dataset.q = q;
                    polygon.dataset.r = r;
                    
                    const ring = getRing(q, r);
                    polygon.classList.add(`ring-${ring}`);
                    polygon.dataset.ring = ring;
                    
                    if (q === 0 && r === 0) {
                        polygon.classList.add('throne');
                    }
                    
                    polygon.addEventListener('click', (e) => onHexClick(q, r, e));
                    hexGroup.appendChild(polygon);
                }
            }

            // Create pinning paths group (rendered behind pieces)
            const pinningGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            pinningGroup.id = 'pinning-paths-group';
            svg.appendChild(pinningGroup);

            // Create piece group
            const pieceGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            pieceGroup.id = 'piece-group';
            svg.appendChild(pieceGroup);
        }

        function renderPieces() {
            const pieceGroup = document.getElementById('piece-group');
            pieceGroup.innerHTML = '';

            gameState.pieces.forEach((piece, index) => {
                if (!piece.alive) return;

                const { x, y } = hexToPixel(piece.q, piece.r);
                
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.classList.add('piece');
                g.dataset.index = index;
                
                if (gameState.selectedPiece === index) {
                    g.classList.add('selected');
                }
                if (piece.pinned) {
                    g.classList.add('pinned');
                }
                if (gameState.usedPieces.has(index)) {
                    g.classList.add('used');
                }

                // Piece background
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', HEX_SIZE * 0.6);
                circle.setAttribute('fill', piece.player === 1 ? '#c94c4c' : '#4c8bc9');
                circle.setAttribute('stroke', piece.player === 1 ? '#8a3535' : '#35628a');
                circle.setAttribute('stroke-width', 2);
                g.appendChild(circle);

                // Piece symbol
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y + 6);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '24');
                text.setAttribute('fill', 'white');
                text.setAttribute('pointer-events', 'none');
                text.textContent = PIECE_TYPES[piece.type].symbol;
                g.appendChild(text);

                // HP indicator (not for King)
                if (!PIECE_TYPES[piece.type].isKing && piece.hp < Infinity) {
                    const hpText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    hpText.setAttribute('x', x + HEX_SIZE * 0.4);
                    hpText.setAttribute('y', y - HEX_SIZE * 0.3);
                    hpText.classList.add('piece-hp');
                    hpText.textContent = piece.hp;
                    g.appendChild(hpText);
                }

                g.addEventListener('click', (e) => {
                    e.stopPropagation();
                    onPieceClick(index);
                });

                pieceGroup.appendChild(g);
            });
        }

        function highlightValidMoves(moves) {
            // Clear previous highlights
            document.querySelectorAll('.hex.valid-move, .hex.damage-path').forEach(el => {
                el.classList.remove('valid-move', 'damage-path');
            });

            moves.forEach(move => {
                const hex = document.querySelector(`.hex[data-q="${move.q}"][data-r="${move.r}"]`);
                if (hex) {
                    hex.classList.add(move.willKill ? 'damage-path' : 'valid-move');
                }
                
                // Highlight damage path
                if (move.damagePath) {
                    move.damagePath.forEach(pos => {
                        const pathHex = document.querySelector(`.hex[data-q="${pos.q}"][data-r="${pos.r}"]`);
                        if (pathHex) pathHex.classList.add('damage-path');
                    });
                }
            });
        }

        function clearHighlights() {
            document.querySelectorAll('.hex.valid-move, .hex.damage-path, .hex.selected, .hex.path-step, .hex.path-end').forEach(el => {
                el.classList.remove('valid-move', 'damage-path', 'selected', 'path-step', 'path-end');
            });
        }

        // ============================================
        // GAME LOGIC
        // ============================================

        function getValidMoves(piece) {
            if (!piece.alive || piece.pinned) return [];
            
            const config = gameState.unitConfigs[piece.type];
            const maxRange = config.range;
            // For templates, all directions are valid for path finding
            // Template restrictions are enforced during path building
            const validDirections = [0, 1, 2, 3, 4, 5];
            
            // Use BFS to find all reachable positions
            // Track all paths to each destination, then select the best one
            const bestPaths = new Map(); // key -> { move, damageCount, distance }
            const queue = [{
                q: piece.q,
                r: piece.r,
                distance: 0,
                damagePath: [],
                path: [{ q: piece.q, r: piece.r }]
            }];
            
            // Track visited states: key -> Set of (distance, damageCount) pairs
            // This allows revisiting if we find a better path (more damage or shorter)
            const visited = new Map(); // key -> Set of "distance,damageCount" strings
            
            function getVisitedKey(distance, damageCount) {
                return `${distance},${damageCount}`;
            }
            
            function isBetterPath(newDistance, newDamageCount, existing) {
                if (!existing) return true;
                // Prefer paths with more damage, or if same damage, shorter path
                for (const state of existing) {
                    const [dist, dmg] = state.split(',').map(Number);
                    if (dmg > newDamageCount) return false; // Existing has more damage
                    if (dmg === newDamageCount && dist <= newDistance) return false; // Same damage, shorter or equal
                }
                return true;
            }
            
            function addVisited(key, distance, damageCount) {
                if (!visited.has(key)) {
                    visited.set(key, new Set());
                }
                visited.get(key).add(getVisitedKey(distance, damageCount));
            }
            
            function shouldExplore(key, distance, damageCount) {
                const existing = visited.get(key);
                if (!existing) return true;
                return isBetterPath(distance, damageCount, existing);
            }
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Stop if we've reached max range
                if (current.distance >= maxRange) continue;
                
                // Try moving in all valid directions from current position
                validDirections.forEach(dir => {
                    const next = hexNeighbor(current.q, current.r, dir);
                    const nextKey = hexKey(next.q, next.r);
                    
                    // Check if valid hex
                    if (!isValidHex(next.q, next.r)) return;
                    
                    const newDistance = current.distance + 1;
                    const occupant = getPieceAt(next.q, next.r);
                    const newDamagePath = [...current.damagePath];
                    let newDamageCount = newDamagePath.length;
                    
                    // If there's an enemy here, add to damage path
                    if (occupant && occupant.player !== piece.player) {
                        newDamagePath.push({ q: next.q, r: next.r, piece: occupant });
                        newDamageCount = newDamagePath.length;
                    }
                    
                    // Check if we should explore this path
                    if (!shouldExplore(nextKey, newDistance, newDamageCount)) {
                        return;
                    }
                    
                    const newPath = [...current.path, { q: next.q, r: next.r }];
                    const newState = {
                        q: next.q,
                        r: next.r,
                        distance: newDistance,
                        damagePath: newDamagePath,
                        damageCount: newDamageCount,
                        path: newPath
                    };
                    
                    // If there's a friendly, we can pass through but can't end here
                    if (occupant && occupant.player === piece.player) {
                        // Can pass through - continue exploring
                        addVisited(nextKey, newDistance, newDamageCount);
                        queue.push(newState);
                        return;
                    }
                    
                    // Empty hex or enemy hex - can potentially end here
                    addVisited(nextKey, newDistance, newDamageCount);
                    
                    // Check if we can end on this hex
                    let isValidDestination = false;
                    let wouldKill = false;
                    
                    if (occupant && occupant.player !== piece.player) {
                        // Check if the attacker is pinning this target
                        const occupantIndex = gameState.pieces.indexOf(occupant);
                        const attackerIndex = gameState.pieces.indexOf(piece);
                        const isPinningPiece = occupantIndex >= 0 &&
                                               attackerIndex >= 0 &&
                                               gameState.pinningMap.has(occupantIndex) &&
                                               gameState.pinningMap.get(occupantIndex).has(attackerIndex);
                        
                        // If the attacker is pinning the target, they can't insta-kill it
                        // They must deal enough damage to kill it normally
                        if (isPinningPiece && occupant.pinned) {
                            // Attacker is pinning the target - must kill with damage, not insta-kill
                            wouldKill = canKillWithRam(piece, occupant, newDamageCount + 1);
                        } else {
                            // Normal case: pinned pieces die instantly (unless pinned by attacker)
                            wouldKill = occupant.pinned || canKillWithRam(piece, occupant, newDamageCount + 1);
                        }
                        isValidDestination = wouldKill;
                    } else {
                        // Empty hex - valid destination
                        isValidDestination = true;
                    }
                    
                    if (isValidDestination) {
                        // Check if this is a better path to this destination
                        const existing = bestPaths.get(nextKey);
                        const isBetter = !existing || 
                            newDamageCount > existing.damageCount ||
                            (newDamageCount === existing.damageCount && newDistance < existing.distance);
                        
                        if (isBetter) {
                            bestPaths.set(nextKey, {
                                q: next.q,
                                r: next.r,
                                damagePath: newDamagePath,
                                damageCount: newDamageCount,
                                willKill: wouldKill,
                                path: newPath,
                                distance: newDistance
                            });
                        }
                    }
                    
                    // Continue exploring from this position
                    queue.push(newState);
                });
            }
            
            return Array.from(bestPaths.values()).map(({ willKill, damagePath, path, q, r }) => ({
                q, r, damagePath, willKill, path
            }));
        }

        function getValidNextSteps(piece, currentPath) {
            // Pinned pieces cannot move
            if (!piece.alive || piece.pinned) return [];
            
            // Get valid adjacent hexes for the next step in path building
            const config = gameState.unitConfigs[piece.type];
            const maxRange = config.range;
            
            // If path is at max range, no more steps
            if (currentPath.length >= maxRange) return [];
            
            const currentPos = currentPath.length > 0 
                ? currentPath[currentPath.length - 1]
                : { q: piece.q, r: piece.r };
            
            // Determine valid directions based on template
            let validDirections = [];
            
            if (config.template === MOVEMENT_TEMPLATES.FREE_MOTION) {
                // Free motion: can move in any direction
                validDirections = [0, 1, 2, 3, 4, 5];
            } else if (config.template === MOVEMENT_TEMPLATES.STRAIGHT_LINE) {
                // Straight line: must continue in the same direction
                if (currentPath.length === 0) {
                    // First step: can choose any direction
                    validDirections = [0, 1, 2, 3, 4, 5];
                } else {
                    // Subsequent steps: must continue in the same direction
                    // Find the direction from the previous position to the current position
                    let fromPos, toPos;
                    if (currentPath.length === 1) {
                        // From piece position to first step
                        fromPos = { q: piece.q, r: piece.r };
                        toPos = currentPath[0];
                    } else {
                        // From previous step to current step
                        fromPos = currentPath[currentPath.length - 2];
                        toPos = currentPath[currentPath.length - 1];
                    }
                    
                    // Find the direction from fromPos to toPos
                    let direction = -1;
                    for (let dir = 0; dir < 6; dir++) {
                        const neighbor = hexNeighbor(fromPos.q, fromPos.r, dir);
                        if (neighbor.q === toPos.q && neighbor.r === toPos.r) {
                            direction = dir;
                            break;
                        }
                    }
                    
                    // If we found the direction, only allow that direction
                    if (direction >= 0) {
                        validDirections = [direction];
                    } else {
                        // Fallback: if we can't determine direction, allow all (shouldn't happen)
                        validDirections = [0, 1, 2, 3, 4, 5];
                    }
                }
            }
            
            const validNext = [];
            
            validDirections.forEach(dir => {
                const next = hexNeighbor(currentPos.q, currentPos.r, dir);
                
                if (!isValidHex(next.q, next.r)) return;
                
                // Check if already in path (can't backtrack)
                const alreadyInPath = currentPath.some(step => step.q === next.q && step.r === next.r);
                if (alreadyInPath) return;
                
                const occupant = getPieceAt(next.q, next.r);
                
                // Can pass through friendlies, but can't end on them
                // Can pass through enemies (will damage), can end on them if they'd die
                validNext.push({
                    q: next.q,
                    r: next.r,
                    hasEnemy: occupant && occupant.player !== piece.player,
                    hasFriendly: occupant && occupant.player === piece.player,
                    occupant: occupant
                });
            });
            
            return validNext;
        }

        function calculateDamagePath(piece, path) {
            // Calculate which enemies would be damaged along this path
            const damagePath = [];
            path.forEach(step => {
                const occupant = getPieceAt(step.q, step.r);
                if (occupant && occupant.player !== piece.player) {
                    damagePath.push({ q: step.q, r: step.r, piece: occupant });
                }
            });
            return damagePath;
        }

        function canKillWithRam(attackingPiece, targetPiece, damageTotal) {
            if (PIECE_TYPES[targetPiece.type].isKing) {
                return targetPiece.pinned; // King can only die if pinned
            }
            const ramDamage = gameState.unitConfigs[attackingPiece.type].ramDamage;
            return targetPiece.hp <= damageTotal * ramDamage;
        }

        function getPieceAt(q, r) {
            return gameState.pieces.find(p => p.alive && p.q === q && p.r === r);
        }

        // Simulate killing pieces along path and check if destination would still be killable
        function simulateMoveAndValidate(pieceIndex, targetQ, targetR, move, ramDamage) {
            const piece = gameState.pieces[pieceIndex];
            const destOccupant = getPieceAt(targetQ, targetR);
            
            // If no destination enemy, move is valid
            if (!destOccupant || destOccupant.player === piece.player) {
                return true;
            }
            
            // Create list of pieces that would be killed along the path (excluding destination)
            const piecesToKill = [];
            if (move.damagePath) {
                move.damagePath.forEach(pos => {
                    // Skip destination - it will be handled separately
                    if (pos.q === targetQ && pos.r === targetR) return;
                    
                    const target = pos.piece || getPieceAt(pos.q, pos.r);
                    if (target && target.player !== piece.player) {
                        // Check if this piece would die from the damage
                        if (target.pinned || canKillWithRam(piece, target, 1)) {
                            piecesToKill.push(target);
                        }
                    }
                });
            }
            
            // Temporarily mark pieces as dead to simulate the move
            const originalAliveStates = new Map();
            piecesToKill.forEach(target => {
                originalAliveStates.set(target, target.alive);
                target.alive = false;
            });
            
            // Recalculate pins with simulated kills
            updatePins();
            
            // Check if destination would still be killable after simulated kills
            const destAfterSimulation = getPieceAt(targetQ, targetR);
            if (!destAfterSimulation || destAfterSimulation.player === piece.player) {
                // Restore original states
                originalAliveStates.forEach((alive, target) => {
                    target.alive = alive;
                });
                updatePins();
                return true; // Destination is gone or friendly, move is valid
            }
            
            const totalDamageInstances = 1; // Destination always takes 1 instance of damage
            
            // Check if the attacker is pinning this target (using simulated pin state)
            const occupantIndex = gameState.pieces.indexOf(destAfterSimulation);
            const attackerIndex = pieceIndex;
            const isPinningPiece = occupantIndex >= 0 &&
                                   gameState.pinningMap.has(occupantIndex) &&
                                   gameState.pinningMap.get(occupantIndex).has(attackerIndex);
            
            // Check if destination would die
            let wouldKill;
            if (isPinningPiece && destAfterSimulation.pinned) {
                // Attacker is pinning the target - must kill with damage, not insta-kill
                wouldKill = canKillWithRam(piece, destAfterSimulation, totalDamageInstances);
            } else {
                // Normal case: pinned pieces die instantly (unless pinned by attacker)
                wouldKill = destAfterSimulation.pinned || canKillWithRam(piece, destAfterSimulation, totalDamageInstances);
            }
            
            // Restore original states
            originalAliveStates.forEach((alive, target) => {
                target.alive = alive;
            });
            updatePins();
            
            return wouldKill;
        }

        function executeMove(pieceIndex, targetQ, targetR, move) {
            const piece = gameState.pieces[pieceIndex];
            const destOccupant = getPieceAt(targetQ, targetR);
            const ramDamage = gameState.unitConfigs[piece.type].ramDamage;
            
            // Validate the entire move by simulating it first
            if (!simulateMoveAndValidate(pieceIndex, targetQ, targetR, move, ramDamage)) {
                // Invalid move - don't execute anything
                addLog('Cannot land on enemy that would survive!', 'system');
                return false;
            }
            
            // Now that validation passed, apply damage along path (excluding destination)
            const piecesToDamage = [];
            if (move.damagePath) {
                move.damagePath.forEach(pos => {
                    // Skip destination - it will be handled separately
                    if (pos.q === targetQ && pos.r === targetR) return;
                    
                    const target = pos.piece || getPieceAt(pos.q, pos.r);
                    if (target && target.player !== piece.player) {
                        piecesToDamage.push(target);
                    }
                });
            }
            
            // Apply damage to pieces along path (not destination)
            piecesToDamage.forEach(target => {
                applyDamage(target, ramDamage, pieceIndex);
                // Recalculate pins after each kill (pinned pieces might have been killed)
                updatePins();
            });
            
            // Handle enemy at destination (we've already validated it will die)
            if (destOccupant && destOccupant.player !== piece.player) {
                applyDamage(destOccupant, ramDamage, pieceIndex);
                // Recalculate pins after damage/kill
                updatePins();
                // Double-check that it actually died
                if (destOccupant.alive) {
                    console.error('Move validation error - destination survived');
                    addLog('Cannot land on enemy that would survive!', 'system');
                    return false;
                }
            }
            
            // Only move the piece if we got here (all validations passed and destination died if it was an enemy)
            piece.q = targetQ;
            piece.r = targetR;
            
            addLog(`${piece.player === 1 ? 'P1' : 'P2'} ${PIECE_TYPES[piece.type].name} moves to (${targetQ}, ${targetR})`, piece.player);
            
            // Check victory
            if (targetQ === 0 && targetR === 0 && PIECE_TYPES[piece.type].isKing) {
                endGame(piece.player, 'throne');
                return true;
            }
            
            // Update pins after move
            updatePins();
            
            // Check army elimination
            checkArmyElimination();
            
            return true;
        }

        function applyDamage(piece, damage, attackerIndex = null) {
            // Find the piece index
            const pieceIndex = gameState.pieces.indexOf(piece);
            
            // Check if the attacker is one of the pieces pinning this target
            const isPinningPiece = attackerIndex !== null && 
                                   pieceIndex >= 0 &&
                                   gameState.pinningMap.has(pieceIndex) &&
                                   gameState.pinningMap.get(pieceIndex).has(attackerIndex);
            
            // Pinned pieces die immediately when dealt any damage (including King)
            // BUT NOT if the attacker is one of the pieces pinning them
            if (piece.pinned && !isPinningPiece) {
                piece.alive = false;
                if (PIECE_TYPES[piece.type].isKing) {
                    addLog(`${piece.player === 1 ? 'P1' : 'P2'} King destroyed (pinned)!`, 'system');
                    endGame(piece.player === 1 ? 2 : 1, 'kingkill');
                } else {
                    addLog(`${piece.player === 1 ? 'P1' : 'P2'} ${PIECE_TYPES[piece.type].name} destroyed (pinned)`, piece.player);
                }
                return;
            }
            
            if (PIECE_TYPES[piece.type].isKing) {
                // King can only be damaged if pinned (and not by pinning piece)
                // If pinned and attacked by pinning piece, apply normal damage
                if (piece.pinned && isPinningPiece) {
                    piece.hp -= damage;
                    if (piece.hp <= 0) {
                        piece.alive = false;
                        addLog(`${piece.player === 1 ? 'P1' : 'P2'} King destroyed!`, 'system');
                        endGame(piece.player === 1 ? 2 : 1, 'kingkill');
                    }
                }
                return;
            }
            
            piece.hp -= damage;
            if (piece.hp <= 0) {
                piece.alive = false;
                addLog(`${piece.player === 1 ? 'P1' : 'P2'} ${PIECE_TYPES[piece.type].name} destroyed`, piece.player);
            }
        }

        function updatePins() {
            // Only calculate pins for the current active player
            const activePlayer = gameState.currentPlayer;
            
            // Reset all pin states
            gameState.pieces.forEach(piece => {
                if (piece.alive) {
                    piece.pinned = false;
                }
            });
            
            // Clear pinning paths and pinning map
            gameState.pinningPaths = [];
            gameState.pinningMap.clear();
            
            // Group pieces by player
            const piecesByPlayer = { 1: [], 2: [] };
            gameState.pieces.forEach(piece => {
                if (piece.alive) {
                    piecesByPlayer[piece.player].push(piece);
                }
            });
            
            // Only check paths from the active player's pieces
            const allies = piecesByPlayer[activePlayer];
            const enemies = piecesByPlayer[activePlayer === 1 ? 2 : 1];
            
            // Check all pairs of allies from the active player
            for (let i = 0; i < allies.length; i++) {
                for (let j = i + 1; j < allies.length; j++) {
                    const ally1 = allies[i];
                    const ally2 = allies[j];
                    
                    // Find all valid paths between these allies
                    const paths = findValidPinningPaths(ally1, ally2);
                    
                    // For each path, check if enemies exist at every cell (excluding endpoints)
                    paths.forEach(path => {
                        if (isPathPinned(path, enemies)) {
                            // Store this pinning path for visualization (with player info)
                            gameState.pinningPaths.push({ path: path, player: activePlayer });
                            
                            // Find the indices of the pinning allies
                            const ally1Index = gameState.pieces.findIndex(p => p === ally1);
                            const ally2Index = gameState.pieces.findIndex(p => p === ally2);
                            
                            // Mark all enemies on this path as pinned and track which allies are pinning them
                            path.forEach(step => {
                                if (step.q === ally1.q && step.r === ally1.r) return;
                                if (step.q === ally2.q && step.r === ally2.r) return;
                                
                                const enemy = getPieceAt(step.q, step.r);
                                if (enemy && enemy.player !== activePlayer && enemy.alive) {
                                    enemy.pinned = true;
                                    
                                    // Track which allies are pinning this enemy
                                    const enemyIndex = gameState.pieces.findIndex(p => p === enemy);
                                    if (!gameState.pinningMap.has(enemyIndex)) {
                                        gameState.pinningMap.set(enemyIndex, new Set());
                                    }
                                    gameState.pinningMap.get(enemyIndex).add(ally1Index);
                                    gameState.pinningMap.get(enemyIndex).add(ally2Index);
                                }
                            });
                        }
                    });
                }
            }
            
            // Render pinning paths
            renderPinningPaths();
            
            // Check if all enemies are pinned (win condition)
            checkAllEnemiesPinned();
        }

        function renderPinningPaths() {
            const pinningGroup = document.getElementById('pinning-paths-group');
            if (!pinningGroup) return;
            
            // Clear existing paths
            pinningGroup.innerHTML = '';
            
            // Render each pinning path
            gameState.pinningPaths.forEach(pinningData => {
                const path = pinningData.path;
                const player = pinningData.player;
                
                if (path.length < 2) return;
                
                // Create a path element
                const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                
                // Build path data
                let pathData = '';
                path.forEach((step, index) => {
                    const { x, y } = hexToPixel(step.q, step.r);
                    if (index === 0) {
                        pathData += `M ${x} ${y}`;
                    } else {
                        pathData += ` L ${x} ${y}`;
                    }
                });
                
                // Use team color for the pin line
                const teamColor = player === 1 ? 'var(--player1)' : 'var(--player2)';
                // Make blue (player 2) pins more visible
                const opacity = player === 2 ? '0.6' : '0.4';
                const strokeWidth = player === 2 ? '3' : '2';
                
                pathElement.setAttribute('d', pathData);
                pathElement.setAttribute('stroke', teamColor);
                pathElement.setAttribute('stroke-width', strokeWidth);
                pathElement.setAttribute('fill', 'none');
                pathElement.setAttribute('opacity', opacity);
                pathElement.setAttribute('stroke-dasharray', '4 4');
                pathElement.style.pointerEvents = 'none';
                
                pinningGroup.appendChild(pathElement);
            });
        }

        function findValidPinningPaths(start, end) {
            const paths = [];
            const startRing = getRing(start.q, start.r);
            const endRing = getRing(end.q, end.r);
            
            // Try strictly monotonic paths (no throne)
            if (startRing < endRing) {
                // Strictly increasing
                findMonotonicPath(start.q, start.r, end.q, end.r, startRing, endRing, true, []);
            } else if (startRing > endRing) {
                // Strictly decreasing
                findMonotonicPath(start.q, start.r, end.q, end.r, startRing, endRing, false, []);
            }
            
            // Try paths that go through throne (allows direction reversal)
            // Determine initial direction based on start and target
            // We can start increasing or decreasing, then reverse at throne
            if (startRing !== endRing) {
                // Try starting decreasing, then reverse to increasing
                // This allows paths like: ring 1 -> throne -> ring 1 -> ring 2
                if (endRing > startRing) {
                    findPathThroughThrone(start.q, start.r, end.q, end.r, startRing, endRing, false, true, [], undefined);
                }
                // Try starting decreasing, then exit throne (for cases like ring 2 -> throne -> ring 1)
                if (endRing < startRing) {
                    // When going from higher ring to lower ring through throne:
                    // Decrease to throne (2 -> 1 -> 0), exit opposite to ring 1, target at ring 1
                    // So: beforeIncreasing=false (decreasing), afterIncreasing=true (but we exit to target ring, so it doesn't matter)
                    findPathThroughThrone(start.q, start.r, end.q, end.r, startRing, endRing, false, true, [], undefined);
                    // Also try the reverse: might need to go through throne differently
                    // Actually, for endRing < startRing, we always need to decrease to throne, so only one path needed
                }
            } else {
                // Same ring - must use throne to create valid path
                // Start decreasing to throne, then reverse to increasing
                if (startRing > 0) {
                    findPathThroughThrone(start.q, start.r, end.q, end.r, startRing, endRing, false, true, [], undefined);
                }
            }
            
            function findMonotonicPath(q, r, targetQ, targetR, currentRing, targetRing, increasing, path) {
                const currentPath = [...path, { q, r }];
                
                // Reached target
                if (q === targetQ && r === targetR) {
                    paths.push(currentPath);
                    return;
                }
                
                // Limit path length
                if (currentPath.length >= 15) return;
                
                for (let dir = 0; dir < 6; dir++) {
                    const neighbor = hexNeighbor(q, r, dir);
                    if (!isValidHex(neighbor.q, neighbor.r)) continue;
                    
                    const neighborRing = getRing(neighbor.q, neighbor.r);
                    
                    // Check if already in path
                    if (currentPath.some(step => step.q === neighbor.q && step.r === neighbor.r)) continue;
                    
                    // Must be strictly monotonic
                    if (increasing) {
                        if (neighborRing <= currentRing || neighborRing > targetRing) continue;
                    } else {
                        if (neighborRing >= currentRing || neighborRing < targetRing) continue;
                    }
                    
                    findMonotonicPath(neighbor.q, neighbor.r, targetQ, targetR, neighborRing, targetRing, increasing, currentPath);
                }
            }
            
            function findPathThroughThrone(q, r, targetQ, targetR, currentRing, targetRing, beforeIncreasing, afterIncreasing, path, throneEntryDir) {
                const currentPath = [...path, { q, r }];
                
                // Reached target
                if (q === targetQ && r === targetR && currentPath.length > 1) {
                    paths.push(currentPath);
                    return;
                }
                
                // Limit path length
                if (currentPath.length >= 15) return;
                
                const isBeforeThrone = throneEntryDir === undefined && currentRing !== 0;
                const isAtThrone = currentRing === 0;
                const isAfterThrone = throneEntryDir !== undefined && currentRing !== 0;
                
                for (let dir = 0; dir < 6; dir++) {
                    const neighbor = hexNeighbor(q, r, dir);
                    if (!isValidHex(neighbor.q, neighbor.r)) continue;
                    
                    const neighborRing = getRing(neighbor.q, neighbor.r);
                    
                    // Check if already in path
                    if (currentPath.some(step => step.q === neighbor.q && step.r === neighbor.r)) continue;
                    
                    if (isBeforeThrone) {
                        // Before throne - follow initial direction toward throne
                        const increasing = beforeIncreasing;
                        if (increasing) {
                            if (neighborRing <= currentRing) continue; // Must increase
                        } else {
                            if (neighborRing >= currentRing) continue; // Must decrease
                        }
                        
                        if (neighborRing === 0) {
                            // Entering throne - remember entry direction
                            // When we move from current cell to throne in direction 'dir',
                            // the throne sees us entering from direction (dir + 3) % 6
                            const entryDir = (dir + 3) % 6;
                            findPathThroughThrone(neighbor.q, neighbor.r, targetQ, targetR, 0, targetRing, beforeIncreasing, afterIncreasing, currentPath, entryDir);
                        } else {
                            // Continue toward throne
                            findPathThroughThrone(neighbor.q, neighbor.r, targetQ, targetR, neighborRing, targetRing, beforeIncreasing, afterIncreasing, currentPath, undefined);
                        }
                    } else if (isAtThrone) {
                        // At throne - must exit opposite direction
                        if (neighborRing === 0) continue; // Can't stay at throne
                        // Check if exit direction is opposite to entry direction
                        // throneEntryDir is the direction FROM which we entered (from throne's perspective)
                        // dir is the direction we're going TO exit
                        // They should be opposite: exit should be (throneEntryDir + 3) % 6
                        const requiredExitDir = (throneEntryDir + 3) % 6;
                        if (dir !== requiredExitDir) continue; // Must exit opposite to entry
                        
                        // Check if we're exiting directly to the target
                        // (This will also be checked at the start of the recursive call, but being explicit here)
                        if (neighbor.q === targetQ && neighbor.r === targetR) {
                            // Exiting directly to target - path is complete
                            const finalPath = [...currentPath, { q: neighbor.q, r: neighbor.r }];
                            paths.push(finalPath);
                            continue;
                        }
                        
                        // After throne, follow reversed direction
                        findPathThroughThrone(neighbor.q, neighbor.r, targetQ, targetR, neighborRing, targetRing, beforeIncreasing, afterIncreasing, currentPath, throneEntryDir);
                    } else if (isAfterThrone) {
                        // After throne - follow final direction toward target
                        // Special case: if we just exited to ring 1 and target is also at ring 1,
                        // we can only end at the exact exit cell (opposite of entry), not other ring 1 cells
                        if (currentRing === targetRing && currentRing === 1) {
                            // We're at ring 1 after exiting throne
                            // First check if we're already at the target (should be caught by "Reached target" at start, but double-check)
                            if (q === targetQ && r === targetR) {
                                // We're at the target - path should already be added by "Reached target" check
                                // But continue to check neighbors just in case
                            }
                            // Check if neighbor is the target - if so, allow it
                            if (neighborRing === 1) {
                                if (neighbor.q === targetQ && neighbor.r === targetR) {
                                    // Neighbor is the target - allow reaching it
                                    findPathThroughThrone(neighbor.q, neighbor.r, targetQ, targetR, neighborRing, targetRing, beforeIncreasing, afterIncreasing, currentPath, throneEntryDir);
                                }
                                // Don't allow moving to other ring 1 cells
                                continue;
                            }
                            // Allow continuing to other rings if needed
                        }
                        
                        const increasing = afterIncreasing;
                        if (increasing) {
                            if (neighborRing <= currentRing) continue; // Must strictly increase
                            if (neighborRing > targetRing) continue; // Can't exceed target
                        } else {
                            if (neighborRing >= currentRing) continue; // Must strictly decrease
                            if (neighborRing < targetRing) continue; // Can't go below target
                        }
                        
                        findPathThroughThrone(neighbor.q, neighbor.r, targetQ, targetR, neighborRing, targetRing, beforeIncreasing, afterIncreasing, currentPath, throneEntryDir);
                    }
                }
            }
            
            return paths;
        }

        function getDirectionFrom(from, to) {
            // Find which direction from 'from' to 'to'
            for (let dir = 0; dir < 6; dir++) {
                const neighbor = hexNeighbor(from.q, from.r, dir);
                if (neighbor.q === to.q && neighbor.r === to.r) {
                    return dir;
                }
            }
            return -1;
        }

        function isPathPinned(path, enemies) {
            // Check if every cell along the path (excluding endpoints) has an enemy
            for (let i = 1; i < path.length - 1; i++) {
                const step = path[i];
                const occupant = getPieceAt(step.q, step.r);
                
                // Must have an enemy at this position
                if (!occupant || !occupant.alive) return false;
                if (!enemies.includes(occupant)) return false;
            }
            
            return path.length > 2; // Path must have at least 3 cells (start, middle, end)
        }

        function executeRotation(ring, clockwise) {
            const ringHexes = getHexesInRing(ring);
            const piecesInRing = gameState.pieces.filter(p => 
                p.alive && getRing(p.q, p.r) === ring
            );
            
            // Rotate each piece
            piecesInRing.forEach(piece => {
                const rotated = rotateHexAroundCenter(piece.q, piece.r, clockwise ? 1 : -1);
                piece.q = rotated.q;
                piece.r = rotated.r;
            });
            
            addLog(`${gameState.currentPlayer === 1 ? 'P1' : 'P2'} King rotates ring ${ring} ${clockwise ? 'CW' : 'CCW'}`, gameState.currentPlayer);
            
            // Update pins after rotation
            updatePins();
            
            // Check for pin + ram kills
            checkPinnedKings();
        }

        function checkPinnedKings() {
            gameState.pieces.forEach(piece => {
                if (piece.alive && PIECE_TYPES[piece.type].isKing && piece.pinned) {
                    // Check if any adjacent enemy can ram
                    // This is evaluated after rotation
                }
            });
        }

        function checkArmyElimination() {
            [1, 2].forEach(player => {
                const nonKingPieces = gameState.pieces.filter(p => 
                    p.player === player && p.alive && !PIECE_TYPES[p.type].isKing
                );
                if (nonKingPieces.length === 0) {
                    endGame(player === 1 ? 2 : 1, 'elimination');
                }
            });
        }

        function checkAllEnemiesPinned() {
            [1, 2].forEach(player => {
                const enemyPlayer = player === 1 ? 2 : 1;
                const enemyPieces = gameState.pieces.filter(p => 
                    p.player === enemyPlayer && p.alive
                );
                
                // If there are no enemy pieces, skip (already handled by elimination check)
                if (enemyPieces.length === 0) return;
                
                // Check if all enemy pieces are pinned
                const allPinned = enemyPieces.every(piece => piece.pinned);
                
                if (allPinned) {
                    endGame(player, 'allpinned');
                }
            });
        }

        function endGame(winner, reason) {
            gameState.phase = 'ended';
            
            const reasons = {
                throne: `Player ${winner} captures the Throne!`,
                kingkill: `Player ${winner} destroys the enemy King!`,
                elimination: `Player ${winner} eliminates all enemy units!`,
                allpinned: `Player ${winner} pins all enemy pieces!`
            };
            
            document.getElementById('victory-title').textContent = `Player ${winner} Wins!`;
            document.getElementById('victory-message').textContent = reasons[reason];
            document.getElementById('victory-modal').classList.add('active');
            
            addLog(`VICTORY: ${reasons[reason]}`, 'system');
        }

        function useAction(pieceIndex) {
            gameState.usedPieces.add(pieceIndex);
            gameState.hasAnyPieceMoved = true;
            gameState.actionsRemaining--;
            
            document.getElementById('actions-count').textContent = gameState.actionsRemaining;
            
            if (gameState.actionsRemaining <= 0) {
                endTurn();
            }
        }

        function endTurn() {
            if (gameState.pathBuilding) {
                cancelPathBuilding();
            }
            
            // Clear all pins at the end of the turn
            gameState.pieces.forEach(piece => {
                if (piece.alive) {
                    piece.pinned = false;
                }
            });
            gameState.pinningPaths = [];
            gameState.pinningMap.clear();
            
            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
            
            // After the first turn, all players get 2 actions
            if (gameState.isFirstTurn) {
                gameState.isFirstTurn = false;
            }
            gameState.actionsRemaining = gameState.params.actionsPerTurn;
            
            gameState.usedPieces.clear();
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            
            // Recalculate pins for the new active player
            updatePins();
            
            updateUI();
            clearHighlights();
            renderPieces();
            document.getElementById('btn-rotate').style.display = 'none';
            
            addLog(`--- Player ${gameState.currentPlayer}'s Turn ---`, 'system');
        }

        // ============================================
        // INPUT HANDLING
        // ============================================

        function onHexClick(q, r, e) {
            if (gameState.phase !== 'playing') return;
            
            if (gameState.rotationMode) {
                handleRotationClick(q, r);
                return;
            }
            
            // Path building mode
            if (gameState.pathBuilding && gameState.pathStartPiece !== null) {
                const piece = gameState.pieces[gameState.pathStartPiece];
                const validNext = getValidNextSteps(piece, gameState.currentPath);
                const clickedStep = validNext.find(step => step.q === q && step.r === r);
                
                if (clickedStep) {
                    // Add this step to path
                    gameState.currentPath.push({ q, r });
                    updatePathVisualization();
                } else {
                    // Check if clicking the last step again (confirm move)
                    if (gameState.currentPath.length > 0) {
                        const last = gameState.currentPath[gameState.currentPath.length - 1];
                        if (last.q === q && last.r === r) {
                            confirmPathMove();
                            return;
                        }
                    }
                    // Invalid step - cancel path building
                    cancelPathBuilding();
                }
                return;
            }
            
            // Old behavior - deselect
            if (gameState.selectedPiece !== null) {
                gameState.selectedPiece = null;
                gameState.validMoves = [];
                clearHighlights();
                renderPieces();
                document.getElementById('btn-rotate').style.display = 'none';
            }
        }

        function onPieceClick(index) {
            const piece = gameState.pieces[index];
            
            if (gameState.phase !== 'playing') return;
            
            // In rotation mode, treat piece clicks same as hex clicks - select the ring
            if (gameState.rotationMode) {
                handleRotationClick(piece.q, piece.r);
                return;
            }
            
            // If we're in path building mode, check if this piece is on a valid next step
            if (gameState.pathBuilding && gameState.pathStartPiece !== null) {
                const pathPiece = gameState.pieces[gameState.pathStartPiece];
                const validNext = getValidNextSteps(pathPiece, gameState.currentPath);
                const clickedStep = validNext.find(step => step.q === piece.q && step.r === piece.r);
                
                if (clickedStep) {
                    // This piece is on a valid move tile - continue the path
                    gameState.currentPath.push({ q: piece.q, r: piece.r });
                    updatePathVisualization();
                    return;
                } else {
                    // This piece is not on a valid move tile - cancel path building
                    cancelPathBuilding();
                }
            }
            
            // Select the piece type in the unit editor
            selectUnitForEdit(piece.type);
            
            // Select own piece - start path building
            if (piece.player === gameState.currentPlayer && !gameState.usedPieces.has(index)) {
                // Pinned pieces cannot be selected
                if (piece.pinned) {
                    addLog('Pinned pieces cannot move or take actions!', 'system');
                    return;
                }
                startPathBuilding(index);
            }
        }

        function startPathBuilding(pieceIndex) {
            const piece = gameState.pieces[pieceIndex];
            
            // Pinned pieces cannot take actions
            if (piece.pinned) {
                addLog('Pinned pieces cannot move or take actions!', 'system');
                return;
            }
            
            gameState.pathBuilding = true;
            gameState.pathStartPiece = pieceIndex;
            gameState.currentPath = [];
            gameState.selectedPiece = pieceIndex;
            
            // Show rotate button if King (and not pinned)
            const rotateBtn = document.getElementById('btn-rotate');
            if (PIECE_TYPES[piece.type].isKing && !piece.pinned) {
                rotateBtn.style.display = 'block';
            } else {
                rotateBtn.style.display = 'none';
            }
            
            updatePathVisualization();
        }

        function cancelPathBuilding() {
            gameState.pathBuilding = false;
            gameState.currentPath = [];
            gameState.pathStartPiece = null;
            gameState.selectedPiece = null;
            clearHighlights();
            renderPieces();
            document.getElementById('btn-rotate').style.display = 'none';
            document.getElementById('btn-confirm-path').style.display = 'none';
            document.getElementById('btn-cancel-path').style.display = 'none';
        }

        function updatePathVisualization() {
            if (!gameState.pathBuilding || gameState.pathStartPiece === null) return;
            
            const piece = gameState.pieces[gameState.pathStartPiece];
            const validNext = getValidNextSteps(piece, gameState.currentPath);
            
            clearHighlights();
            
            // Highlight current path
            gameState.currentPath.forEach((step, idx) => {
                const hex = document.querySelector(`.hex[data-q="${step.q}"][data-r="${step.r}"]`);
                if (hex) {
                    if (idx === gameState.currentPath.length - 1) {
                        hex.classList.add('path-end'); // Last step highlighted more prominently
                    } else {
                        hex.classList.add('path-step'); // Intermediate steps
                    }
                }
            });
            
            // Highlight valid next steps
            validNext.forEach(step => {
                const hex = document.querySelector(`.hex[data-q="${step.q}"][data-r="${step.r}"]`);
                if (hex) {
                    if (step.hasEnemy) {
                        hex.classList.add('damage-path');
                    } else {
                        hex.classList.add('valid-move');
                    }
                }
            });
            
            // Show confirm/cancel buttons
            const confirmBtn = document.getElementById('btn-confirm-path');
            const cancelBtn = document.getElementById('btn-cancel-path');
            if (gameState.currentPath.length > 0) {
                confirmBtn.style.display = 'block';
            } else {
                confirmBtn.style.display = 'none';
            }
            cancelBtn.style.display = 'block';
            
            renderPieces();
        }

        function confirmPathMove() {
            if (!gameState.pathBuilding || gameState.pathStartPiece === null || gameState.currentPath.length === 0) {
                return;
            }
            
            const piece = gameState.pieces[gameState.pathStartPiece];
            const destination = gameState.currentPath[gameState.currentPath.length - 1];
            const damagePath = calculateDamagePath(piece, gameState.currentPath);
            
            // Check if destination is valid
            const occupant = getPieceAt(destination.q, destination.r);
            
            // Cannot land on friendly
            if (occupant && occupant.player === piece.player) {
                addLog('Cannot land on friendly unit!', 'system');
                return;
            }
            
            // If landing on enemy, must kill it
            if (occupant && occupant.player !== piece.player) {
                // Check if destination is already in damagePath (would only take 1 instance of damage)
                const destInPath = damagePath.some(pos => pos.q === destination.q && pos.r === destination.r);
                const totalDamageInstances = destInPath ? damagePath.length : damagePath.length + 1;
                
                // Check if the attacker is pinning this target
                const occupantIndex = gameState.pieces.indexOf(occupant);
                const attackerIndex = gameState.pathStartPiece;
                const isPinningPiece = occupantIndex >= 0 &&
                                       gameState.pinningMap.has(occupantIndex) &&
                                       gameState.pinningMap.get(occupantIndex).has(attackerIndex);
                
                // If the attacker is pinning the target, they can't insta-kill it
                // They must deal enough damage to kill it normally
                let wouldKill;
                if (isPinningPiece && occupant.pinned) {
                    // Attacker is pinning the target - must kill with damage, not insta-kill
                    wouldKill = canKillWithRam(piece, occupant, totalDamageInstances);
                    if (!wouldKill) {
                        addLog('Cannot kill piece that you are pinning!', 'system');
                        return;
                    }
                } else {
                    // Normal case: pinned pieces die instantly (unless pinned by attacker)
                    wouldKill = occupant.pinned || canKillWithRam(piece, occupant, totalDamageInstances);
                    if (!wouldKill) {
                        addLog('Cannot land on enemy that would survive!', 'system');
                        return;
                    }
                }
            }
            
            // Execute the move
            const move = {
                q: destination.q,
                r: destination.r,
                damagePath: damagePath,
                willKill: occupant && occupant.player !== piece.player,
                path: gameState.currentPath
            };
            
            // Only consume action if move succeeds
            const moveSucceeded = executeMove(gameState.pathStartPiece, destination.q, destination.r, move);
            if (!moveSucceeded) {
                // Move was rejected - don't consume action, don't clean up path building
                // User can try a different move
                return;
            }
            
            useAction(gameState.pathStartPiece);
            
            // Clean up
            cancelPathBuilding();
            updateArmyDisplay();
        }


        function handleRotationClick(q, r) {
            const ring = getRing(q, r);
            if (ring === 0 || ring > BOARD_RADIUS) return;
            
            gameState.selectedRing = ring;
            document.getElementById('rotation-ring').textContent = ring;
            
            // Highlight selected ring
            document.querySelectorAll('.ring-highlight').forEach(el => el.classList.remove('active'));
            document.getElementById(`ring-${ring}`).classList.add('active');
        }

        function setupRotationControls() {
            document.getElementById('rotate-cw').addEventListener('click', () => {
                if (gameState.selectedRing) {
                    executeRotation(gameState.selectedRing, true);
                    exitRotationMode();
                    useAction(gameState.selectedPiece);
                    gameState.selectedPiece = null;
                    renderPieces();
                }
            });
            
            document.getElementById('rotate-ccw').addEventListener('click', () => {
                if (gameState.selectedRing) {
                    executeRotation(gameState.selectedRing, false);
                    exitRotationMode();
                    useAction(gameState.selectedPiece);
                    gameState.selectedPiece = null;
                    renderPieces();
                }
            });
            
            document.getElementById('rotate-cancel').addEventListener('click', () => {
                exitRotationMode();
            });
        }

        function enterRotationMode(pieceIndex) {
            const piece = gameState.pieces[pieceIndex];
            if (!PIECE_TYPES[piece.type].isKing) return;
            
            // Pinned pieces cannot take actions
            if (piece.pinned) {
                addLog('Pinned pieces cannot move or take actions!', 'system');
                return;
            }
            
            gameState.rotationMode = true;
            gameState.selectedRing = 1;
            
            const controls = document.getElementById('rotation-controls');
            controls.style.display = 'flex';
            controls.style.top = '80px';
            controls.style.left = '50%';
            controls.style.transform = 'translateX(-50%)';
            
            document.getElementById('rotation-ring').textContent = '1';
            document.getElementById(`ring-1`).classList.add('active');
        }

        function exitRotationMode() {
            gameState.rotationMode = false;
            gameState.selectedRing = null;
            document.getElementById('rotation-controls').style.display = 'none';
            document.querySelectorAll('.ring-highlight').forEach(el => el.classList.remove('active'));
        }

        // ============================================
        // UI UPDATES
        // ============================================

        function updateUI() {
            const indicator = document.getElementById('turn-indicator');
            indicator.className = `turn-indicator player${gameState.currentPlayer}`;
            indicator.querySelector('.player-name').textContent = `Player ${gameState.currentPlayer}`;
            document.getElementById('actions-count').textContent = gameState.actionsRemaining;
            
            document.getElementById('game-phase').textContent = 
                gameState.phase === 'playing' ? 'BATTLE PHASE' : 'GAME OVER';
            
            document.getElementById('btn-end-turn').disabled = gameState.phase !== 'playing';
        }


        function updateArmyDisplay() {
            [1, 2].forEach(player => {
                const container = document.getElementById(`army-p${player}`);
                container.innerHTML = '';
                
                gameState.pieces.filter(p => p.player === player).forEach((piece, idx) => {
                    const div = document.createElement('div');
                    div.className = `army-piece player${player}`;
                    if (!piece.alive) div.classList.add('dead');
                    if (piece.pinned) div.classList.add('pinned');
                    div.textContent = PIECE_TYPES[piece.type].symbol;
                    div.title = `${PIECE_TYPES[piece.type].name} HP: ${piece.hp}`;
                    container.appendChild(div);
                });
            });
        }


        function addLog(message, type = 'system') {
            const log = document.getElementById('game-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type === 1 ? 'player1' : type === 2 ? 'player2' : 'system'}`;
            entry.textContent = message;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // ============================================
        // UNIT EDITOR
        // ============================================

        function setupUnitEditor() {
            const selector = document.getElementById('unit-selector');
            
            Object.entries(PIECE_TYPES).forEach(([type, info]) => {
                const btn = document.createElement('button');
                btn.className = 'unit-btn';
                btn.dataset.type = type;
                btn.textContent = info.symbol;
                btn.title = info.name;
                btn.addEventListener('click', () => selectUnitForEdit(type));
                selector.appendChild(btn);
            });
            
            setupTemplateSelector();
        }

        function selectUnitForEdit(type) {
            document.querySelectorAll('.unit-btn').forEach(b => b.classList.remove('active'));
            // Find and activate the button for this unit type
            const btn = document.querySelector(`.unit-btn[data-type="${type}"]`);
            if (btn) {
                btn.classList.add('active');
            }
            
            document.getElementById('unit-details').style.display = 'block';
            
            const config = gameState.unitConfigs[type];
            const rangeInput = document.getElementById('unit-range');
            rangeInput.value = config.range;
            
            // Disable range input for King (always 1)
            if (type === 'KING') {
                rangeInput.disabled = true;
                rangeInput.title = 'King move range is always 1';
            } else {
                rangeInput.disabled = false;
                rangeInput.title = '';
            }
            
            document.getElementById('unit-hp').value = config.hp === Infinity ? 999 : config.hp;
            
            // Disable Max HP if it's Infinity (King) or if any piece has ever moved
            const hpInput = document.getElementById('unit-hp');
            hpInput.disabled = config.hp === Infinity || gameState.hasAnyPieceMoved;
            if (gameState.hasAnyPieceMoved) {
                hpInput.title = 'Cannot change Max HP: pieces have already moved';
            } else {
                hpInput.title = '';
            }
            
            document.getElementById('unit-ram-damage').value = config.ramDamage;
            
            // Update template selector
            document.querySelectorAll('.template-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.template === config.template);
            });
            
            // Store current editing type
            document.getElementById('unit-details').dataset.type = type;
        }

        function setupTemplateSelector() {
            const selector = document.getElementById('template-selector');
            selector.innerHTML = '';
            
            // Create template buttons
            const templates = [
                { id: MOVEMENT_TEMPLATES.FREE_MOTION, label: 'Free Motion', desc: 'Move in any direction' },
                { id: MOVEMENT_TEMPLATES.STRAIGHT_LINE, label: 'Straight Line', desc: 'Pick one direction, continue straight' }
            ];
            
            templates.forEach(template => {
                const btn = document.createElement('button');
                btn.className = 'template-btn';
                btn.dataset.template = template.id;
                btn.innerHTML = `<div style="font-weight: 600; margin-bottom: 4px;">${template.label}</div><div style="font-size: 10px; color: var(--text-muted);">${template.desc}</div>`;
                btn.addEventListener('click', () => selectTemplate(template.id));
                selector.appendChild(btn);
            });
            
            // Range input handler
            document.getElementById('unit-range').addEventListener('change', (e) => {
                const type = document.getElementById('unit-details').dataset.type;
                if (type) {
                    gameState.unitConfigs[type].range = parseInt(e.target.value);
                }
            });
            
            // HP input handler
            document.getElementById('unit-hp').addEventListener('change', (e) => {
                const type = document.getElementById('unit-details').dataset.type;
                if (type) {
                    // Check if any piece has ever moved
                    if (gameState.hasAnyPieceMoved) {
                        // Revert the value - can't change if pieces have moved
                        const config = gameState.unitConfigs[type];
                        e.target.value = config.hp === Infinity ? 999 : config.hp;
                        return;
                    }
                    
                    const value = parseInt(e.target.value);
                    const newHP = value === 999 ? Infinity : value;
                    gameState.unitConfigs[type].hp = newHP;
                    
                    // Update all existing pieces of this type
                    gameState.pieces.forEach(piece => {
                        if (piece.type === type && piece.alive) {
                            piece.maxHP = newHP;
                            // Set current HP to new max HP (heal to full)
                            piece.hp = newHP;
                        }
                    });
                    
                    // Update the display
                    renderPieces();
                    updateArmyDisplay();
                }
            });
            
            // Ram damage input handler
            document.getElementById('unit-ram-damage').addEventListener('change', (e) => {
                const type = document.getElementById('unit-details').dataset.type;
                if (type) {
                    gameState.unitConfigs[type].ramDamage = parseInt(e.target.value);
                }
            });
        }

        function selectTemplate(templateId) {
            const type = document.getElementById('unit-details').dataset.type;
            if (!type) return;
            
            gameState.unitConfigs[type].template = templateId;
            
            // Update UI
            document.querySelectorAll('.template-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.template === templateId);
            });
        }

        // ============================================
        // PARAMETERS
        // ============================================

        function setupParams() {
            document.getElementById('param-actions').addEventListener('change', (e) => {
                gameState.params.actionsPerTurn = parseInt(e.target.value);
                gameState.actionsRemaining = gameState.params.actionsPerTurn;
                document.getElementById('actions-count').textContent = gameState.actionsRemaining;
            });
        }

        // ============================================
        // GAME CONTROLS
        // ============================================

        function startGame() {
            gameState.phase = 'playing';
            gameState.currentPlayer = 1;
            gameState.isFirstTurn = true;
            // First player gets only 1 action on their first turn
            gameState.actionsRemaining = 1;
            
            updatePins();
            updateUI();
            renderPieces();
            
            addLog('=== GAME STARTED ===', 'system');
            addLog(`Player 1's Turn (1 action)`, 'system');
        }

        function resetGame() {
            gameState.phase = 'playing';
            gameState.currentPlayer = 1;
            gameState.isFirstTurn = true;
            gameState.actionsRemaining = 1; // First player gets 1 action
            gameState.actionsPerTurn = gameState.params.actionsPerTurn;
            gameState.usedPieces = new Set();
            gameState.hasAnyPieceMoved = false;
            gameState.pieces = [];
            gameState.board = new Map();
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            gameState.rotationMode = false;
            gameState.selectedRing = null;
            gameState.pathBuilding = false;
            gameState.currentPath = [];
            gameState.pathStartPiece = null;
            gameState.pinningPaths = [];
            gameState.pinningMap.clear();
            
            document.getElementById('victory-modal').classList.remove('active');
            document.getElementById('game-log').innerHTML = '<div class="log-entry system">Game reset.</div>';
            
            setupFixedPositions();
            exitRotationMode();
            cancelPathBuilding();
            clearHighlights();
            renderPieces();
            updateUI();
            updateArmyDisplay();
            addLog('=== GAME STARTED ===', 'system');
            addLog(`Player 1's Turn`, 'system');
        }

        // ============================================
        // KEYBOARD SHORTCUTS
        // ============================================

        function setupKeyboard() {
            document.addEventListener('keydown', (e) => {
                if (gameState.phase !== 'playing') return;
                
                // R for rotation mode
                if (e.key === 'r' || e.key === 'R') {
                    if (gameState.selectedPiece !== null) {
                        const piece = gameState.pieces[gameState.selectedPiece];
                        if (PIECE_TYPES[piece.type].isKing && piece.player === gameState.currentPlayer) {
                            enterRotationMode(gameState.selectedPiece);
                        }
                    }
                }
                
                // Escape to cancel
                if (e.key === 'Escape') {
                    if (gameState.rotationMode) {
                        exitRotationMode();
                    } else if (gameState.pathBuilding) {
                        cancelPathBuilding();
                    } else {
                        gameState.selectedPiece = null;
                        gameState.validMoves = [];
                        clearHighlights();
                        renderPieces();
                    }
                }
                
                // Number keys for ring selection in rotation mode
                if (gameState.rotationMode && e.key >= '1' && e.key <= '5') {
                    const ring = parseInt(e.key);
                    gameState.selectedRing = ring;
                    document.getElementById('rotation-ring').textContent = ring;
                    document.querySelectorAll('.ring-highlight').forEach(el => el.classList.remove('active'));
                    document.getElementById(`ring-${ring}`).classList.add('active');
                }
            });
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        function init() {
            initUnitConfigs();
            createBoard();
            setupUnitEditor();
            setupParams();
            setupRotationControls();
            setupKeyboard();
            setupFixedPositions();
            updateArmyDisplay();
            updateUI();
            startGame();
            
            document.getElementById('btn-reset').addEventListener('click', resetGame);
            document.getElementById('btn-end-turn').addEventListener('click', endTurn);
            document.getElementById('btn-new-game').addEventListener('click', resetGame);
            document.getElementById('btn-confirm-path').addEventListener('click', confirmPathMove);
            document.getElementById('btn-cancel-path').addEventListener('click', cancelPathBuilding);
            document.getElementById('btn-rotate').addEventListener('click', () => {
                if (gameState.selectedPiece !== null) {
                    const piece = gameState.pieces[gameState.selectedPiece];
                    if (PIECE_TYPES[piece.type].isKing && piece.player === gameState.currentPlayer && !piece.pinned) {
                        enterRotationMode(gameState.selectedPiece);
                        document.getElementById('btn-rotate').style.display = 'none';
                    } else if (piece.pinned) {
                        addLog('Pinned pieces cannot move or take actions!', 'system');
                    }
                }
            });
        }

        // Start
        init();
    </script>
</body>
</html>

